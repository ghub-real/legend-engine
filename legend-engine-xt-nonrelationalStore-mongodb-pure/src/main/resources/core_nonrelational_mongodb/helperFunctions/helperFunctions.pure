import meta::pure::router::store::metamodel::*;
import meta::pure::router::routing::*;
import meta::pure::mapping::*;
import  meta::external::store::mongodb::metamodel::mapping::*;

function meta::external::store::mongodb::metamodel::mapping::findPropertyMapping(property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], currentPropertyMapping:PropertyMapping[*], propertyMappingFromRouter:PropertyMapping[*], mapping:Mapping[1],debug:DebugContext[1]):PropertyMapping[*]
{
   let propertyName = $property.name->toOne();
   let propertyMappings = if($currentPropertyMapping->size() >= 1  && $currentPropertyMapping->at(0)->instanceOf(EmbeddedMongoDbInstanceSetImplementation),
         | let embeddedPropertyMapping = $currentPropertyMapping->cast(@EmbeddedMongoDbInstanceSetImplementation)->map(c|$c.propertyMappingsByPropertyName($propertyName));

           let result = if( !$embeddedPropertyMapping->isEmpty()
                         ,|$embeddedPropertyMapping
                         ,|if(!$propertyMappingFromRouter->isEmpty()
                           ,| $propertyMappingFromRouter
                           ,| // this should only been done in the builder but will refactor as part of other fixes;
                              $currentPropertyMapping
                              ->filter(c | $c->match([
                                 //is: InlineEmbeddedRelationalInstanceSetImplementation[1] | $is.parent.classMappingById($is.inlineSetImplementationId)->toOne().class->_subTypeOf($propertyOwnerClass),
                                 a: Any[1] | true
                              ]))
                              ->map(c | $c->cast(@EmbeddedMongoDbInstanceSetImplementation)->propertyMappingsByPropertyName($propertyName));
                            );

                         );
           assert(!$result->isEmpty(), | 'The system can\'t find a mapping for the property \''+$propertyOwnerClass->elementToPath()+'.'+$propertyName+
                  '\' in the mapping \''+$mapping->elementToPath()+ '-> (Embedded)' + $currentPropertyMapping->at(0)->cast(@EmbeddedMongoDbInstanceSetImplementation).setMappingOwner.class.name->toOne() + '.' + $currentPropertyMapping->at(0).property.name->toOne() + '\'');
           $result;
         ,
         | let propMappings = if (!$propertyMappingFromRouter->isEmpty() && $propertyMappingFromRouter.property->removeDuplicates() == $property,
                 |$propertyMappingFromRouter->map(pm | $pm->meta::pure::router::routing::reprocessAggregationAwarePropertyMapping()),
                 |let rootClassMapping = $mapping.rootClassMappingByClass($propertyOwnerClass)->potentiallyResolveOperation($mapping);
                  let classMapping = if($rootClassMapping->isEmpty() && $propertyOwnerClass->instanceOf(MappingClass),
                                        | $mapping.classMappings()->filter(x | $x->instanceOf(InstanceSetImplementation) && $x->cast(@InstanceSetImplementation).mappingClass == $propertyOwnerClass),
                                        | $rootClassMapping);
                     assertSize($classMapping, 1, | 'The system can\'t find a mapping ('+$classMapping->size()->toString()+') for the class \''+$propertyOwnerClass->elementToPath()+'\' in the mapping \''+$mapping->elementToPath()+'\'');
                     let setImpls = $classMapping->resolveOperation($mapping);
                     let result = $setImpls->map(s|$s.propertyMappingsByPropertyName($propertyName))->map(pm | $pm->meta::pure::router::routing::reprocessAggregationAwarePropertyMapping());
                     assert(!$result->isEmpty(), | 'The system can\'t find a mapping for the property \''+$propertyOwnerClass->elementToPath()+'.'+$propertyName+'\' in the mapping \''+$mapping->elementToPath()+'\'');
                     $result;
              );
           if ($currentPropertyMapping->size() == 1 && ($propMappings->size() > 1),
              |//In this use case, the precedent mappings were filtered (and we have nothing to union ... so we can't take the first one)
               let result = $propMappings->filter(p|$p.sourceSetImplementationId == $currentPropertyMapping.targetSetImplementationId);
               assert(!$result->isEmpty(),| 'Error can\'t find a mapping for the property:\''+$property.name->toOne()+'\' (owner class:"'+$propertyOwnerClass.name->toOne()+'") in the set implement id:"'+$currentPropertyMapping.targetSetImplementationId->toOne()+'" in ['+$propMappings->map(p|$p.owner->toOne().id+' : ('+$p.sourceSetImplementationId+' -> '+$p.targetSetImplementationId+')')->joinStrings(',')+']');
               $result;,
              |$propMappings
           );
   );

   $propertyMappings->map({pm |
      $pm->match([
         i: InlineEmbeddedSetImplementation[1] | $i->inlineEmbeddedMapping($mapping),
         p: PropertyMapping[1]                 | $p
      ])
   });
}

function meta::external::store::mongodb::metamodel::mapping::findPropertySequence(v:ValueSpecification[1]):Pair<Class<Any>,AbstractProperty<Any>>[*]
{
   $v->match([
               fe:FunctionExpression[1]|
                     $fe.func->match(
                        [
                           p:AbstractProperty<Any>[1]|pair($fe.parametersValues->at(0).genericType.rawType->cast(@Class<Any>)->toOne(), $p)->concatenate(if($fe.parametersValues->size()==1,|$fe.parametersValues->at(0)->findPropertySequence(),|[]));,
                           f:NativeFunction<Any>[1]|if(($f == map_T_m__Function_1__V_m_ || $f == map_T_MANY__Function_1__V_MANY_) && $fe.parametersValues->at(1)->byPassRouterInfo()->instanceOf(InstanceValue),|pair($fe.parametersValues->at(0).genericType.rawType->cast(@Class<Any>)->toOne(), $fe.parametersValues->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)
                           ->match([a:AbstractProperty<Any>[1]|$a,
                                    l:LambdaFunction<Any>[1] |$l.expressionSequence->at(0)->byPassRouterInfo()->cast(@FunctionExpression).func;
                                   ])
                           ->cast(@AbstractProperty<Any>))->concatenate($fe.parametersValues->at(0)->findPropertySequence()),|[]),
                           a:Any[1]|[]
                        ]
                 );,
               e:StoreMappingRoutedValueSpecification[1]|$e->byPassRouterInfo()->findPropertySequence(),
               a:Any[1]|[];
            ])
}