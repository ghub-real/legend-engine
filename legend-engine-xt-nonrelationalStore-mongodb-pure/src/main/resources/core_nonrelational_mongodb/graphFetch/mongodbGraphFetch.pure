// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::graphFetch::execution::*;
import meta::external::store::mongodb::runtime::connections::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::external::store::mongodb::metamodel::aggregation::*;
import meta::external::store::mongodb::runtime::*;
import meta::pure::executionPlan::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;
import meta::external::store::mongodb::graphFetch::executionPlan::*;
import meta::external::store::mongodb::metamodel::mapping::*;
import meta::external::store::mongodb::metamodel::*;
import meta::external::store::mongodb::metamodel::runtime::*;
import meta::external::store::mongodb::mapping::functions::*;

import meta::external::store::mongodb::graphFetch::executionPlan::*;


Class meta::external::store::mongodb::graphFetch::executionPlan::DocumentGraphFetchExecutionNode extends LocalGraphFetchExecutionNode
{
   //<<doc.deprecated>> relationalNode : ExecutionNode[0..1];
   children : DocumentGraphFetchExecutionNode[*];
}

//Class <<doc.deprecated>> meta::relational::graphFetch::executionPlan::RelationalTempTableGraphFetchExecutionNode extends RelationalGraphFetchExecutionNode
//{
//   tempTableName : String[1];
//   columns : SQLResultColumn[*];
//}
//
//Class <<doc.deprecated>>  meta::relational::graphFetch::executionPlan::RelationalRootGraphFetchExecutionNode extends RelationalTempTableGraphFetchExecutionNode
//{
//}
//
//Class <<doc.deprecated>> meta::relational::graphFetch::executionPlan::RelationalCrossRootGraphFetchExecutionNode extends RelationalTempTableGraphFetchExecutionNode
//{
//   parentTempTableName : String[1];
//   parentTempTableColumns : SQLResultColumn[*];
//}

Class meta::external::store::mongodb::graphFetch::executionPlan::DocumentClassQueryTempTableGraphFetchExecutionNode extends DocumentGraphFetchExecutionNode  // By pass the temp table class RelationalTempTableGraphFetchExecutionNode
{
}

Class meta::external::store::mongodb::graphFetch::executionPlan::DocumentPrimitiveQueryGraphFetchExecutionNode extends DocumentGraphFetchExecutionNode
{
}

Class meta::external::store::mongodb::graphFetch::executionPlan::DocumentRootQueryTempTableGraphFetchExecutionNode extends DocumentClassQueryTempTableGraphFetchExecutionNode
{
  batchSize : Integer[0..1];
  enableConstraints : Boolean[1];
  checked : Boolean[1];
  databaseCommand: DatabaseCommand[1];
  //tempCollectionName: String[1];
}

// Class meta::relational::graphFetch::executionPlan::DocumentStoreCrossRootQueryTempTableGraphFetchExecutionNode extends RelationalClassQueryTempTableGraphFetchExecutionNode
// {
//   parentTempTableName    : String[1];
//   parentTempTableColumns : SQLResultColumn[*];
// }

//function <<access.private>> meta::relational::graphFetch::executionPlan::tempTableName(index: Integer[1]):String[1]
//{
//   'temp_table_node_' + toString($index)
//}
//
//function <<access.private>> meta::relational::graphFetch::executionPlan::crossTempTableName(index: Integer[1]):String[1]
//{
//   'cross_temp_table_node_' + toString($index)
//}

function meta::external::store::mongodb::graphFetch::executionPlan::planRootGraphFetchExecutionMongoDb(sq: StoreQuery[1], ext: RoutedValueSpecification[0..1], clusteredTree: ClusteredGraphFetchTree[1], orderedPaths: String[*], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], enableConstraints: Boolean[1], checked: Boolean[1], extensions: Extension[*], debug: DebugContext[1]): LocalGraphFetchExecutionNode[1]
{
   let fe           = $sq.fe->evaluateAndDeactivate();
   let lhsFe        = $fe.parametersValues->evaluateAndDeactivate()->at(0)->byPassRouterInfo()->cast(@FunctionExpression);
   let rootTree     = $clusteredTree->byPassClusteringInfo()->cast(@RoutedRootGraphFetchTree<Any>);
   let setImpls     = $rootTree.sets->cast(@RootMongoDbInstanceSetImplementation);
   let store        = $sq.store->cast(@MongoDatabase);

   let dbConnection = $runtime->connectionByElement($store)->toOne()->cast(@MongoDatabaseConnection)->map(x | ^$x(element = $store));
   let oneRuntime   = ^Runtime(connections = [$dbConnection]);
   //let batchSize    = if($fe.func == graphFetch_T_MANY__RootGraphFetchTree_1__Integer_1__T_MANY_, | $fe->instanceValueAtParameter(2)->cast(@Integer), | 1000);

   let simplePrimitiveProperties = $rootTree.subTrees->filter(x | !$x->cast(@RoutedPropertyGraphFetchTree).propertyMapping->toOne()->cast(@MongoDbPropertyMapping).field.type->instanceOf(meta::external::store::mongodb::metamodel::ObjectIdType))->cast(@PropertyGraphFetchTree).property->cast(@Property<Nil,Any|*>);

   /* Assert conditions on sets */
   $setImpls->map(x | $x->assertConditionsOnSetImpl($simplePrimitiveProperties));

   /* Generate Document Query */
   //let pureToDocumentQueryState      = createPureToDocumentQueryState($simplePrimitiveProperties, $sq.inScopeVars, $mapping, $exeCtx);
   //println($lhsFe);
   println('planRootGraphFetchExecutionMongoDb');
   let databaseCommand    = $lhsFe->toDatabaseCommand($mapping, $sq.inScopeVars, $debug, $extensions)->cast(@DatabaseCommand);
   println(meta::json::toPrettyJSON($databaseCommand, 15));

   //let documentNode       = $selectDocumentQuery->meta::external::store::mongodb::graphFetch::executionPlan::buildDocumentQueryExecutionNode($dbConnection, $extensions);

   // TODO
   //let postProcessorResult = $selectDocumentQuery->toOne()->cast(@SelectSQLQuery)->postProcessSQLQuery($store, $ext, $mapping, $oneRuntime, $exeCtx, $extensions);
   //let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);

   /* Create execution node */
   // noSqlNode       = $postProcessedQuery->buildSQLExecutionNode($dbConnection, $extensions);
   //let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   //let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);


   let documentRootQueryTempTableGraphFetchExecutionNode = ^DocumentRootQueryTempTableGraphFetchExecutionNode
   (
      resultType     = $rootTree->resultTypeFromGraphFetchTree(),
      nodeIndex      = 0,
      graphFetchTree = $rootTree,
      databaseCommand = $databaseCommand,
     // batchSize      = $batchSize,
      //tempCollectionName  = 'root',
      //columns        = $sqlNode.resultColumns->filter(x | $x.label->startsWith('"pk_'))->map(x | ^SQLResultColumn(label = $x.label->substring(1, $x.label->length() - 1), dataType = $x.dataType->toOne())),
      //children       = $rootTree->generateRelationalChildGraphNodes($rootTree->nodePathName(), $setImpls, $simplePrimitiveProperties, $orderedPaths, $store, $mapping, $oneRuntime, $sq.inScopeVars, $exeCtx, $extensions, $debug),
      //executionNodes = $documentNode,
      enableConstraints = $enableConstraints,
      checked = $checked
   );

   $documentRootQueryTempTableGraphFetchExecutionNode;
}

function <<access.private>> meta::external::store::mongodb::graphFetch::executionPlan::assertConditionsOnSetImpl(setImpl: MongoDbInstanceSetImplementation[1], simplePrimitiveProperties: Property<Nil,Any|*>[*]):Boolean[1]
{
   let r = $setImpl->match([
      //e: EmbeddedDocumentInstanceSetImplementation[1] | $e.setMappingOwner,
      r: RootMongoDbInstanceSetImplementation[1] | $r
   ]);

   // assert($r.resolvePrimaryKey()->isNotEmpty(), | 'Primary Key definition is must in graph fetch flow');
   // assert($r->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty(), | 'Store group by not allowed in graph fetch flow');
   // assert($r->meta::relational::functions::pureToSqlQuery::getDistinct() != true,  | 'Store distinct not allowed in graph fetch flow');

   $simplePrimitiveProperties->forAll({prop |
      assert($setImpl.propertyMappingsByPropertyName($prop.name->toOne())->isNotEmpty(),    //$prop->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype() ||
             | 'Property "' + $prop.name->toOne() + '" is not mapped in the set: "' + $setImpl.id + '"')
   });
}

/*
function <<access.private>> meta::external::store::mongodb::graphFetch::executionPlan::buildDocumentQueryExecutionNode(query: SelectDocumentQuery[1], dbConnection: DatabaseConnection[1], extensions:Extension[*]):DocumentQueryExecutionNode[1]
{

   ^DocumentQueryExecutionNode
    (
       // documentQuery         = $sql,
       //resultFields    = $query.fields->cast(@Alias)->map(c | ^DocumentQueryResultField(label = $c.name, dataType = $c->inferDocumentStoreType()->toOne())), // not passing in meta::relational::translation::TranslationContext
       //resultFields    = $query.fields->cast(@Alias)->map(c | ^DocumentQueryResultField(label = $c.name)), // not passing in meta::relational::translation::TranslationContext

       resultType       = ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::ResultType(type = Any)
       //connection       = $dbConnection->meta::external::store::document::mapping::functions::updateConnection($extensions)->cast(@DatabaseConnection),
       //supportFunctions = documentStorePlanSupportFunctions($dbConnection)
    );
}

function <<access.private>> meta::external::store::mongodb::graphFetch::executionPlan::createPureToDocumentQueryState(simplePrimitiveProperties: Property<Nil,Any|*>[*], inScopeVars: Map<String, List<Any>>[1], mapping: Mapping[1], exeCtx: ExecutionContext[1]):State[1]
{
   let defaultPureToDocumentQueryState = defaultState($mapping, $inScopeVars);
   let sqlStateAsPerContext  = if($exeCtx->isNotEmpty() && $exeCtx->toOne()->instanceOf(MongoDbExecutionContext),
                                  | let docContext = $exeCtx->toOne()->cast(@MongoDbExecutionContext);
                                    ^$defaultPureToDocumentQueryState();
                                     //(
                                        //preserveJoinOrder              = $docContext.preserveJoinOrder,
                                        //addDriverTablePkForProject     = $docContext.addDriverTablePkForProject,
                                        //insertDriverTablePkInTempTable = $docContext.insertDriverTablePkInTempTable,
                                        //useTempTableAsDriver           = $docContext.useTempTableAsDriver
                                     //);
                                     ,
                                  | $defaultPureToDocumentQueryState
                               );
   ^$sqlStateAsPerContext
    (
       graphFetchFlow       = true,
       graphFetchProperties = $simplePrimitiveProperties
    );
}

function <<access.private>> meta::external::store::mongodb::graphFetch::executionPlan::tempTableName(index: Integer[1]):String[1]
{
   'temp_table_node_' + toString($index)
}
*/