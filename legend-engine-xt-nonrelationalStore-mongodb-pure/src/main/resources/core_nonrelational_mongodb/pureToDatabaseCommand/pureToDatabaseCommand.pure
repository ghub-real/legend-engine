import meta::pure::router::printer::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::path::*;
import meta::external::store::mongodb::metamodel::mapping::functions::*;
import meta::external::store::mongodb::metamodel::mapping::*;
import meta::pure::router::metamodel::*;
import meta::external::store::mongodb::metamodel::runtime::*;
import meta::external::store::mongodb::metamodel::*;
import meta::pure::router::store::metamodel::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;
import meta::pure::mapping::*;
import meta::external::store::mongodb::extension::databaseCommandToString::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::metamodel::*;
import meta::external::store::mongodb::metamodel::aggregation::*;
import meta::pure::functions::meta::*;

Class meta::external::store::mongodb::functions::pureToDatabaseCommand::MongoDbExecutionContext extends ExecutionContext
{
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::toDatabaseCommand(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], executionCtx:MongoDbExecutionContext[1], extensions:Extension[*]):String[1]
{
  //toDatabaseCommand($functionExpression, $mapping, $inScopeVars, $debug, $executionCtx->mongodbExecutionContextToState(defaultState($mapping, $inScopeVars)), $extensions)
  'asadasd'
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::toDatabaseCommand(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], extensions:Extension[*]): DatabaseCommand[1]
{
  let result = if ($functionExpression.functionName == 'filter',
    | let dbCommand = ^DatabaseCommand(
        aggregationPipeline=^AggregationPipeline(
          stages=[
            processSimpleFunctionExpressionToMatchStage(
              $functionExpression->cast(@SimpleFunctionExpression),
              $mapping,
              $inScopeVars,
              $debug
            )
          ]
        )
      ),
    | ^DatabaseCommand());
    println('toDatabaseCommand');
    println($result, 10);
  $result;
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processSimpleFunctionExpressionToMatchStage(functionExpression: FunctionExpression[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MatchStage[1]
{
  let instanceValue = processInstanceValue($functionExpression.parametersValues->at(1)->cast(@FunctionRoutedValueSpecification).value->cast(@InstanceValue), $mapping, $inScopeVars, $debug);
  let matchStage = processSimpleFunctionExpression($functionExpression, $mapping, $inScopeVars, $debug);
  ^MatchStage(expression=$matchStage);
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processSimpleFunctionExpression(functionExpression: FunctionExpression[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): ArgumentExpression[1]
{
  let result = if ($functionExpression.functionName == 'getAll',
    | processInstanceValue($functionExpression.parametersValues->at(0)->cast(@InstanceValue), $mapping,  $inScopeVars, $debug),
    | if ($functionExpression.functionName == 'filter',
      | 
        let instanceValue = processInstanceValue($functionExpression.parametersValues->at(1)->cast(@FunctionRoutedValueSpecification).value->cast(@InstanceValue), $mapping, $inScopeVars, $debug);
        /*
        println('instance value in filter');
        println($instanceValue);
        println('first param');
        println($functionExpression.parametersValues->at(0));
        */
        let expressionFake = ^LiteralValue(value=^StringTypeValue(value='afdf'));
        ^ObjectExpression(keyValues=[^KeyValueExpressionPair(field='asd',argument=^LiteralValue(value=^StringTypeValue(value='afdf')))]);,
      | if ($functionExpression.functionName == 'and',
        | 
          let leftSide = processSimpleFunctionExpression($functionExpression.parametersValues->at(0)->cast(@SimpleFunctionExpression), $mapping, $inScopeVars, $debug);
          let rightSide = processSimpleFunctionExpression($functionExpression.parametersValues->at(1)->cast(@SimpleFunctionExpression), $mapping, $inScopeVars, $debug);
          let expressionFake1 = ^LiteralValue(value=^StringTypeValue(value='afdf'));
          let expressionFake2 = ^LiteralValue(value=^StringTypeValue(value='afdf'));
          ^AndOperatorExpression(expressions=[$expressionFake1, $expressionFake2]);,
        | if ($functionExpression.functionName == 'equal',
          | 
            let equalOperatorExpression = processEqual($functionExpression, $mapping, $inScopeVars, $debug);
            println('equalOperatorExpression is:');
            println($equalOperatorExpression);
            ^ObjectExpression(keyValues=[$equalOperatorExpression]);,
          | ^ObjectExpression(keyValues=[^KeyValueExpressionPair(field='asd',argument=^LiteralValue(value=^StringTypeValue(value='afdf')))]);
          )
        )
      )
    );
    $result->cast(@ArgumentExpression);
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processEqual(functionExpression: FunctionExpression[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): KeyValueExpressionPair[1]
{
  //println($functionExpression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).value->cast(@SimpleFunctionExpression).func.name);
  let leftSide = getFieldPathForPropertyNameAndMapping($functionExpression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).value->cast(@SimpleFunctionExpression).func.name->toOne(), $mapping);
  let rightSide = processInstanceValue($functionExpression.parametersValues->at(1)->cast(@InstanceValue), $mapping, $inScopeVars, $debug)->cast(@LiteralValue);
  ^KeyValueExpressionPair(field=$leftSide, argument=^EqOperatorExpression(expression=$rightSide));
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::getFieldPathForPropertyNameAndMapping(propertyName: String[1], mapping: Mapping[1]): String[1]
{
  println('getFieldPathForPropertyNameAndMapping');
  //println(meta::json::toPrettyJSON($mapping.classMappings->cast(@RootMongoDbInstanceSetImplementation).propertyMappings), 8);
  //println($mapping, 5);
  let mongoDbPropertyMapping = $mapping.classMappings->cast(@RootMongoDbInstanceSetImplementation).propertyMappings->filter(x | $x.property.name == $propertyName)->toOne();
  //println('mongoDbPropertyMapping');
  //println($mongoDbPropertyMapping);
  $mongoDbPropertyMapping->cast(@MongoDbPropertyMapping).mongoDbElement->cast(@Field).name;
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processInstanceValue(i: InstanceValue[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): ArgumentExpression[1]
{
  let result = $i.values->match([
    s: String[1] | ^LiteralValue(value=^StringTypeValue(value=$s));,
    l: LambdaFunction<Any>[1] |
      let fe = $i.values->cast(@LambdaFunction<Any>).expressionSequence->cast(@SimpleFunctionExpression);
      processSimpleFunctionExpression($fe->toOne(), $mapping, $inScopeVars, $debug);

  ]);
  $result->toOne();
}
/*
if($argument.functionName == 'graphFetch',
  | 
    println('in graphFetch');
    println($argument.parametersValues->at(0));
    let match = if($argument.parametersValues->at(0).functionName == 'filter'*, | processSimpleFunctionExpression($argument.parametersValues->at(0)),| '');
    let matchFake = ^MatchStage(expression=^LiteralValue(value=^StringTypeValue(value='afdf')));
    let collectionName = 'persons';
    ^DatabaseCommand(aggregationPipeline=^AggregationPipeline(stages=$matchFake));,
  | 
  */
/*
  function meta::external::store::mongodb::functions::pureToDatabaseCommand::processValueSpecification(vs:ValueSpecification[1], parentQuery:DatabaseCommand[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): DatabaseCommand[1]
{
   $vs->evaluateAndDeactivate()->match(
             [
                 r:ExtendedRoutedValueSpecification[1] | $r.value->processValueSpecification($parentQuery, $inScopeVars, $debug),
                 r:FunctionRoutedValueSpecification[1] | $r.value->processValueSpecification($parentQuery, $inScopeVars, $debug),
                 f:FunctionExpression[1]               | $f->processFunctionExpression($parentQuery, $inScopeVars, $debug),
                 i:InstanceValue[1]                    | $i->processInstanceValue($parentQuery, $inScopeVars, $debug),
                 v:VariableExpression[1]               | $v->processVariableExpression($parentQuery, $inScopeVars, $debug)
             ])
}
*/