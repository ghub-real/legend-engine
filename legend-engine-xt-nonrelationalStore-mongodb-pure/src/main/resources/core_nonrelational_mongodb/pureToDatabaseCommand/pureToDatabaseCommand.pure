import meta::json::*;
import meta::pure::router::printer::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::metamodel::path::*;
import meta::external::store::mongodb::metamodel::mapping::functions::*;
import meta::external::store::mongodb::metamodel::mapping::*;
import meta::pure::router::metamodel::*;
import meta::external::store::mongodb::metamodel::runtime::*;
import meta::external::store::mongodb::metamodel::*;
import meta::pure::router::store::metamodel::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;
import meta::pure::mapping::*;
import meta::external::store::mongodb::extension::databaseCommandToString::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::metamodel::*;
import meta::external::store::mongodb::metamodel::aggregation::*;
import meta::pure::functions::meta::*;

Class meta::external::store::mongodb::functions::pureToDatabaseCommand::MongoDbExecutionContext extends ExecutionContext
{
}

Class meta::external::store::mongodb::functions::pureToDatabaseCommand::PureFunctionToMongoDbFunctionPair extends Pair<meta::pure::metamodel::function::Function<Any>, meta::pure::metamodel::function::Function<{FunctionExpression[1], DatabaseCommand[1], Mapping[1], Map<String, List<Any>>[1], DebugContext[1]->MongoDbOperationElement[1]}>>
{
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::toDatabaseCommand(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], extensions:Extension[*]): MongoDbOperationElement[1]
{
   processValueSpecification($functionExpression, ^DatabaseCommand(), $mapping, $inScopeVars, $debug);
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processFunctionExpression(f:FunctionExpression[1], databaseCommand:DatabaseCommand[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]):MongoDbOperationElement[1]
{
   let res  = $f.func->match ([
      //p:Property<Nil,Any|*>[1] | ^$databaseCommand(processingParam = $f->findAndReplacePropertyPathsInValueSpecification([]).second.values->toOne()),
      //q:QualifiedProperty<Any>[1] | ^$databaseCommand(processingParam = $f->findAndReplacePropertyPathsInValueSpecification([]).second.values->toOne()),
      a:Any[1]| processFunction($f, $databaseCommand, $mapping, $inScopeVars, $debug)
   ]);

   $res;
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processFunction(f:FunctionExpression[1], databaseCommand:DatabaseCommand[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MongoDbOperationElement[1]
{
   let func = findSupportedFunction($f, getSupportedFunctions());
   if(!$func->isEmpty(),
      | $func->toOne()->eval($f, $databaseCommand, $mapping, $inScopeVars, $debug);,
      | fail($f.func.name->toOne() + ' is not Supported with mongo store !!'); $databaseCommand;
   );
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processEqual(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): ObjectExpression[1]
{
  let leftSide = getFieldPathForPropertyNameAndMapping($functionExpression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).value->cast(@SimpleFunctionExpression).func.name->toOne(), $mapping);
  let rightSide = processInstanceValue($functionExpression.parametersValues->at(1)->cast(@InstanceValue), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@LiteralValue);
  ^ObjectExpression(keyValues=^KeyValueExpressionPair(field=$leftSide, argument=^EqOperatorExpression(expression=$rightSide)));
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processNot(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): ObjectExpression[1]
{
  let objectExpression = processValueSpecification($functionExpression.parametersValues->at(0), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@ObjectExpression);
  let keyValuePair = $objectExpression.keyValues->at(0);
  let field = $keyValuePair.field;
  let expression = $keyValuePair.argument->cast(@EqOperatorExpression).expression;
  ^ObjectExpression(keyValues=^KeyValueExpressionPair(field=$field, argument=^NEOperatorExpression(expression=$expression)));
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::getFieldPathForPropertyNameAndMapping(propertyName: String[1], mapping: Mapping[1]): String[1]
{
  let mongoDbPropertyMapping = $mapping.classMappings->cast(@RootMongoDbInstanceSetImplementation).propertyMappings->filter(x | $x.property.name == $propertyName)->toOne();
  $mongoDbPropertyMapping->cast(@MongoDbPropertyMapping).mongoDbElement->cast(@Field).name;
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processInstanceValue(i: InstanceValue[1], databaseCommand: DatabaseCommand[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MongoDbOperationElement[1]
{
  $i.values->match([
    s: String[1] | ^LiteralValue(value=^StringTypeValue(value=$s));,
    l: LambdaFunction<Any>[1] |
      let fe = $i.values->cast(@LambdaFunction<Any>).expressionSequence->cast(@SimpleFunctionExpression);
      processFunctionExpression($fe->toOne(), $databaseCommand, $mapping, $inScopeVars, $debug);
  ]);
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processValueSpecification(vs:ValueSpecification[1], databaseCommand:DatabaseCommand[1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MongoDbOperationElement[1]
{
   $vs->evaluateAndDeactivate()->match(
             [
                 s:StoreMappingRoutedValueSpecification[1] | $s.value->processValueSpecification($databaseCommand, $mapping, $inScopeVars, $debug),
                 r:ExtendedRoutedValueSpecification[1]     | $r.value->processValueSpecification($databaseCommand, $mapping, $inScopeVars, $debug),
                 r:FunctionRoutedValueSpecification[1]     | $r.value->processValueSpecification($databaseCommand, $mapping, $inScopeVars, $debug),
                 f:FunctionExpression[1]                   | $f->processFunctionExpression($databaseCommand, $mapping, $inScopeVars, $debug),
                 i:InstanceValue[1]                        | $i->processInstanceValue($databaseCommand, $mapping, $inScopeVars, $debug)
                 //v:VariableExpression[1]                   | $v->processVariableExpression($databaseCommand, $mapping, $inScopeVars, $debug)
             ]);
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processFilter(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand [1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): DatabaseCommand[1]
{
  let leftSide = processValueSpecification($functionExpression.parametersValues->at(0), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@DatabaseCommand);
  let rightSide = processValueSpecification($functionExpression.parametersValues->at(1), $databaseCommand, $mapping, $inScopeVars, $debug)->match([
    l: LogicalOperatorExpression[1] | $l->cast(@LogicalOperatorExpression),
    o: ObjectExpression [1]         | $o->cast(@ObjectExpression)
  ]);

  let matchStage = if ($leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(MatchStage))->size() == 1, 
    | let existingMatchStageKeyValuePairExpressions = $leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(MatchStage))->toOne()->cast(@MatchStage).expression->cast(@ObjectExpression).keyValues;
      let currentKeyValuePairExpressions = $rightSide->cast(@ObjectExpression).keyValues;
      ^MatchStage(expression=^ObjectExpression(keyValues=$existingMatchStageKeyValuePairExpressions->concatenate($currentKeyValuePairExpressions)));,
    | ^MatchStage(expression=$rightSide)
  )->toOne();

  let projectStage = if ($leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(ProjectStage))->size() == 1,
    | $leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(ProjectStage))->toOne()->cast(@ProjectStage),
    | []);
  
  ^$leftSide(
    aggregationPipeline = ^AggregationPipeline(stages=[$matchStage]->concatenate($projectStage))
  );
}

/*
function meta::external::store::mongodb::functions::pureToDatabaseCommand::processFilter(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand [1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MongoDbOperationElement[1]
{
  let leftSideDatabaseCommand = processValueSpecification($functionExpression.parametersValues->at(0), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@DatabaseCommand);
  let rightSide = processValueSpecification($functionExpression.parametersValues->at(1), $databaseCommand, $mapping, $inScopeVars, $debug)->match([
    l: LogicalOperatorExpression[1] | $l->cast(@LogicalOperatorExpression),
    o: ObjectExpression [1]         | $o->cast(@ObjectExpression)
  ]);

  let existingStages = $leftSideDatabaseCommand.aggregationPipeline.stages->concatenate(^MatchStage(expression=$rightSide));
  ^$leftSideDatabaseCommand(
    aggregationPipeline = ^AggregationPipeline(stages=$existingStages)
  )->cast(@DatabaseCommand);
}
*/

/*
function meta::external::store::mongodb::functions::pureToDatabaseCommand::processFilter(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand [1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): MongoDbOperationElement[1]
{
  let leftSide = processValueSpecification($functionExpression.parametersValues->at(0), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@DatabaseCommand);
  let rightSide = processValueSpecification($functionExpression.parametersValues->at(1), $databaseCommand, $mapping, $inScopeVars, $debug)->match([
    l: LogicalOperatorExpression[1] | $l->cast(@LogicalOperatorExpression),
    o: ObjectExpression [1]         | $o->cast(@ObjectExpression)
  ]);

  let matchStage = if ($leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(MatchStage))->size() == 1, 
    | let existingMatchStageKeyValuePairExpressions = $leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(MatchStage))->toOne()->cast(@MatchStage).expression->cast(@ObjectExpression).keyValues;
      let currentKeyValuePairExpressions = $rightSide->cast(@ObjectExpression).keyValues;
      ^MatchStage(expression=^ObjectExpression(keyValues=$existingMatchStageKeyValuePairExpressions->concatenate($currentKeyValuePairExpressions)));,
    | ^MatchStage(expression=$rightSide)
  )->toOne();

  let projectStage = if ($leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(ProjectStage))->size() == 1,
    | $leftSide.aggregationPipeline.stages->filter(x | $x->instanceOf(ProjectStage))->toOne()->cast(@ProjectStage),
    | []);
  
  ^$leftSide(
    aggregationPipeline = ^AggregationPipeline(stages=[$matchStage]->concatenate($projectStage))
  );
}
*/

function meta::external::store::mongodb::functions::pureToDatabaseCommand::processAnd(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand [1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): AndOperatorExpression[1]
{
  let leftSide = processValueSpecification($functionExpression.parametersValues->at(0), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@ObjectExpression);
  let rightSide = processValueSpecification($functionExpression.parametersValues->at(1), $databaseCommand, $mapping, $inScopeVars, $debug)->cast(@ObjectExpression);
  ^AndOperatorExpression(expressions=[$leftSide, $rightSide]);
}


function meta::external::store::mongodb::functions::pureToDatabaseCommand::processGetAll(functionExpression: FunctionExpression[1], databaseCommand: DatabaseCommand [1], mapping: Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1]): DatabaseCommand[1]
{
  let setImplementation = $functionExpression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne();
  let collectionName = $setImplementation->cast(@RootMongoDbInstanceSetImplementation).mainCollectionAlias.mongoDbElement->cast(@Collection).name;
  let projectedKeys = getProjectKeyValuesForMongoDbPropertyMappings($setImplementation->cast(@RootMongoDbInstanceSetImplementation).propertyMappings->cast(@MongoDbPropertyMapping));
  let result = ^$databaseCommand(collectionName=$collectionName, aggregationPipeline=^AggregationPipeline(stages=^ProjectStage(filters=^ObjectExpression(keyValues=[$projectedKeys]))));
  $result;
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::getProjectKeyValuesForMongoDbPropertyMappings(propertyMappings: MongoDbPropertyMapping[*]): KeyValueExpressionPair[*]
{
  $propertyMappings->map(k | 
    let ff = $k.property.name->toOne();
    println('the ff');
    println($ff);
    let field = meta::json::toJSONElement($k.property)->cast(@JSONObject).keyValuePairs.value->at(0)->cast(@meta::json::JSONString).value;
    ^KeyValueExpressionPair(argument=^ComputedFieldValue(value=$k.mongoDbElement->cast(@Field).name), field=$field);
  );
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::findSupportedFunction(fe:FunctionExpression[1], supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], DatabaseCommand[1], Mapping[1], Map<String, List<Any>>[1], DebugContext[1]->MongoDbOperationElement[1]}>>[1]):meta::pure::metamodel::function::Function<{FunctionExpression[1], DatabaseCommand[1], Mapping[1], Map<String, List<Any>>[1], DebugContext[1]->MongoDbOperationElement[1]}>[0..1]
{
   $supportedFunctions->get($fe.func)
}

function meta::external::store::mongodb::functions::pureToDatabaseCommand::getSupportedFunctions():Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], DatabaseCommand[1], Mapping[1], Map<String, List<Any>>[1], DebugContext[1]->MongoDbOperationElement[1]}>>[1]
{
   newMap([
      ^PureFunctionToMongoDbFunctionPair(first=meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_, second=meta::external::store::mongodb::functions::pureToDatabaseCommand::processEqual_FunctionExpression_1__DatabaseCommand_1__Mapping_1__Map_1__DebugContext_1__ObjectExpression_1_),
      ^PureFunctionToMongoDbFunctionPair(first=meta::pure::functions::boolean::not_Boolean_1__Boolean_1_, second=meta::external::store::mongodb::functions::pureToDatabaseCommand::processNot_FunctionExpression_1__DatabaseCommand_1__Mapping_1__Map_1__DebugContext_1__ObjectExpression_1_),
      ^PureFunctionToMongoDbFunctionPair(first=meta::pure::functions::collection::filter_T_MANY__Function_1__T_MANY_, second=meta::external::store::mongodb::functions::pureToDatabaseCommand::processFilter_FunctionExpression_1__DatabaseCommand_1__Mapping_1__Map_1__DebugContext_1__DatabaseCommand_1_),
      ^PureFunctionToMongoDbFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__T_MANY_, second=meta::external::store::mongodb::functions::pureToDatabaseCommand::processGetAll_FunctionExpression_1__DatabaseCommand_1__Mapping_1__Map_1__DebugContext_1__DatabaseCommand_1_),
      ^PureFunctionToMongoDbFunctionPair(first=meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_, second=meta::external::store::mongodb::functions::pureToDatabaseCommand::processAnd_FunctionExpression_1__DatabaseCommand_1__Mapping_1__Map_1__DebugContext_1__AndOperatorExpression_1_)
   ])
}