import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::external::store::mongodb::runtime::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::external::store::mongodb::metamodel::mapping::*;
import meta::external::store::mongodb::metamodel::*;
import meta::pure::router::clustering::*;
import meta::pure::mapping::modelToModel::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;
import meta::pure::store::*;
import meta::pure::mapping::*;
import meta::pure::executionPlan::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::external::store::mongodb::graphFetch::executionPlan::*;

function meta::external::store::mongodb::contract::mongoDbStoreContract(): StoreContract[1]
{
  ^StoreContract
  (
    id = 'mongoDbStore',
    planExecution =  meta::external::store::mongodb::contract::planExecution_StoreQuery_1__RoutedValueSpecification_$0_1$__Mapping_$0_1$__Runtime_$0_1$__ExecutionContext_1__Extension_MANY__DebugContext_1__ExecutionNode_1_,
    planGraphFetchExecution = meta::external::store::mongodb::contract::planGraphFetchExecution_StoreMappingLocalGraphFetchExecutionNodeGenerationInput_1__LocalGraphFetchExecutionNode_1_,
    supportsStore = s:Store[1]|$s->instanceOf(meta::external::store::mongodb::metamodel::MongoDatabase),
    supportsNativeJoinAmongElements = false,
    supportsSetImplementation = s:SetImplementation[1]| $s->instanceOf(MongoDbInstanceSetImplementation) ||
                                                        $s->instanceOf(CrossSetImplementation) && $s->cast(@CrossSetImplementation).targetStore->instanceOf(MongoDatabase),
    resolveStoreFromSetImplementation = s:InstanceSetImplementation[1]|$s->meta::external::store::mongodb::contract::getStore(),
    supports = meta::external::store::mongodb::contract::supports_FunctionExpression_1__Boolean_1_
  )
}

function meta::external::store::mongodb::contract::planExecution(sq:meta::pure::mapping::StoreQuery[1], ext:RoutedValueSpecification[0..1], m:Mapping[0..1], runtime:Runtime[0..1], exeCtx:ExecutionContext[1], extensions:Extension[*], debug:DebugContext[1]): ExecutionNode[1]
{
   let store = $sq.store->cast(@MongoDatabase);
   let fe = $sq.fe->evaluateAndDeactivate();
   if($fe.func->in([meta::pure::graphFetch::execution::graphFetchFunctions()]),
      |
        // Graph Fetch Flow
        $sq->meta::pure::graphFetch::executionPlan::planGraphFetchExecution($ext, $m->toOne(), $runtime->toOne(), $exeCtx, $extensions, $debug);,

      |
        // Normal Flow
       let connections = $runtime.connections->filter(c | $c->instanceOf(DatabaseConnection));
       let storeRuntime = if($connections->size() <= 1,
                             | $runtime->toOne(),
                             | let oldRuntime = $runtime->toOne();
                               let dbConn = $oldRuntime->connectionByElement($store)->cast(@DatabaseConnection);
                               ^$oldRuntime(connections = $dbConn);
                          );

      //let queryExeCtx = if($exeCtx->instanceOf(MongoDbExecutionContext),|$exeCtx,|[])->cast(@MongoDbExecutionContext);
      let queryExeCtx = $exeCtx->cast(@MongoDbExecutionContext);
      let originalQuery = $sq.fe->toDatabaseCommand($m->toOne(), $sq.inScopeVars, $debug, $extensions);
      $originalQuery;
      ^ExecutionNode(resultType=^ResultType(type = Boolean));
      /*
      $originalQuery->postProcessSQLQuery($store, $ext, $m->toOne(), $storeRuntime, $exeCtx, $extensions)
                    ->generateExecutionNodeForPostProcessedResult($sq, $store, $ext, $m->toOne(), $storeRuntime, $exeCtx, $debug, $extensions);
                    */
   );
}

function meta::external::store::mongodb::contract::supportsStream(f:FunctionExpression[1]):Boolean[1]
{
  true;
}

function meta::external::store::mongodb::contract::getStore(r:InstanceSetImplementation[1]):Store[1]
{
  $r->match(
    [
      r:RootMongoDbInstanceSetImplementation[1]|
          //let mainCollectionAlias = $r.mainCollectionAlias;
          $r.mainCollectionAlias.mongoDatabase->toOne(),
      s:CrossSetImplementation[1]|$s.targetStore
    ]
  )  
}

function meta::external::store::mongodb::contract::supports(f:FunctionExpression[1]):Boolean[1]
{
  true;
}

function meta::external::store::mongodb::contract::planGraphFetchExecution(input: StoreMappingLocalGraphFetchExecutionNodeGenerationInput[1]): LocalGraphFetchExecutionNode[1]
{
  meta::external::store::mongodb::graphFetch::executionPlan::planRootGraphFetchExecutionMongoDb($input.storeQuery, $input.ext, $input.clusteredTree, $input.orderedPaths, $input.mapping, $input.runtime, $input.exeCtx, $input.enableConstraints, $input.checked, $input.extensions, $input.debug)
}
