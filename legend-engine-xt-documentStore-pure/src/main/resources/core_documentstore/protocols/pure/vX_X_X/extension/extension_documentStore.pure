// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;

import meta::external::store::document::metamodel::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::external::store::document::metamodel::runtime::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::document::*;
import meta::external::store::document::graphFetch::executionPlan::*;
import meta::protocols::pure::vX_X_X::metamodel::executionPlan::*;

function meta::protocols::pure::vX_X_X::extension::store::document::getDocumentStoreExtension(type:String[1]):meta::pure::extension::SerializerExtension[1]
{
   let res = [
      pair('documentStore', | meta::protocols::pure::vX_X_X::extension::store::document::getDocumentStoreExtension())
   ]->filter(f|$f.first == $type);
   assert($res->isNotEmpty(), |'Can\'t find the type '+$type);
   $res->at(0).second->eval();
}

function meta::protocols::pure::vX_X_X::extension::store::document::getDocumentStoreExtension():meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X[1]
{
   ^meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X
   (
    scan_buildBasePureModel_extractStores = {m:Mapping[1], extensions:meta::pure::extension::Extension[*] |
                                                     [
                                                        rsi: RootDocumentInstanceSetImplementation[1] |
                                                                          // Main Store
                                                                          let mainCollectionAlias = $rsi.mainCollectionAlias;
                                                                          let mainStore = $mainCollectionAlias.documentStore;    // No schema stuff if ($mainCollectionAlias.documentStore->isEmpty(), | $rsi.mainTable.schema.database, | $mainTableAlias.database->toOne());
                                                                          // Filter
                                                                          // let filter = $rsi.resolveFilter();
                                                                          // let fromFilter = $filter.database;
                                                                          // let fromFilterOpertation = $filter.filter.operation->meta::relational::functions::pureToSqlQuery::extractStore();
                                                                          // let fromFilterJoins = $filter.joinTreeNode->map(x|$x->meta::relational::functions::pureToSqlQuery::flatten()).database;
                                                                          // Properties
                                                                          // let fromProperties = $rsi->processProperties($m, $extensions);
                                                                          // All
                                                                          $mainStore; //->concatenate($fromFilter)->concatenate($fromFilterOpertation)->concatenate($fromFilterJoins)->concatenate($fromProperties);,
                                                        // x: EmbeddedRelationalInstanceSetImplementation[1]|$x->processProperties($m, $extensions),
                                                        // ag:	meta::pure::mapping::aggregationAware::AggregationAwareSetImplementation[1]| $ag.mainSetImplementation->extractStores($m, $extensions)->concatenate($ag.aggregateSetImplementations->map(a|$a.setImplementation->extractStores($m, $extensions)))
                                                     ]
                                                   },
    transfers_store_transformConnection2 = {extensions:meta::pure::extension::Extension[*] |
    [
        db:meta::external::store::document::metamodel::runtime::DatabaseConnection[1] | $db->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::store::document::transformDatabaseConnection($extensions)
    ]},
   transfers_store_transformStore2 = {extensions:meta::pure::extension::Extension[*] |
   [
        d:meta::external::store::document::metamodel::DocumentStore[1] | $d->transformDataStore($extensions)
   ]},


//      transfers_store_transformConnection =
//          [
//             serviceStoreConnection:ServiceStoreConnection[1] | $serviceStoreConnection->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::store::service::transformServiceStoreConnection()
//          ],
      transfers_executionPlan_transformNode = {mapping:Mapping[1], extensions:meta::pure::extension::Extension[*] |
          [
            /*
                     rb:meta::pure::executionPlan::RelationalBlockExecutionNode[1]|
                               ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalBlockExecutionNode( _type = 'relationalBlock',
                                                                                                                       resultType = $rb.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions)),
            */
                     rel:meta::external::store::document::metamodel::mapping::DocumentQueryExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::DocumentQueryExecutionNode(
                          // TODO: should be noSQL, needs to be whitelisted somewhere, related error: Could not resolve type id 'noSQL' as a subtype of `org.finos.legend.engine.protocol.pure.v1.model.executionPlan.nodes.ExecutionNode`: known type ids = [aggregationAware, allocation, constant, createAndPopulateTempTable, dataQuality, documentQuery, error, externalFormatExternalize, externalFormatInternalize, flatDataDeserialize, flatDataSerialize, freeMarkerConditionalExecutionNode, function-parameters-validation, globalGraphFetchExecutionNode, graphFetchExecutionNode, graphFetchM2M, inMemoryCrossStoreGraphFetch, inMemoryPropertyGraphFetch, inMemoryRootGraphFetch, jsonDeserialize, jsonSerialize, limit, multiResultSequence, platform, platformMerge, platformUnion, pureExp, relational, relationalBlock, relationalClassInstantiation, relationalClassQueryTempTableGraphFetch, relationalCrossRootGraphFetchExecutionNode, relationalCrossRootQueryTempTableGraphFetch, relationalDataTypeInstantiation, relationalGraphFetchExecutionNode, relationalPrimitiveQueryGraphFetch, relationalRelationDataInstantiation, relationalRootGraphFetchExecutionNode, relationalRootQueryTempTableGraphFetch, relationalTdsInstantiation, relationalTempTableGraphFetchExecutionNode, restService, sequence, serviceParametersResolution, sql, storeStreamReading, urlStream, varResolution, xmlDeserialize, xmlSerialize] (for POJO property 'executionNodes')
                           _type = 'sql',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           //resultColumns = $rel.resultColumns->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultColumn()),
                           //sqlQuery = $rel.sqlQuery,
                           onConnectionCloseCommitQuery = $rel.onConnectionCloseCommitQuery,
                           onConnectionCloseRollbackQuery = $rel.onConnectionCloseRollbackQuery
                           //connection = $rel.connection->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformDatabaseConnection($extensions)
                        ),
            /*  
                     rel:meta::relational::mapping::RelationalTdsInstantiationExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalTdsInstantiationExecutionNode(
                           _type = 'relationalTdsInstantiation',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity())
                        ),
                        
                     rel:meta::relational::mapping::RelationalClassInstantiationExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalClassInstantiationExecutionNode(
                           _type = 'relationalClassInstantiation',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity())
                        ),
                     rel:meta::relational::mapping::RelationalRelationDataInstantiationExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalRelationDataInstantiationExecutionNode(
                           _type = 'relationalRelationDataInstantiation',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity())
                        ),
                     rel:meta::relational::mapping::RelationalDataTypeInstantiationExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalDataTypeInstantiationExecutionNode(
                           _type = 'relationalDataTypeInstantiation',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity())
                        ),
                     cpt:meta::relational::mapping::CreateAndPopulateTempTableExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::CreateAndPopulateTempTableExecutionNode
                        (
                           _type = 'createAndPopulateTempTable',
                           inputVarNames = $cpt.inputVarNames,
                           tempTableName = $cpt.tempTableName,
                           resultType = $cpt.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $cpt.resultSizeRange->isEmpty()->if(|[],|$cpt.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           tempTableColumnMetaData = $cpt.tempTableColumnMetaData->map(col | $col->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformTempTableColumnMetaData()),
                           connection = $cpt.connection->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformDatabaseConnection($extensions)
                        ),
              */
                     rel:meta::external::store::document::graphFetch::executionPlan::DocumentStoreRootQueryTempTableGraphFetchExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::DocumentStoreRootQueryTempTableGraphFetchExecutionNode(
                           //_type = 'documentStoreRootQueryTempTableGraphFetch',
                           // TODO: is this the right type?
                           _type = 'LocalGraphFetchExecutionNode',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           //batchSize = $rel.batchSize,
                           // TODO: the name isn't root, check if I need to use the tempTableName or something else there.
                           //tempCollectionName='root',
                           //tempTableName = $rel.tempTableName,
                           //columns = $rel.columns->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultColumn()),
                           //children = $rel.children->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformNode($mapping, $extensions))->cast(@meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalGraphFetchExecutionNode),
                           nodeIndex = $rel.nodeIndex,
                           parentIndex = $rel.parentIndex,
                           graphFetchTree = $rel.graphFetchTree->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformGraphFetchTree([], newMap([]->cast(@Pair<String,List<Any>>)), $extensions)
                           //checked = $rel.checked
                        )
                        /*
                     rel:meta::relational::graphFetch::executionPlan::RelationalCrossRootQueryTempTableGraphFetchExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalCrossRootQueryTempTableGraphFetchExecutionNode(
                           _type = 'relationalCrossRootQueryTempTableGraphFetch',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           tempTableName = $rel.tempTableName,
                           columns = $rel.columns->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultColumn()),
                           children = $rel.children->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformNode($mapping, $extensions))->cast(@meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalGraphFetchExecutionNode),
                           nodeIndex = $rel.nodeIndex,
                           parentIndex = $rel.parentIndex,
                           parentTempTableName = $rel.parentTempTableName,
                           parentTempTableColumns = $rel.parentTempTableColumns->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultColumn()),
                           graphFetchTree = $rel.graphFetchTree->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformGraphFetchTree([], newMap([]->cast(@Pair<String,List<Any>>)), $extensions)
                        ),
                     rel:meta::relational::graphFetch::executionPlan::RelationalClassQueryTempTableGraphFetchExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalClassQueryTempTableGraphFetchExecutionNode(
                           _type = 'relationalClassQueryTempTableGraphFetch',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           tempTableName = $rel.tempTableName,
                           columns = $rel.columns->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultColumn()),
                           children = $rel.children->map(c | $c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformNode($mapping, $extensions))->cast(@meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalGraphFetchExecutionNode),
                           nodeIndex = $rel.nodeIndex,
                           parentIndex = $rel.parentIndex,
                           graphFetchTree = $rel.graphFetchTree->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformGraphFetchTree([], newMap([]->cast(@Pair<String,List<Any>>)), $extensions)
                        ),
                     rel:meta::relational::graphFetch::executionPlan::RelationalPrimitiveQueryGraphFetchExecutionNode[1]|
                        ^meta::protocols::pure::vX_X_X::metamodel::executionPlan::RelationalPrimitiveQueryGraphFetchExecutionNode(
                           _type = 'relationalPrimitiveQueryGraphFetch',
                           resultType = $rel.resultType->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformResultType($mapping, $extensions),
                           resultSizeRange = $rel.resultSizeRange->isEmpty()->if(|[],|$rel.resultSizeRange->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()),
                           nodeIndex = $rel.nodeIndex,
                           parentIndex = $rel.parentIndex,
                           graphFetchTree = $rel.graphFetchTree->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformGraphFetchTree([], newMap([]->cast(@Pair<String,List<Any>>)), $extensions)
                        )
                        */
          ]
       }
//      transfers_mapping_transformSetImplementation2 = {mapping:Mapping[1], extensions:meta::pure::extension::Extension[*] | [
//            rsi:RootServiceInstanceSetImplementation[1]  | $rsi->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::service::mapping::transformRootServiceInstanceSetImplementation($mapping, $extensions),
//            esi:EmbeddedServiceStoreSetImplementation[1] | []
//          ]}
//      transfers_store_transformStore2 = {extensions:meta::pure::extension::Extension[*] |
//         [
//            s:ServiceStore[1] | $s->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::service::transformServiceStore($extensions)
//         ]},
//      scan_buildBasePureModel_extractStores = {m:Mapping[1], extensions:meta::pure::extension::Extension[*] |
//         [
//            rsi:RootServiceInstanceSetImplementation[1]  | $rsi->meta::protocols::pure::vX_X_X::extension::store::service::extractServiceStore(),
//            esi:EmbeddedServiceStoreSetImplementation[1] | $esi->meta::protocols::pure::vX_X_X::extension::store::service::extractServiceStore()
//         ]}
   )
}


Class meta::protocols::pure::vX_X_X::extension::store::document::DocumentStoreModuleSerializerExtension extends meta::protocols::pure::vX_X_X::extension::ModuleSerializerExtension
{
   // Removed. , meta::protocols::pure::vX_X_X::metamodel::store::relational::PostProcessorWithParameter[*]
   transfers_connection_transformDatabaseConnection : meta::pure::metamodel::function::Function<{String[1], String[1], String[1] -> meta::pure::metamodel::function::Function<{Nil[1]->meta::protocols::pure::vX_X_X::metamodel::store::document::connection::DatabaseConnection[1]}>[*]}>[0..1];
   //transfers_connection_transformPostProcessors : Function<{Nil[1] -> meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::PostProcessor[1]}>[*];
   transfers_connection_transformAuthenticationStrategy : meta::pure::metamodel::function::Function<{Nil[1] -> meta::protocols::pure::vX_X_X::metamodel::store::document::connection::alloy::authentication::AuthenticationStrategy[1]}>[*];
   transfers_connection_transformDatasourceSpecification : meta::pure::metamodel::function::Function<{Nil[1] -> meta::protocols::pure::vX_X_X::metamodel::store::document::connection::alloy::specification::DatasourceSpecification[1]}>[*];
   //transfers_connection_transformPostProcessorParameters : Function<{Nil[1] -> meta::protocols::pure::vX_X_X::metamodel::store::relational::PostProcessorParameter[1]}>[*];
   //transfers_milestoning_transformMilestoning : Function<{Nil[1]->meta::protocols::pure::vX_X_X::metamodel::store::relational::Milestoning[1]}>[*];
   reverse_transfers_typeLookups: Pair<String, String>[*];
   reverse_transfers_connection_transformAuthenticationStrategy : meta::pure::metamodel::function::Function<{Nil[1] -> meta::external::store::document::runtime::authentication::AuthenticationStrategy[1]}>[*];
   reverse_transfers_connection_transformDatasourceSpecification : meta::pure::metamodel::function::Function<{Nil[1] -> meta::external::store::document::runtime::connections::specification::DatasourceSpecification[1]}>[*];
}

