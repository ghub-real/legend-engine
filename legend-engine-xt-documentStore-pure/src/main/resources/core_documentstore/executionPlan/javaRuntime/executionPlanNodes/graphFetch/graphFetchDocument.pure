import meta::external::language::java::factory::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::metamodel::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::serialization::*;
import meta::external::language::java::transform::*;
import meta::pure::executionPlan::*;
import meta::pure::executionPlan::engine::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::executionPlan::engine::java::graphFetch::common::*;
import meta::pure::executionPlan::engine::java::naming::*;
import meta::pure::executionPlan::engine::java::platform::*;
import meta::pure::executionPlan::platformBinding::typeInfo::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::mapping::xStore::*;
import meta::pure::milestoning::*;
import meta::pure::extension::*;
import meta::external::store::document::graphFetch::executionPlan::*;
import meta::pure::executionPlan::engine::java::graphFetch::document::store::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::pure::executionPlan::engine::java::*;
import meta::document::store::mapping::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::pure::executionPlan::document::engine::java::*;
import meta::pure::executionPlan::document::engine::java::addObjectMapperField::*;
import meta::pure::executionPlan::engine::java::graphFetch::document::*;


function meta::pure::executionPlan::engine::java::graphFetch::document::prepareForDocumentGraphFetch(node: DocumentGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], debug: DebugContext[1]):GenerationContext[1]
{
  /*
   $node->match([
      //r : RelationalClassQueryTempTableGraphFetchExecutionNode[1] | $r->prepareForRelationalClassQueryTempTableGraphFetch($path, $context, $debug),
      p : DocumentGraphFetchExecutionNode[1] |
                let pureType = $node->typeFromStoreLocalNode();
                let simpleType = ^SimpleJavaType(pureType = $pureType, javaType = $context.conventions->className($pureType));
                ^$context(nodeInfos = $context.nodeInfos->concatenate(^NodeInfo(path = $path, returnType = $simpleType)));,
      m : ExecutionNode[1]                        | $context
   ])
   */
   $node->match([
      r : DocumentClassQueryTempTableGraphFetchExecutionNode[1] | $r->prepareForDocumentClassQueryTempTableGraphFetch($path, $context, $debug),
      p : DocumentGraphFetchExecutionNode[1]                    | $context
   ])
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::prepareForDocumentClassQueryTempTableGraphFetch(node: DocumentClassQueryTempTableGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], debug: DebugContext[1]):GenerationContext[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') prepareForDocumentClassQueryTempTableGraphFetch\n', |''));

   let pureType = $node->typeFromStoreLocalNode();

   let simpleType = ^SimpleJavaType(pureType = $pureType, javaType = $context.conventions->className($pureType));

   let returnType = $node->match([
      r : DocumentRootQueryTempTableGraphFetchExecutionNode[1] | if($r.checked->isTrue(), | ^CheckedJavaType(checkedOf = $simpleType), | $simpleType),
      p : DocumentClassQueryTempTableGraphFetchExecutionNode[1]| $simpleType
   ]);

   ^$context
   (
      nodeInfos = $context.nodeInfos->concatenate(
         ^NodeInfo(path = $path, returnType = $returnType)
      )
   );
}

function meta::pure::executionPlan::engine::java::graphFetch::document::store::generateDocumentStoreGraphFetchProject(node: DocumentGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], extensions: Extension[*], debug: DebugContext[1]):Project[1]
{
   let specificsClass = initializeSpecificsClass($node, $path, $context, $debug)
                           ->map(s | $s->addSpecificsPrepareMethod($node, $path, $context, $debug))
                           ->map(s | $s->addSpecificsGeneralMethods($node, $path, $context, $debug))
                           ->map(s | $s->addSpecificsCachingMethods($node, $path, $context, $debug));

   let executeClass   = initializeExecuteClass($node, $specificsClass, $path, $context, $debug)
                           ->map(e | $e->addExecuteGeneralMethods($node, $path, $context, $debug))
                           ->map(e | $e->addExecuteCachingMethods($node, $path, $context, $debug));

   newProject()->addClasses([$specificsClass, $executeClass]);
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::initializeExecuteClass(node:DocumentGraphFetchExecutionNode[1], specificsClass: meta::external::language::java::metamodel::Class[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   
   let nodeSpecifics = $conventions->className($node->match([
      pr : DocumentPrimitiveQueryGraphFetchExecutionNode[1]          | INonRelationalPrimitiveQueryGraphFetchExecutionNodeSpecifics,
      rq : DocumentRootQueryTempTableGraphFetchExecutionNode[1]      | INonRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics,
      //cr : DocumentCrossRootQueryTempTableGraphFetchExecutionNode[1] | INonRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics,
      cq : DocumentClassQueryTempTableGraphFetchExecutionNode[1]     | INonRelationalClassQueryTempTableGraphFetchExecutionNodeSpecifics
   ]));
   

   let executeClass = $conventions->planNodeClass('public', $path, 'Execute');
   $executeClass
      ->imports(javaPackage('java.util'))
      ->imports(javaPackage('java.util.function'))
      ->imports(javaPackage('java.util.stream'))
      ->imports(javaReflectMethod())
      ->imports(javaResultSet())
      ->imports(javaClass('org.eclipse.collections.api.tuple.Pair'))
      ->imports($conventions->className(IExecutionNodeContext))
      ->imports($conventions->className(GraphInstance))
      ->imports($conventions->className(IReferencedObject))
      ->imports($nodeSpecifics)->implements($nodeSpecifics)
      ->addField(
         javaField(['private'], $specificsClass, 'specifics')
      )
      ->addConstructor(
         javaConstructor(
            ['public'], [],
            j_this($executeClass)->j_field('specifics', $specificsClass)->j_assign(j_new($specificsClass, []))
         )
      );
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::addExecuteGeneralMethods(executeClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions    = $context.conventions;
   let jThis          = j_this($executeClass);
   let specificsField = $jThis->j_field('specifics');
   let isPrimitive    = $node->instanceOf(DocumentPrimitiveQueryGraphFetchExecutionNode);
   let isClassResult  = $node->instanceOf(DocumentClassQueryTempTableGraphFetchExecutionNode) && !$node->instanceOf(DocumentRootQueryTempTableGraphFetchExecutionNode);
   let isLocalRoot    = $node->instanceOf(DocumentRootQueryTempTableGraphFetchExecutionNode);
   //let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

   let nextType = if (!$isPrimitive,
                      | graphInstanceOf(javaWildcardExtends($conventions->className(IReferencedObject)), $conventions),
                      | graphInstanceOf(javaWildcard(), $conventions)
                  );

  //let nextType = graphInstanceOf(javaWildcard(), $conventions);

// goncah, this generates class Execute implements INonRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics
   $executeClass
      ->addMethod($executeClass->meta::pure::executionPlan::engine::java::graphFetch::document::store::buildPrepareMethod(['public'], $specificsField->j_invoke('prepare', [j_parameter(javaList(javaClass('org.finos.legend.engine.plan.dependencies.store.document.graphFetch.DocumentQueryResultField')), 'documentQueryResultFields'), j_parameter(javaString(), 'databaseTimeZone'), j_parameter(javaString(), 'databaseConnection')], javaVoid())))
      ->addMethod($executeClass->meta::pure::executionPlan::engine::java::graphFetch::document::store::buildNextGraphInstanceMethod(['public'], $nextType, j_return($specificsField->j_invoke('nextGraphInstance', [], $nextType))))
      ->map({exe |
         if ($isClassResult || $isLocalRoot,
             | $exe
                  ->addMethod($exe->buildPrimaryKeyGettersMethod(['public'], j_return($specificsField->j_invoke('primaryKeyGetters', [], javaList(javaReflectMethod())))))
                  ->addMethod($exe->buildAllInstanceSetImplementationsMethod(['public'], j_return($specificsField->j_invoke('allInstanceSetImplementations', [], javaList(javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()]))))))
                  ->addMethod($exe->buildPrimaryKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('primaryKeyColumns', [j_parameter(javaInt(), 'setIndex')], javaList(javaString()))))),

             | $exe
         )
      })
      /* ->map({exe |

         if (true,
                            | $exe
                                 ->addMethod($exe->buildAllInstanceSetImplementationsMethod(['public'], j_return($specificsField->j_invoke('allInstanceSetImplementations', [], javaList(javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()]))))))
                                 ->addMethod($exe->buildPrimaryKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('primaryKeyColumns', [j_parameter(javaInt(), 'setIndex')], javaList(javaString()))))),
                            | $exe
                        )
      }) */
      ->map({exe |
      /*
         if (!$isLocalRoot,
             | $exe->addMethod($exe->buildAddChildToParentMethod(['public'], $specificsField->j_invoke('addChildToParent', [j_parameter(javaObject(), 'parent'), j_parameter(javaObject(), 'child'), j_parameter($conventions->className(IExecutionNodeContext), 'executionNodeContext')], javaVoid()), $conventions)),
             | $exe
         )
         */
         $exe
      })
      /*
      ->map({exe |
         if ($isPrimitive || $isClassResult,
                   | $exe->addMethod($exe->buildParentPrimaryKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('parentPrimaryKeyColumns', [j_parameter(javaList(javaString()), 'queryResultColumns')], javaList(javaString()))))),
                   | $exe
               )
      })
      */
      ->map({exe |
      /*
         if ($isCrossRoot,
             | $exe->addMethod($exe->buildParentCrossKeyGettersMethod(['public'], j_return($specificsField->j_invoke('parentCrossKeyGetters', [], javaList(javaReflectMethod()))))),
             | $exe
         )
         */
         $exe
      });
}

function meta::pure::executionPlan::engine::java::graphFetch::document::store::enrichForDocumentStoreGraphExecution(cl: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], context: GenerationContext[1], extensions: meta::pure::extension::Extension[*], debug: DebugContext[1]):Project[1]
{
   let constraintsToExclude = $node.graphFetchTree.constraintsExclusions;
   //let qualifiersProject  = $cl->updateImplementationClassWithQualifiedProperties($node->typeFromStoreLocalNode(), $context);
   let constraintsProject = $cl->createConstraintCheckingForClass($node->typeFromStoreLocalNode(), $constraintsToExclude, $context, $debug->indent());
   let primaryKeyProject  = $cl->updateImplementationClassWithPrimaryKeys($node, $context);
   let additionalProject  = $cl->updateImplementationClassWithSetConnectionAndReference($node, $context);
   mergeProjects([/*$qualifiersProject, */$constraintsProject, $primaryKeyProject, $additionalProject]);
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::updateImplementationClassWithSetConnectionAndReference(implClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], context: GenerationContext[1]): Project[1]
{
   let conventions     = $context.conventions;
   let setIdProp       = meta::pure::executionPlan::document::engine::java::setIdPropertyName();
   let setIdField      = $conventions->fieldName($setIdProp);
   let connectionProp  = meta::pure::executionPlan::document::engine::java::databaseConnectionPropertyName();
   let connectionField = $conventions->fieldName($connectionProp);
   let referenceProp   = $conventions->referencedObjectReference();
   let referenceField  = $conventions->fieldName($referenceProp);

   let updatedClass =
      $implClass
         ->meta::pure::executionPlan::document::engine::java::addObjectMapperField($conventions)
         ->addFields([
            javaField(['private'], javaString(), $setIdField),
            javaField(['public', 'static'], javaString(), $connectionField),
            javaField(['private'], javaString(), $referenceField)
         ])
         ->addMethods([
            javaMethod(['public'], javaString(), $conventions->getterName($setIdProp), [], 'return this.' + $setIdField + ';'),
            javaMethod(['public'], javaVoid(), $conventions->setterName($setIdProp), [javaParam(javaString(), 'setId')], 'this.' + $setIdField + ' = setId;'),
            documentReferenceIdentifierGetterMethodForImplementation($node.resultType->cast(@ClassResultType).setImplementations->cast(@DocumentInstanceSetImplementation), $implClass, $conventions),
            javaMethod(['public'], javaVoid(), $conventions->setterName($referenceProp), [javaParam(javaString(), 'reference')], 'this.' + $referenceField + ' = reference;')
         ]);

   newProject()->addClasses($updatedClass);
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::updateImplementationClassWithPrimaryKeys(implClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], context: GenerationContext[1]): Project[1]
{
   let conventions = $context.conventions;
   let sets        = $node.resultType->cast(@ClassResultType).setImplementations->cast(@DocumentInstanceSetImplementation);

   let withKeys = $sets->fold({set, cl |
      let setIdx = $sets->indexOf($set);
      let pks    = $set->resolvePrimaryKey();
      $pks->fold({pk, clWithKeys |
         let pkIdx    = $pks->indexOf($pk);
         let pkString = 'pk$_' + $pkIdx->toString() + if($sets->size() == 1, | '', | '_' + $setIdx->toString());
         let pkField  = $conventions->fieldName($pkString);

         $clWithKeys
            ->addField(javaField(['private'], javaObject(), $pkField))
            ->addMethod(javaMethod(['public'], javaObject(), $conventions->getterName($pkString), [], 'return this.' + $pkField + ';'))
            ->addMethod(javaMethod(['public'], javaVoid(), $conventions->setterName($pkString), [javaParam(javaObject(), $pkField)], 'this.' + $pkField + ' = ' + $pkField + ';'));
      }, $cl);
   }, $implClass);

   newProject()->addClasses($withKeys);
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::initializeSpecificsClass(node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions = $context.conventions;

   let specificsClass = $context.conventions->planNodeClass([], $path, 'Specifics')
      ->imports(javaPackage('java.util'))
      ->imports(javaPackage('java.util.function'))
      ->imports(javaPackage('java.util.stream'))
      ->imports(javaReflectMethod())
      ->imports(javaResultSet())
      ->imports(javaClass('java.sql.ResultSetMetaData'))
      ->imports(javaClass('java.sql.Types'))
      ->imports(javaClass('org.eclipse.collections.impl.tuple.Tuples'))
      ->imports(javaClass('org.eclipse.collections.api.tuple.Pair'))
      ->imports($conventions->className(IExecutionNodeContext))
      ->imports($conventions->className(IConstantResult))
      ->imports($conventions->className(GraphInstance))
      ->imports($conventions->className(PureDate))
      ->addFields([
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'STRING_TYPES', 'Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'INT_TYPES', 'Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'FLOAT_TYPES', 'Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'BOOL_TYPES', 'Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'STRICT_DATE_TYPES', 'Arrays.asList(Types.DATE, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'DATE_TIME_TYPES', 'Arrays.asList(Types.TIMESTAMP, Types.NULL)'),
         javaField(['private'], javaResultSet(), 'resultSet'),
         javaField(['private'], javaString(), 'databaseTimeZone'),
         javaField(['private'], javaString(), 'databaseConnection'),
         javaField(['private'], javaList(javaClass('java.lang.Integer')), 'columnTypes'),
         javaField(['private'], javaList(javaList(javaClass('java.lang.Integer'))), 'propertyIndices'),
         javaField(['private'], javaList(javaList(javaSupplier(javaObject()))), 'propertyGetters'),
         javaField(['private'], javaClass('java.util.Calendar'), 'calendar'),
         javaField(['private'], javaReflectMethod(), 'parentPropertyAdder'),
         javaField(['private'], javaReflectMethod(), 'parentEdgePointPropertyAdder')
      ])
      ->addMethods([
         meta::pure::executionPlan::document::engine::java::getAlloyNativeValueFromResultSetMethod(),
         meta::pure::executionPlan::document::engine::java::encodeHexMethod()
      ]);
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::addExecuteCachingMethods(executeClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let jThis          = j_this($executeClass);
   let specificsField = $jThis->j_field('specifics');
   //let isLocalRoot    = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isLocalRoot    = $node->instanceOf(DocumentRootQueryTempTableGraphFetchExecutionNode);
   //let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

   $executeClass->map({exe |
      if ($isLocalRoot,
          | $exe
               ->addMethod($exe->buildSupportsCachingMethod(['public'], j_return(j_boolean(true)))),
          | $exe
      )
   });
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::addSpecificsPrepareMethod(specificsClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   let isComplexNode = $node.resultType->instanceOf(PartialClassResultType);
   let typeInfos     = $context.typeInfos;

   let rsetParam = j_parameter(javaResultSet(), 'resultSet');
   let tzParam   = j_parameter(javaString(), 'databaseTimeZone');
   let cParam    = j_parameter(javaString(), 'databaseConnection');

   let jThis                = j_this($specificsClass);
   let resultSetField       = $jThis->j_field('resultSet');
   let dbTimeZoneField      = $jThis->j_field('databaseTimeZone');
   let dbConnectionField    = $jThis->j_field('databaseConnection');
   let calendarField        = $jThis->j_field('calendar');
   let columnTypesField     = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let javaException    = j_parameter(javaException(), 'e');
   let runtimeException = j_parameter(javaRuntimeException(), 'e');

   let resultSetMetDataVar = j_variable(javaClass('java.sql.ResultSetMetaData'), 'resultSetMetaData');
   let columnCountVar      = j_variable(javaInt(), 'columnCount');
   let columnNamesVar      = j_variable(javaList(javaString()), 'columnNames');
   let columnLabelVar      = j_variable(javaString(), 'columnLabel');
   let propertyIndexVar    = j_variable(javaInt(), 'propertyIndex');
   let propertyGetterVar   = j_variable(javaSupplier(javaObject()), 'propertyGetter');

   let enumPropertyGetterCodes = {property:AbstractProperty<Any>[1], propertyType: meta::pure::metamodel::type::Enumeration<Any>[1], currentPropertyMapping: DocumentPropertyMapping[1] |
      let javaEnumeration       =  $conventions->className($propertyType);
      let enumValueMappings     = $currentPropertyMapping.transformer->cast(@EnumerationMapping<Any>).enumValueMappings;
      let enumReverseMapVar     = j_variable(javaMap(javaObject(), javaString()), 'enumReverseMap');
      let enumResVar            = j_variable($javaEnumeration, 'res');
      let transformedR          = j_variable(javaString(), 'transformedR');
      let finalPropertyIndexVar = j_variable(javaInt(), 'finalPropertyIndex');

      let r = j_variable(javaObject(), 'r');

      j_block(
         [
            j_declare(['final'], $finalPropertyIndexVar, $propertyIndexVar),
            j_declare(['final'], $enumReverseMapVar, j_new(javaParameterizedType(javaClass('java.util.HashMap'), [javaObject(), javaString()]), []))
         ]
         ->concatenate(
            $enumValueMappings->map({ev | $ev.sourceValues->map({x |
               $enumReverseMapVar->j_invoke('put', [
                  $x->match([
                     s:String[1] | j_string($s),
                     i:Integer[1] | javaClass('java.lang.Long')->j_invoke('valueOf', j_string($i->toString()), javaLong()),
                     f:Float[1] | javaClass('java.lang.Double')->j_invoke('valueOf', j_string($f->toString()), javaDouble())
                  ]),
                  j_string($ev.enum.name)
               ], javaVoid())
            })})
         )->concatenate(
            $propertyGetterVar->j_assign(j_lambda([]->cast(@Parameter), j_try(
               [
                  $enumResVar->j_declare(j_null()),
                  $r->j_declare($jThis->j_invoke('getAlloyNativeValueFromResultSet', [$resultSetField, $finalPropertyIndexVar, $columnTypesField->j_invoke('get', [$finalPropertyIndexVar->j_minus(j_int(1))], javaInt())], javaObject())),
                  j_if(
                     $r->j_ne(j_null()),
                     [
                        $transformedR->j_declare($enumReverseMapVar->j_invoke('get', [$r], javaString())),
                        j_if(
                           $transformedR->j_eq(j_null()),
                           j_throw(j_new(javaRuntimeException(), [
                              j_string('Enumeration mapping failure. Cannot find transformation for source value \'')
                              ->j_plus($r)
                              ->j_plus(j_string('\' for enumeration property \'' + $property.name->toOne() + '\' of type ' + $propertyType->elementToPath() + ' in enumeration mapping ' + $currentPropertyMapping.transformer->cast(@EnumerationMapping<Any>).name->toOne() + '.'))
                           ]))
                        ),
                        $enumResVar->j_assign(javaClass('java.lang.Enum')->j_invoke('valueOf', [$javaEnumeration->j_classField(), $transformedR], $javaEnumeration))
                     ]
                  ),
                  j_return($enumResVar)
               ],
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )))
         )
      );
   };

   let i = j_variable(javaInt(), 'i');

   $specificsClass
      ->addMethods([
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForStringPropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForIntegerPropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForFloatPropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForDecimalPropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForBooleanPropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForStrictDatePropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForDateTimePropertyMethod(),
         meta::pure::executionPlan::document::engine::java::getResultSetPropertyGetterForDatePropertyMethod()
      ])
      ->addMethod(
         $specificsClass->meta::pure::executionPlan::engine::java::graphFetch::document::store::buildPrepareMethod(
            [],
            j_try(
               [
                  $resultSetField->j_assign($rsetParam),
                  $dbTimeZoneField->j_assign($tzParam),
                  $dbConnectionField->j_assign($cParam),
                  $calendarField->j_assign(j_new(javaClass('java.util.GregorianCalendar'), [javaClass('java.util.TimeZone')->j_invoke('getTimeZone', [$dbTimeZoneField], javaClass('java.util.TimeZone'))])),
                  $resultSetMetDataVar->j_declare($resultSetField->j_invoke('getMetaData', [], javaClass('java.sql.ResultSetMetaData'))),
                  $columnCountVar->j_declare($resultSetMetDataVar->j_invoke('getColumnCount', [], javaInt())),
                  $columnTypesField->j_assign(j_new(javaArrayList(javaClass('java.lang.Integer')), [])),
                  $columnNamesVar->j_declare(j_new(javaArrayList(javaString()), [])),
                  j_for($i->j_declare(j_int(1)), $i->j_le($columnCountVar), $i->j_inc(),
                     [
                        $columnLabelVar->j_declare($resultSetMetDataVar->j_invoke('getColumnLabel', [$i], javaString())),
                        $columnNamesVar->j_invoke(
                           'add',
                           $columnLabelVar->j_invoke('startsWith', [j_string('"')], javaBoolean())->j_and($columnLabelVar->j_invoke('endsWith', [j_string('"')], javaBoolean()))->j_conditional(
                              $columnLabelVar->j_invoke('substring', [j_int(1), $columnLabelVar->j_invoke('length', [], javaInt())->j_minus(j_int(1))], javaString())->j_invoke('toUpperCase', [], javaString()),
                              $columnLabelVar->j_invoke('toUpperCase', [], javaString())
                           ), javaVoid()),
                        $columnTypesField->j_invoke('add', [$resultSetMetDataVar->j_invoke('getColumnType', [$i], javaInt())], javaVoid())
                     ]
                  )
               ]->concatenate(
                  if ($isComplexNode,
                     {|
                        let partialClassResultType = $node.resultType->cast(@PartialClassResultType);
                        let resultClass = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
                        let sets = $partialClassResultType.setImplementations->cast(@DocumentInstanceSetImplementation);
                        let nonExplodingSimplePrimitiveProperties = $typeInfos->allProperties($typeInfos->forClass($resultClass))->filter(x | $x->isPrimitiveValueProperty() && (!$x->hasGeneratedMilestoningPropertyStereotype()) && $x->functionReturnMultiplicity()->hasToOneUpperBound())->filter(x | $x->in($partialClassResultType.propertiesWithParameters.property));

                        [
                           $propertyIndicesField->j_assign(j_new(javaArrayList(javaList(javaInt())), []))
                        ]->concatenate(
                           $sets->size()->range()->map({s |
                              let currentSet = $sets->at($s);
                              let currentSetPks = if (!$currentSet->instanceOf(RootDocumentInstanceSetImplementation),
                                                      | $currentSet->resolvePrimaryKey(),
                                                      | []);
                              /*
                              let addMilestoningProps = getTemporalMilestoningStrategy($currentSet.class)->isNotEmpty() &&
                                                        getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->forAll(s| $s->relationalElementCanSupportStrategy($currentSet->resolveMainTable()));
                              */
                              let index_s = j_variable(javaList(javaInt()), 'index_' + $s->toString());
                              [
                                 $index_s->j_declare(j_new(javaArrayList(javaInt()), []))
                              ]->concatenate(
                                 $nonExplodingSimplePrimitiveProperties
                                    ->map({p | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string($p.name->toOne()->toUpper())], javaInt())->j_plus(j_int(1))], javaVoid())})
                              )
                              /*
                              ->concatenate($addMilestoningProps->if(
                                 | let milestonedPropertyAliases = getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->map(x | $x->temporalColumnAliasProperties()).second->sort();
                                   $milestonedPropertyAliases->map({x | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string($x->toUpper())], javaInt())->j_plus(j_int(1))], javaVoid())});,
                                 | [])
                              )
                              */
                              ->concatenate(
                                 $currentSetPks->size()->range()
                                    ->map({pkIdx | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string('PK_' + $pkIdx->toString() + if($sets->size() == 1, | '', | '_' + $s->toString()))], javaInt())->j_plus(j_int(1))], javaVoid())})
                              )
                              ->concatenate(
                                 [
                                    $propertyIndicesField->j_invoke('add', [$index_s], javaVoid())
                                 ]
                              );
                           })
                        )->concatenate(
                           [
                              $node->graphImplClass($path, $context)->j_field(meta::pure::executionPlan::document::engine::java::databaseConnectionPropertyName(), javaString())->j_assign($cParam),
                              $propertyGettersField->j_assign(j_new(javaArrayList(javaList(javaSupplier(javaObject()))), [])),
                              $propertyIndexVar->j_declare(),
                              $propertyGetterVar->j_declare(j_null())
                           ]
                        )->concatenate(
                           $sets->size()->range()->map({s |
                              let currentSet = $sets->at($s);
                              let currentSetPks = if (!$currentSet->instanceOf(RootDocumentInstanceSetImplementation),
                                                      | $currentSet->resolvePrimaryKey(),
                                                      | []);
                                                      /*
                              let addMilestoningProps = getTemporalMilestoningStrategy($currentSet.class)->isNotEmpty() &&
                                                        getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->forAll(s| $s->relationalElementCanSupportStrategy($currentSet->resolveMainTable()));
                                                        */
                              //let allProperties = $nonExplodingSimplePrimitiveProperties->concatenate($addMilestoningProps->if(|$sets->at($s).class.properties->filter(p| $p->isPrimitiveValueProperty() && $p->hasGeneratedMilestoningPropertyStereotype()), |[])->sortBy(x | $x.name->toOne()));
                              let allProperties = $nonExplodingSimplePrimitiveProperties;
                              let propertyGetter_s = j_variable(javaList(javaSupplier(javaObject())), 'propertyGetter_' + $s->toString());

                              [
                                 $propertyGetter_s->j_declare(j_new(javaArrayList(javaSupplier(javaObject())), []))
                              ]->concatenate(
                                 $allProperties->size()->range()->map({propIndex |
                                    let prop = $allProperties->at($propIndex);
                                    let propertyName = $prop.name->toOne();
                                    let propertyType = $prop->functionReturnType().rawType->toOne();
                                    let propertyMultiplicity = $prop.multiplicity;

                                    [
                                       $propertyIndexVar->j_assign($propertyIndicesField->j_invoke('get', [j_int($s)], javaList(javaInt()))->j_invoke('get', [j_int($propIndex)], javaInt()))
                                    ]->concatenate(
                                       if ($propertyType->in([String, Integer, Float, Decimal, Boolean, StrictDate, DateTime, Date]),
                                          {|
                                             $propertyGetterVar->j_assign($jThis->j_invoke('getResultSetPropertyGetterFor' + $propertyType.name->toOne() + 'Property', [
                                                $resultSetField,
                                                $propertyIndexVar,
                                                $resultSetMetDataVar->j_invoke('getColumnType', [$propertyIndexVar], javaInt()),
                                                j_string($propertyName)
                                             ], javaSupplier(javaObject())))
                                          },
                                          {|
                                             if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                                                {|
                                                   let allPropertyMappings = $sets->at($s)->cast(@InstanceSetImplementation).allPropertyMappings()->filter(pm | $pm.property->instanceOf(Property) && $pm.property->functionReturnType().rawType->toOne()->instanceOf(meta::pure::metamodel::type::DataType));
                                                   let currentPropertyMapping = $allPropertyMappings->filter(x | $x.property == $prop)->toOne()->cast(@DocumentPropertyMapping);
                                                   $enumPropertyGetterCodes->eval($prop, $propertyType, $currentPropertyMapping);
                                                },
                                                {|
                                                   [
                                                      j_throw(j_new(javaRuntimeException(), [j_string('Type : \'' + $propertyType->elementToPath() + '\' not supported yet!')]))
                                                   ]
                                                }
                                             );
                                          }
                                       )
                                    )->concatenate(
                                       [
                                          $propertyGetter_s->j_invoke('add', $propertyGetterVar, javaVoid())
                                       ]
                                    );
                                 })
                              )
                              ->concatenate(
                                 [
                                    $propertyGettersField->j_invoke('add', $propertyGetter_s, javaVoid())
                                 ]
                              );
                           })
                        );
                     },
                     {|
                        let property = $node.graphFetchTree->cast(@PropertyGraphFetchTree).property;
                        let propertyName = $property.name->toOne();
                        let propertyType = $property->functionReturnType().rawType->toOne();

                        [
                           $propertyIndexVar->j_declare($columnNamesVar->j_invoke('indexOf', [j_string('NODE_' + $node.nodeIndex->toString() + '_RESULT')], javaInt())->j_plus(j_int(1))),
                           $propertyIndicesField->j_assign(javaArrays()->j_invoke('asList', [javaArrays()->j_invoke('asList', [$propertyIndexVar], javaList(javaWildcard()))], javaList(javaWildcard()))),
                           $propertyGetterVar->j_declare(j_null())
                        ]->concatenate(
                           if ($propertyType->in([String, Integer, Float, Decimal, Boolean, StrictDate, DateTime, Date]),
                              {|
                                 $propertyGetterVar->j_assign($jThis->j_invoke('getResultSetPropertyGetterFor' + $propertyType.name->toOne() + 'Property', [
                                    $resultSetField,
                                    $propertyIndexVar,
                                    $resultSetMetDataVar->j_invoke('getColumnType', [$propertyIndexVar], javaInt()),
                                    j_string($propertyName)
                                 ], javaSupplier(javaObject())))
                              },
                              {|
                                 if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                                    {|
                                       let currentPropertyMapping = $node.graphFetchTree->cast(@RoutedPropertyGraphFetchTree).propertyMapping->at(0)->cast(@DocumentPropertyMapping);
                                       $enumPropertyGetterCodes->eval($property, $propertyType, $currentPropertyMapping);
                                    },
                                    {|
                                       [
                                          j_throw(j_new(javaRuntimeException(), [j_string('Type : \'' + $propertyType->elementToPath() + '\' not supported yet!')]))
                                       ]
                                    }
                                 );
                              }
                           )
                        )->concatenate(
                           [
                              $propertyGettersField->j_assign(javaArrays()->j_invoke('asList', [javaArrays()->j_invoke('asList', [$propertyGetterVar], javaList(javaWildcard()))], javaList(javaWildcard())))
                           ]
                        );
                     }
                  )
               )->toOneMany(),
               j_catch($runtimeException, j_throw($javaException)),
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )
         )
      );
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::addSpecificsGeneralMethods(specificsClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions    = $context.conventions;
   let isComplexNode  = $node.resultType->instanceOf(PartialClassResultType);
   let typeInfos      = $context.typeInfos;

   let isPrimitive    = $node->instanceOf(DocumentPrimitiveQueryGraphFetchExecutionNode);
     let isClassResult  = $node->instanceOf(DocumentClassQueryTempTableGraphFetchExecutionNode) && !$node->instanceOf(DocumentRootQueryTempTableGraphFetchExecutionNode);
     let isLocalRoot    = $node->instanceOf(DocumentRootQueryTempTableGraphFetchExecutionNode);
     //let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

  // let isComplex      = $isClassResult || $isLocalRoot;

   let isComplex = true;

   let jThis                = j_this($specificsClass);
   let resultSetField       = $jThis->j_field('resultSet');
   let dbTimeZoneField      = $jThis->j_field('databaseTimeZone');
   let dbConnectionField    = $jThis->j_field('databaseConnection');
   let calendarField        = $jThis->j_field('calendar');
   let columnTypesField     = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let javaException    = j_parameter(javaException(), 'e');
   let runtimeException = j_parameter(javaRuntimeException(), 'e');

/*
   let nextType = if (!$isPrimitive,
                      | graphInstanceOf(javaWildcardExtends($conventions->className(IReferencedObject)), $conventions),
                      | graphInstanceOf(javaWildcard(), $conventions)
                  );
                  */
    let nextType = graphInstanceOf(javaWildcardExtends($conventions->className(IReferencedObject)), $conventions);

    $specificsClass
      ->addMethod(
         $specificsClass->buildNextGraphInstanceMethod(
            [],
            $nextType,
            j_try(
               if ($isComplex,
                  {|
                     let partialClassResultType    = $node.resultType->cast(@PartialClassResultType);
                     let resultClass               = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
                     let implClass                 = $node->graphImplClass($path, $context);
                     let sets                      = $partialClassResultType.setImplementations->cast(@DocumentInstanceSetImplementation);
                     let simplePrimitiveProperties = $typeInfos->allProperties($typeInfos->forClass($resultClass))->filter(x | $x->isPrimitiveValueProperty() && (!$x->hasGeneratedMilestoningPropertyStereotype()) && $x->functionReturnMultiplicity()->hasToOneUpperBound())->filter(x | $x->in($partialClassResultType.propertiesWithParameters.property));

                     if ($sets->size() == 1,
                        {|
                           $specificsClass->objectCreationCodes($implClass, $sets->at(0), $sets, $simplePrimitiveProperties, 0, $context)
                              ->concatenate(
                                 [
                                    j_return(j_newAnon(graphInstanceOf($implClass, $conventions), [],
                                       [
                                          j_method(['public'], $implClass, 'getValue', [], [j_return(j_variable($implClass, 'object'))]),
                                          j_method(['public'], javaLong(), 'instanceSize', [], [j_return(j_variable($implClass, 'object')->j_invoke($conventions->getterName(instanceSizeIdentifier()), [], javaLong()))])
                                       ]
                                    ))
                                 ]
                              );
                        },
                        {|
                           $sets->size()->range()->map({s |

                              let objectCreationCodes = $specificsClass->objectCreationCodes($implClass, $sets->at($s), $sets, $simplePrimitiveProperties, $s, $context);

                               [
                                  j_if(
                                     $resultSetField->j_invoke('getInt', j_int(1), javaInt())->j_eq(j_int($s)),
                                     $objectCreationCodes->concatenate(
                                        j_return(j_newAnon(graphInstanceOf($implClass, $conventions), [],
                                           [
                                              j_method(['public'], $implClass, 'getValue', [], [j_return(j_variable($implClass, 'object'))]),
                                              j_method(['public'], javaLong(), 'instanceSize', [], [j_return(j_variable($implClass, 'object')->j_invoke($conventions->getterName(instanceSizeIdentifier()), [], javaLong()))])
                                           ]
                                        ))
                                     )->toOneMany()
                                  )
                               ];
                            })->concatenate(
                               j_return(j_null())
                            );
                        }
                     );
                  },
                  {|
                    println('should execute this block')
                  }
               )->toOneMany(),
               j_catch($runtimeException, j_throw($runtimeException)),
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )
         )
      )
      ->map({spe |
         if ($isComplex,
            {|
               let currentSets = $node.resultType->cast(@PartialClassResultType).setImplementations;
               let currentKeyStrings = $currentSets->map({set |
                  let setIdx = $currentSets->indexOf($set);
                  let setPk = $set->cast(@DocumentInstanceSetImplementation)->resolvePrimaryKey();
                  $setPk->map(x | 'pk$_' + $setPk->indexOf($x)->toString() + if($currentSets->size() == 1, | '', | '_' + $setIdx->toString()));
               });
               $spe->addMethod(
                  $spe->buildPrimaryKeyGettersMethod(
                     [],
                     [
                        j_try(
                           j_return(javaArrays()->j_invoke('asList', $currentKeyStrings->map({x | $node->graphImplClass($path, $context)->j_classField()->j_invoke('getMethod', [j_string($conventions->getterName($x))], javaReflectMethod())}), javaList(javaReflectMethod()))),
                           j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
                        )
                     ]
                  )
               );
            },
            {| $spe }
         )
      })

    ->map({spe |
          if ( ($isClassResult || $isLocalRoot),
            {|
                let partialClassResultType = $node.resultType->cast(@PartialClassResultType);
                let resultClass            = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
                let sets                   = $partialClassResultType.setImplementations->cast(@DocumentInstanceSetImplementation);
                let pairType               = javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()]);

                let currentSets            = $node.resultType->cast(@PartialClassResultType).setImplementations;
                let setIndexParam          = j_parameter(javaInt(), 'setIndex');
                let keyStringsFunction     = {set: DocumentInstanceSetImplementation[1] |
                  let setIdx = $currentSets->indexOf($set);
                  let setPk  = $set->resolvePrimaryKey();
                  $setPk->map(x | 'pk_' + $setPk->indexOf($x)->toString() + if($currentSets->size() == 1, | '', | '_' + $setIdx->toString()))->map(x | j_string($x));
                };

                $spe
                  ->addMethod(
                      $spe->buildAllInstanceSetImplementationsMethod(
                        [],
                        j_return(javaArrays()->j_invoke('asList', $sets->map(s | javaClass('org.eclipse.collections.impl.tuple.Tuples')->j_invoke('pair', [j_string($s.parent->elementToPath()), j_string($s.id)], $pairType)), javaList($pairType)))
                      )
                  )
                  ->addMethod(
                      $spe->buildPrimaryKeyColumnsMethod(
                        [],
                        $sets->map(s | j_if($setIndexParam->j_eq(j_int($sets->indexOf($s))), j_return(javaArrays()->j_invoke('asList', $keyStringsFunction->eval($s), javaList(javaString())))))->concatenate(j_return(j_null()))
                      )
                  );
            },
             {| $spe }
          )
      })
;
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::addSpecificsCachingMethods(specificsClass: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   /*
   let isLocalRoot   = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isCrossRoot   = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);
    */

   $specificsClass->map({exe |
      $exe
   });
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::objectCreationCodes(specificsClass: meta::external::language::java::metamodel::Class[1], implClass: meta::external::language::java::metamodel::Class[1], set: DocumentInstanceSetImplementation[1], allSets: DocumentInstanceSetImplementation[*], properties: Property<Nil,Any|*>[*], index: Integer[1], context:GenerationContext[1]):Code[*]
{
   let conventions = $context.conventions;
   let jThis = j_this($specificsClass);
   let calendarField = $jThis->j_field('calendar');
   let columnTypesField = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let resParam = j_parameter(javaType('java.sql.ResultSet'), 'resultSet');

   let currentSetPks = if (!$set->instanceOf(RootDocumentInstanceSetImplementation),
                           | $set->resolvePrimaryKey(),
                           | []);

   let propertyCount = $properties->size();
   let pureTypeToJavaTypeMap = newMap([
      pair(String, javaString()),
      pair(Integer, javaLong()->toBoxed()),
      pair(Float, javaDouble()->toBoxed()),
      pair(Decimal, javaBigDecimal()),
      pair(Boolean, javaBoolean()->toBoxed()),
      pair(StrictDate, $conventions->className(PureDate)),
      pair(DateTime, $conventions->className(PureDate)),
      pair(Date, $conventions->className(PureDate))
   ]);

   let object = j_variable($implClass, 'object');
   let connectionParam = j_parameter(javaString(), 'databaseConnection');
   let pkColIndex = j_variable(javaInt(), 'pkColIndex');
   let propertyIndex = j_variable(javaInt(), 'propertyIndex');

   [
      j_declare(['final'], $object, j_new($implClass, [])),
      $object->j_invoke($conventions->setterName(meta::pure::executionPlan::document::engine::java::setIdPropertyName()), [j_string($set.id)], javaVoid()),
      $pkColIndex->j_declare(),
      $propertyIndex->j_declare()
   ]->concatenate(
      $currentSetPks->size()->range()->map({pkIdx |
         let pkStr = 'pk$_' + $pkIdx->toString() + if($allSets->size() == 1, | '', | '_' + $allSets->indexOf($set)->toString());
         let pkVar = j_variable(javaObject(), $pkStr);
         [
            $pkColIndex->j_assign($propertyIndicesField->j_invoke('get', [j_int($index)], javaList(javaInt()))->j_invoke('get', [j_int($propertyCount + $pkIdx)], javaInt())),
            $pkVar->j_declare($jThis->j_invoke('getAlloyNativeValueFromResultSet', [$resParam, $pkColIndex, $columnTypesField->j_invoke('get', [$pkColIndex->j_minus(j_int(1))], javaInt())], javaObject())),
            $object->j_invoke($conventions->setterName($pkStr), [$pkVar], javaVoid())
         ];
      })
   )->concatenate(
      $propertyCount->range()->map({propIndex |
      let prop = $properties->at($propIndex);
      let propertyName = $prop.name->toOne();
      let propertyType = $prop->genericType().typeArguments->at(1).rawType->toOne();
      let propertyMultiplicity = $prop.multiplicity;
      let javaType = if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                         | $conventions->className($propertyType),
                         | let jt = $pureTypeToJavaTypeMap->get($propertyType);
                           assert($jt->isNotEmpty(), | 'Property type \'' + $propertyType->elementToPath() + '\' not supported yet. Property name: \'' + $propertyName + '\'');
                           $jt->toOne();
                     );
      let resVar = j_variable($javaType, 'res');

      [
         $propertyIndex->j_assign($propertyIndicesField->j_invoke('get', [j_int($index)], javaList(javaInt()))->j_invoke('get', [j_int($propIndex)], javaInt())),
         j_block(
            [
               $resVar->j_declare(j_cast($propertyGettersField->j_invoke('get', [j_int($index)], javaList(javaSupplier(javaObject())))->j_invoke('get', [j_int($propIndex)], javaSupplier(javaObject()))->j_invoke('get', [], javaObject()), $javaType))
            ]->concatenate(
               if ($propertyMultiplicity->getLowerBound() == 1,
                   | j_if($resVar->j_eq(j_null()), j_throw(j_new(javaRuntimeException(),[j_string('Error reading in property \'' + $propertyName + '\'. Property of multiplicity [1] can not be null')]))),
                   | []
               )
            )->concatenate(
               [
                  $object->j_invoke($conventions->setterName($prop), [$resVar], javaVoid())
               ]
            )
         )
      ];
   }));
}

function meta::pure::executionPlan::engine::java::graphFetch::document::store::enrichForDocumentGraphExecution(cl: meta::external::language::java::metamodel::Class[1], node: DocumentGraphFetchExecutionNode[1], context: GenerationContext[1], extensions: meta::pure::extension::Extension[*], debug: DebugContext[1]):Project[1]
{
   let constraintsToExclude = $node.graphFetchTree.constraintsExclusions;
   //let qualifiersProject  = $cl->updateImplementationClassWithQualifiedProperties($node->typeFromStoreLocalNode(), $context);
   let constraintsProject = $cl->createConstraintCheckingForClass($node->typeFromStoreLocalNode(), $constraintsToExclude, $context, $debug->indent());
   let primaryKeyProject  = $cl->updateImplementationClassWithPrimaryKeys($node, $context);
   let additionalProject  = $cl->updateImplementationClassWithSetConnectionAndReference($node, $context);
   mergeProjects([/*$qualifiersProject, */$constraintsProject, $primaryKeyProject, $additionalProject]);
}

// shouldn't be here
function meta::pure::executionPlan::engine::java::documentReferenceIdentifierGetterMethodForImplementation(sets: DocumentInstanceSetImplementation[*], implClass: meta::external::language::java::metamodel::Class[1], conventions: Conventions[1]):meta::external::language::java::metamodel::Method[1]
{
   let referenceIdentifier = $conventions->fieldName($conventions->meta::pure::executionPlan::document::engine::java::storeObjectReferenceIdentifier());
   javaMethod(
      ['public'], javaString(), $conventions->getterName($conventions->meta::pure::executionPlan::document::engine::java::storeObjectReferenceIdentifier()), [],
      'if (this.' + $referenceIdentifier + ' == null)\n'+
      '{\n'+
      '    try\n'+
      '    {\n'+
      '        StringBuilder referenceBuilder = new StringBuilder();\n'+
      '        referenceBuilder.append("001:");\n'+
      '        referenceBuilder.append("010:");\n\n'+
      '        referenceBuilder.append("' + format('%010d', length('Relational')) + ':");\n'+
      '        referenceBuilder.append("Relational:");\n\n'+
      '        referenceBuilder.append("' + format('%010d', length($sets.parent->at(0)->elementToPath())) + ':");\n'+
      '        referenceBuilder.append("' + $sets.parent->at(0)->elementToPath() + ':");\n\n'+
      '        referenceBuilder.append("' + format('%010d', length($sets.id->joinStrings(';'))) + ':");\n'+
      '        referenceBuilder.append("' + $sets.id->joinStrings(';') + ':");\n\n'+
      '        String setId = this.' + $conventions->getterName(meta::pure::executionPlan::document::engine::java::setIdPropertyName()) + '();\n'+
      '        referenceBuilder.append(String.format("%010d", setId.length()));\n'+
      '        referenceBuilder.append(":");\n'+
      '        referenceBuilder.append(setId);\n'+
      '        referenceBuilder.append(":");\n\n'+
      '        String databaseConnectionString = ' + $implClass->typeToString() + '.' + $conventions->fieldName(meta::pure::executionPlan::document::engine::java::databaseConnectionPropertyName()) + ';\n'+
      '        referenceBuilder.append(String.format("%010d", databaseConnectionString.length()));\n'+
      '        referenceBuilder.append(":");\n'+
      '        referenceBuilder.append(databaseConnectionString);\n'+
      '        referenceBuilder.append(":");\n\n'+
      '        Map<String, Object> pkMap = new HashMap<>();\n\n'+
      $sets->map({set |
         let setIdx = $sets->indexOf($set);
         let pks = $set->resolvePrimaryKey();
         $pks->map({key |
            let pkIdx = $pks->indexOf($key);
            let pkString = 'pk$_' + $pkIdx->toString() + if($sets->size() == 1, | '', | '_' + $setIdx->toString());
            '        pkMap.put("' + $conventions->fieldName($pkString) + '", this.' + $conventions->getterName($pkString)+ '());';
         });
      })->joinStrings('\n')+'\n'+
      '        String pkMapString = objectMapper$.writeValueAsString(pkMap);\n'+
      '        referenceBuilder.append(String.format("%010d", pkMapString.length()));\n'+
      '        referenceBuilder.append(":");\n'+
      '        referenceBuilder.append(pkMapString);\n\n'+
      '        this.' + $referenceIdentifier + ' = "ASOR:" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n'+
      '    }\n'+
      '    catch (Exception e)\n'+
      '    {\n'+
      '       throw new RuntimeException(e);\n'+
      '    }\n'+
      '}\n\n'+
      'return this.' + $referenceIdentifier + ';'
   );
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildPrepareMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaVoid(), 'prepare', [javaParam(javaList(javaClass('? extends org.finos.legend.engine.plan.dependencies.store.document.graphFetch.IDocumentQueryResultField')), 'documentQueryResultFields'), javaParam(javaString(), 'databaseTimeZone'), javaParam(javaString(), 'databaseConnection')], $code)
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildNextGraphInstanceMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], type: meta::external::language::java::metamodel::Type[1], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, $type, 'nextGraphInstance', [], $code)
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildPrimaryKeyGettersMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaReflectMethod()), 'primaryKeyGetters', [], $code)
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildPrimaryKeyColumnsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaString()), 'primaryKeyColumns', [javaParam(javaInt(), 'setIndex')], $code)
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildSupportsCachingMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaBoolean(), 'supportsCaching', [], $code)
}

function <<access.private>> meta::pure::executionPlan::engine::java::graphFetch::document::store::buildAllInstanceSetImplementationsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()])), 'allInstanceSetImplementations', [], $code)
}
