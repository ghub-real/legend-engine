// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;
import meta::pure::extension::*;
import meta::pure::router::printer::*;
import meta::pure::functions::collection::*;
import meta::external::store::document::metamodel::*;
import meta::external::store::document::extension::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::external::store::document::mapping::functions::*;
//import meta::external::store::service::executionPlan::generation::*;
import meta::external::store::document::metamodel::runtime::*;
import meta::external::store::document::extension::documentQueryToString::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::documentmappingspecification::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::metamodel::*;
import meta::external::store::document::mapping::*;


//Class meta::external::store::document::functions::pureToDocumentStoreQuery::DocumentStoreQuery
//{
//   processingParam        :  String[0..1];
//   processingValue        :  Value[0..1];
//   processedParamValueMap :  Map<String, Value>[1];
//   recordsToBeRead        :  Integer[0..1];
//}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::State
{
   mapping:Mapping[1];
   propertyMappingFromRouter : PropertyMapping[*];
   graphFetchFlow : Boolean[0..1];
   inScopeVars:Map<String, List<Any>>[1];
   supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1];
   graphFetchProperties : Property<Nil,Any|*>[*];
   inFilter:Boolean[1];
   leftSideOfQualifier : ValueSpecification[0..1];
   inGetterFlow:Boolean[0..1];
   functionExpressionStack : FunctionExpression[*];
   inProject:Boolean[1]; 
   importDataFlowAddFks: Boolean[0..1];
   inProjectFunctions: Boolean[1];
   processingProjectionThread: Boolean[1];
   shouldIsolate: Boolean[0..1];
   qualifierBase:OperationWithParentPropertyMapping[0..1];
   functionReferenceScope : FunctionParamScope[0..1];
   inIf:Boolean[0..1];
   inIfTrueFalseStmt:Boolean[0..1];
}


Class meta::external::store::document::functions::pureToDocumentStoreQuery::FunctionParamScope
{
   parent : FunctionParamScope[0..1];
   varToSelect : Map<String,SelectDocumentQuery>[0..1];
   varExpressionToSelect :  Pair<VariableExpression,FunctionParamScope>[*];

   resolveFunctionReferenceByName(s : String[1]){
      let resolved = if(!$this.varToSelect->isEmpty(),|$this.varToSelect->toOne()->get($s),|[]);
      if ($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByName($s),|[]),|$resolved->toOne());
   }:SelectDocumentQuery[0..1];

   resolveFunctionReferenceByVar(v : VariableExpression[1]){
      let resolved = $this.varExpressionToSelect->filter(p|$p.first.name == $v.name)->first();
      if($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByVar($v),|[]),|$resolved.second->toOne());
   }:FunctionParamScope[0..1];
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::updateFunctionParamScope(state:State[1], functionType:FunctionType[1], selectDocumentQuery: SelectDocumentQuery[1]):State[1]
{
   let paramNames = $functionType.parameters->evaluateAndDeactivate().name;
   let values=$paramNames->map(p|pair($p,$selectDocumentQuery));
   let varToSelect=newMap($values);
   let newScope = ^FunctionParamScope(parent=$state.functionReferenceScope, varToSelect=$varToSelect);
   ^$state(functionReferenceScope=$newScope);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::updateFunctionParamScope(state:State[1], variableExpressions:VariableExpression[*], selectDocumentQuery: SelectDocumentQuery[1]):State[1]
{
   if(!$state.functionReferenceScope->isEmpty(),| let varExpressionToSelect=$variableExpressions->map(v|pair($v,$state.functionReferenceScope->toOne()));
                                                  let newScope = ^FunctionParamScope(parent=$state.functionReferenceScope, varExpressionToSelect=$varExpressionToSelect);
                                                  ^$state(functionReferenceScope=$newScope);,
                                                | $state);
}

// meta::external::store::document::functions::pureToDocumentStoreQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_
function meta::external::store::document::functions::pureToDocumentStoreQuery::processNoOp(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1],  context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   //Ignores the function and only processes the first parameter
   processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne()
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processValueSpecification(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*],  operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
   processValueSpecificationReturnPropertyMapping($vs, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->map(r | $r.element);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processValueSpecificationReturnPropertyMapping(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let res = $vs->evaluateAndDeactivate()->match(
             [
                 r:ExtendedRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, ^$state(propertyMappingFromRouter = $r.propertyMapping), $context, $extensions),
                 r:FunctionRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                 f:FunctionExpression[1] | processFunctionExpression($f, $currentPropertyMapping, $operation, $vars, ^$state(functionExpressionStack+=$f),  $context, $extensions),
                 i:InstanceValue[1] | let elements = processInstanceValue($i, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions);
                                      $elements->map(e | ^OperationWithParentPropertyMapping(element=$e));,
                 v:VariableExpression[1] | processVariableExpression($v,$currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                 n:NoSetRoutedValueSpecification[1]|$n.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $context, $extensions)                 
             ]);
    $res.element->map(e|$e->match([c:ClassInstanceHolder[1]|true, s:SelectDocumentQuery[1]|$s->validate($vs, $extensions)]));
    $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processVariableExpression(v:VariableExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   print(if(!$context.debug, |'', | $context.space+'>Process Variable Expression, name:' + $v.name + '\n'));
   if ($v.name == 'this' && $state.qualifierBase->isNotEmpty(), | let op = $state.qualifierBase->toOne();
                            let sel = $op.element->cast(@SelectDocumentQuery);
                            //let sel = $elem.select;
                            ^$op(element = ^$sel(filteringOperation = []));,
                          | let res = $v->resolve($vars, $state.inScopeVars)->evaluateAndDeactivate();

                            let resolvedOperation = if(!$state.functionReferenceScope->isEmpty(), //attempt to resolve the variable name to a SelectWithCursor recorded in either this or a parent scope
                                                            | let resolvedOperation = $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name);
                                                              if(!$resolvedOperation->isEmpty(),| $resolvedOperation,|$operation)->toOne();,
                                                            | $operation);

                            let nres = if($res->isNotEmpty() && $res->toOne()->instanceOf(InstanceValue) && $res->cast(@InstanceValue).values->size() == 1 && //$res->cast(@InstanceValue).values->at(0)->instanceOf(VarPlaceHolder) &&
                                          !$state.functionReferenceScope->isEmpty() && $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name)->isNotEmpty(),
                                          |//The open variable is managed in the scope of the expression, so we should not stub it
                                           [],
                                          |$res
                                        );

                            if($nres->isEmpty(),                                                   //true for function params e.g. $e in '[]->filter(e|$e...)'
                                       |$operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                                                             a:DocumentStoreElement[1] | ^OperationWithParentPropertyMapping(
                                                                                                    element=$resolvedOperation,
                                                                                                    currentPropertyMapping=$currentPropertyMapping
                                                                                               )
                                                          ]),
                                       |$nres->toOne()->match(
                                                                [
                                                                   e:VariableExpression[1]| ^OperationWithParentPropertyMapping(element=$operation);,
                                                                   a:Any[1]|                     //the resolved VariableExpression (ValueSpecification) is processed with respect to the $state recorded at the time the owning QualifiedProperty is processed e.g. address in 'Firm.all->filter(f|$f.employeesByAddress($f.address));' employeesByAddress(address: Address[1]){..}'
                                                                            let possiblyNewState = if(!$state.functionReferenceScope ->isEmpty(),
                                                                                                                    | let resolvedVariableExpression=$state.functionReferenceScope->toOne().resolveFunctionReferenceByVar($v);
                                                                                                                      if(!$resolvedVariableExpression->isEmpty(),|^$state(functionReferenceScope=$resolvedVariableExpression->toOne()),|$state);,
                                                                                                                    | $state
                                                                                                     )->toOne();
                                                                            processValueSpecificationReturnPropertyMapping($nres->toOne(), $currentPropertyMapping, $resolvedOperation, $vars, $possiblyNewState, $context->shift(), $extensions);
                                                                ]);
                             );
                          )->cast(@OperationWithParentPropertyMapping);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processFunctionExpression(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
  print(if(!$context.debug, |'', | $context.space+'>Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'));
  let res  = $functionExpression.func->match ([
                                    p:Property<Nil,Any|*>[1] | processPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);,
                                    //q:QualifiedProperty<Any>[1] | processQualifiedPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);,
                                    a:Any[1]| processFunctionExpressionForNonPropertyFunction($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);
                                   ]);

 print(if(!$context.debug, |'', | $context.space+'>End Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'+$res.element->cast(@SelectDocumentQuery)->map(s | $s->printDebugQuery($context.space, $extensions))->joinStrings(', ')));

  $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processFunctionExpressionForNonPropertyFunction(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let func = findSupportedFunction($functionExpression, $state.supportedFunctions);
   if ( (!$func->isEmpty()), | let params1 = [^List<Any>(values=$functionExpression), ^List<Any>(values=$currentPropertyMapping)];
                                   let params = $params1->concatenate([$operation, $vars, $state, $context]->map(v | ^List<Any>(values=$v)))->concatenate(^List<Any>(values = $extensions));
                                   $func->toOne()->evaluate($params)->cast(@DocumentStoreElement)->toOne()->wrapIfNecessary();
       , |


      if($functionExpression.func->instanceOf(FunctionDefinition),
         |let expression = $functionExpression.func->cast(@FunctionDefinition<Any>).expressionSequence;
              assertEquals(1, $expression->size(), | 'Functions with more than one functionExpression are not supported yet! The function \'' + $functionExpression.func->toString() + '\' has ' + $expression->size()->toString() + ' expressions.');
              processValueSpecificationReturnPropertyMapping($expression->toOne(), $currentPropertyMapping, $operation, $functionExpression->mapVariables($vars, $state.inScopeVars), ^$state(inScopeVars=^Map<String, List<Any>>()), $context->shift(), $extensions);
         ,
         |fail('No MQL translation exists for the PURE function \''+$functionExpression.func.name->toOne()+'\'. \nIf you would like to add a SQL translation for the function then follow the step-by-step guide on the PURE wiki.'); $operation->wrapIfNecessary();
          );
   );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processInstanceValue(i:InstanceValue[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
   processValue($i.values, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processValue(vals:Any[*], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
    let select = $operation;
    if ($vals->isEmpty(), | $state.inFilter->if(|^$select(filteringOperation = ^meta::external::store::document::metamodel::Literal(value=^DocumentNull())),|^$select(fields = ^meta::external::store::document::metamodel::Literal(value=^DocumentNull())))
                        , | $vals->map(v | $v->match([
                                  s:String[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$s)),|^$select(fields = ^Literal(value=$s))),
                                  n:Number[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$n)),|^$select(fields = ^Literal(value=$n))),
                                  d:Date[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$d)),|^$select(fields = ^Literal(value=$d))),
                                  b:Boolean[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$b)),|^$select(fields = ^Literal(value=$b))),
                                  //e:Enum[1] | let ev = mapEnumValue($e, $currentPropertyMapping, $context); ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$ev)),|^$select(columns = ^Literal(value=$ev))));,
                                  v:ValueSpecification[1] | processValueSpecification($v, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                                  l:LambdaFunction<Any>[1] | $l.expressionSequence->at(0)->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                                  a:Any[1] | ^ClassInstanceHolder(value=$a);
                             ])) );
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::validate(s:SelectDocumentQuery[1], v:ValueSpecification[0..1], extensions:Extension[*]):Boolean[1]
{
   let allNodes = if($s.data->isEmpty(),|[],|$s.data->toOne()->getAllNodes())->cast(@DocumentTreeNode);
   // validateNode('currentTreeNode', $s, $s.currentTreeNode, $v, $allNodes, $extensions);
   // What exactly do we validate here?
   true;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::validateNode(nodeName:String[1], s:SelectDocumentQuery[1], node:DocumentTreeNode[0..1], v:ValueSpecification[0..1], allNodes:DocumentTreeNode[*], extensions:Extension[*]):Boolean[1]
{
   if ($node->isEmpty(),
      |true,
      |
         assert(
              $allNodes->contains($node->toOne()),
              |'\nfail:\n\nNODE VALIDATION ERROR: '+$nodeName+'\n\n'+$allNodes->map(n|$n->printNode())->makeString(', ')+'\n\nDOESN\'T CONTAIN:\n\n'+$node->printNode()+
               '\n\nIN:\n\n\''+$s->printDebugQuery('', $extensions)+
               'VS: \''+if($v->isEmpty(),|'',|$v->toOne()->meta::pure::router::printer::asString()+'\'');
             );
   );
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::OperationWithParentPropertyMapping extends DocumentStoreElement
{
   element : DocumentStoreElement[1];
   currentPropertyMapping : PropertyMapping[*];
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::ClassInstanceHolder extends DocumentStoreElement
{
   value : Any[1];
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::shift(d:DebugContext[1]):DebugContext[1]
{
   ^$d(space = $d.space+'   ');
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::findSupportedFunction(fe:FunctionExpression[1], supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1]):meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>[0..1]
{
  $supportedFunctions->get($fe.func)
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::getSupportedFunctions():Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1]
{
   newMap([
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__T_MANY_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::collection::filter_T_MANY__Function_1__T_MANY_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processFilter_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processEquals_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_,second=meta::external::store::document::functions::pureToDocumentStoreQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::boolean::or_Boolean_1__Boolean_1__Boolean_1_,second=meta::external::store::document::functions::pureToDocumentStoreQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToDocumentStoreFunctionPair(first=meta::pure::functions::boolean::not_Boolean_1__Boolean_1_,second=meta::external::store::document::functions::pureToDocumentStoreQuery::processNot_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_)
      ]);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processPropertyFunctionExpression(fe:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let propertyOwner = $fe.parametersValues->at(0)->map(p|$p->byPassRouterInfo());

   print(if(!$context.debug, |'', | $context.space+'>Process Property Function Expression: ' + $fe.func.name->toOne() + ', property owner:' + $propertyOwner.genericType->genericTypeClass().name->toOne() + ', inFilter:' + $state.inFilter->toString() + '\n'));

   let leftSide = processValueSpecificationReturnPropertyMapping($fe.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions)->toOne();
   let result = $leftSide.element->match(
                     [
                        c : ClassInstanceHolder[1] |
                              let val = $fe.func->cast(@Property<Nil,Any|*>)->eval($c.value);
                              let element = processValue($val, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions)->toOne();
                              ^OperationWithParentPropertyMapping(element=$element);,
                        sel : SelectDocumentQuery[1] |
                                let toCheckVals = if ($state.inFilter, |$sel.filteringOperation, |$sel.fields);
                                let property = $fe.func->cast(@AbstractProperty<Any>);
                                let propertyOwnerClass = $propertyOwner.genericType->genericTypeClass();
                                let baseOperation = if($currentPropertyMapping->isEmpty()
                                                                ,| $leftSide.currentPropertyMapping
                                                                ,| $currentPropertyMapping
                                                   )->match([
                                                         o:OtherwiseEmbeddedDocumentInstanceSetImplementation[1] | let navigateToOtherwiseMapping = $o.propertyMappingsByPropertyName($property.name->toOne())->isEmpty();
                                                                                                                    ^OperationWithParentPropertyMapping
                                                                                                                     (
                                                                                                                        element = $sel,
                                                                                                                        currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                                                                      );
                                                                                                                     ,

                                                         a:Any[*]|^OperationWithParentPropertyMapping
                                                                  (
                                                                     element = $sel,
                                                                     currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                  );
                                                      ]);
                              processProperty(
                                           $property,
                                           $propertyOwnerClass,
                                           $baseOperation.currentPropertyMapping,
                                           $state.propertyMappingFromRouter,
                                           $baseOperation.element->cast(@SelectDocumentQuery),
                                           $state,
                                           $context->shift(),
                                           $extensions
                                      );
                           

                     ]
                   );
   $result;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::printDebugQuery(select:SelectDocumentQuery[1], space:String[1], extensions:Extension[*]):String[1]
{
   $select->meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(meta::external::store::document::metamodel::runtime::DatabaseType.Mongo, $extensions);
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::wrapIfNecessary(operation:DocumentStoreElement[1]):OperationWithParentPropertyMapping[1]
{
   $operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                       a:DocumentStoreElement[1] | ^OperationWithParentPropertyMapping(element=$operation)
                     ])
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::getAllNodes(s:TreeNode[1]):TreeNode[*]
{
   $s->concatenate($s.childrenData->map(k|$k->getAllNodes()));
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::printNode(t:DocumentTreeNode[0..1]):String[1]
{
   if($t->isEmpty(),|'',|$t->match([a:RootJoinDocumentTreeNode[1]|'root',j:JoinDocumentTreeNode[1]| '('+$j.alias.name+')']));
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::printNodeWithChildren(t:DocumentTreeNode[0..1]):String[1]
{
   $t->printNode()+'['+if($t->isEmpty(),|'',|$t.children->map(c|$c->printNodeWithChildren())->makeString(','))+']';
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processProperty(property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], currentPropertyMapping:PropertyMapping[*], propertyMappingFromRouter:PropertyMapping[*], srcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
// Uses function from relational package: function meta::relational::mapping::findPropertyMapping
   let propertyMappings = findPropertyMapping($property, $propertyOwnerClass, $currentPropertyMapping, $propertyMappingFromRouter, $state.mapping->toOne(),$context);
   let res = processPropertyMapping($propertyMappings, $propertyOwnerClass, $srcOperation, $state, $context, $extensions);
   ^OperationWithParentPropertyMapping(element=$res, currentPropertyMapping=$propertyMappings);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, createDbConfig($dbType, [], false), ^Format(newLine='', indent=''), ^Config(), $extensions);
}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), ^Format(newLine='', indent=''), ^Config(), $extensions);
//}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], config:Config[1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), $config, $extensions);
//}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), ^Config(), $extensions);
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), $config, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1],  dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, $dbConfig, $format, $generationState, ^Config(), $extensions);
}

//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):String[1]
//{
//   $relationalOperationElement->processOperation($sgc.dbConfig, $sgc.format, $sgc.generationState, $sgc.config, $sgc.extensions);
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::collectionToString(collection:Collection[1], dbConfig : DbConfig[1]):String[1]
{
   let collectionName = $dbConfig.collectionNameToIdentifier($collection.name);
   $dbConfig.identifierProcessor($collectionName);
}

function  meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config:Config[1], extensions:Extension[*]):String[1]
{
   let sgc = ^SqlGenerationContext(dbConfig=$dbConfig, format=$format, generationState=$generationState, config=$config, extensions=$extensions);
   $documentStoreElement->match($extensions->map(e|$e.moduleExtension('documentStore')->cast(@DocumentStoreExtension).documentQueryToString_processOperation)->map(f | $f->eval($dbConfig, $format, $generationState, $config, $extensions))->concatenate(
                                       [
                                          //v:VarPlaceHolder[1]| '${'+$v.name+'}',
                                          //v:VarSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          //v:VarCrossSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          //w:WindowColumn[1]|$dbConfig.windowColumnProcessor($w, $sgc),
                                          //s:ViewSelectSQLQuery[1]|'('+$s.selectSQLQuery->processOperation($dbConfig, $format, $generationState, $config, $extensions)+')',
                                          c:Collection[1]|$c->collectionToString($dbConfig),
                                          //js:JoinStrings[1] | $dbConfig.joinStringsProcessor($js, ^$sgc(config=^Config())),
                                          alias:Alias[1]|
                                                let innerTerm = $alias.documentElement->match([
                                                   //r : VarSetPlaceHolder[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions),
                                                   s : SelectDocumentQuery[1]|$s->processSelectDocumentQuery($sgc, true),
                                                   r : DocumentStoreElement[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions)
                                                ]);

                                                let identifier = $dbConfig.identifierProcessor($alias.name);

                                                let sqlOp = $alias.documentElement->instanceOf(SelectDocumentQuery);

                                                '%s%s%s as %s'->format([
                                                      if ($sqlOp,|'(',|''),
                                                      $innerTerm,
                                                      if ($sqlOp,|')',|''),
                                                      $identifier
                                                      ]);
                                             ,
//                                          c:TableAliasColumn[1]|let doubleQuote = if($config.useQuotesForTableAliasColumn == false, |'', |'"');
//                                                                if(!$config.generateJoin->isEmpty() && $config.generateJoin->toOne(),|if ($config.generateJoinTarget == $c.alias,
//                                                                                                                                          |'{target}.',
//                                                                                                                                          |let schema = $c.alias.relationalElement->match([t:Table[1]|$t.schema.name, v:View[1]|$v.schema.name]);
//                                                                                                                                           if ($schema == 'default',|'',|$schema+'.');
//                                                                                                                                      )
//                                                                                                                                    ,|''
//                                                                ) + if ($config.generateJoinTarget == $c.alias, |'',|$dbConfig.identifierProcessor($doubleQuote+$c.alias.name->toOne()+$doubleQuote) + '.') + processColumnName($c.column.name->toOne(), $dbConfig);,
                                          l:Literal[1]| processLiteral($l, $dbConfig),
                                          ll:LiteralList[1] | $ll.values->map(e | $e->processOperation($dbConfig, $format, $generationState, $config, $extensions))->joinStrings('(', ', ', ')'),
                                          s:SelectDocumentQuery[1]|
                                          
                                                                  let fields = $s->cast(@SelectDocumentQuery).fields->map(x | ^Field(name=$x->cast(@Alias).documentElement->cast(@Field).name, type=$x->cast(@Alias).documentElement->cast(@Field).type)); 
                                                                  let y=^SelectDocumentQuery(data=$s.data, fields=$fields, filteringOperation=$s->cast(@SelectDocumentQuery).filteringOperation);
                                                                  $y->processSelectDocumentQuery($sgc, false);,
                                          
                                          //s:SelectDocumentQuery[1]| $s->processOperation($dbConfig, $format, $generationState, $config, $extensions),
//                                          u:UnionAll[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ALL ')+')',
//                                          u:Union[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ')+')',
//                                          f:FreeMarkerOperationHolder[1]|processFreeMarkerOperationHolder($f, $dbConfig, $format, $generationState, $config, false, $extensions),
//                                          d:DynaFunction[1]|processDynaFunction($d, $sgc),
                                          f:FieldName[1]|$dbConfig.identifierProcessor($f.name->toOne()),
//                                          s:SemiStructuredObjectNavigation[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
//                                          s:SemiStructuredArrayFlatten[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
//                                          s:SemiStructuredArrayFlattenOutput[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          {f:  meta::external::store::document::metamodel::Function[1]| assert(false, 'Don\'t know how to handle %s', $f->type()); 'TO DO'; }
                                       ])->toOneMany()
                                     );
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processPropertyMapping(propertyMapping:PropertyMapping[*], propertyOwnerClass:Class<Any>[1], srcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'*>Process Property: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') ' +'NODEID_NA'+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'   (Q)Source Operation>  '+$srcOperation->cast(@SelectDocumentQuery)->printDebugQuery($context.space, $extensions)));
   let res = $propertyMapping->match([
               //s:SemiStructuredRelationalPropertyMapping[*] | processSemiStructuredRelationalPropertyMapping($s, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               r:DocumentPropertyMapping[*] | processDocumentPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $context->shift(), $extensions),
               //r:CrossSetImplementationPropertyMapping[*] | processCrossPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               e:EmbeddedDocumentInstanceSetImplementation[*] | if(($state.inGetterFlow == true) && $e->size() == 1 && $e->toOne()->instanceOf(OtherwiseEmbeddedDocumentInstanceSetImplementation),
                                                                     | processDocumentPropertyMapping($e->toOne()->cast(@OtherwiseEmbeddedDocumentInstanceSetImplementation).otherwisePropertyMapping->cast(@DocumentPropertyMapping), $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $context->shift(), $extensions);,
                                                                     | $srcOperation;
                                                                  )
             ]);

   print(if(!$context.debug, |'',
            | $context.space+'<*Process Property Result: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') ' +'NODEID_NA'+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'            '+$res->cast(@SelectDocumentQuery)->printDebugQuery($context.space, $extensions)));

   $res;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::getPropertyName(documentElement:DocumentStoreElement[1],property:AbstractProperty<Any>[1], documentPropertyMappings:DocumentPropertyMapping[*], extensions:Extension[*]):String[1]
{
   $documentElement->match(
            [//u:Union[1]| '"'+ $relationalPropertyMappings.relationalOperationElement->buildUniqueName(false, $extensions)+'"',
             a:Any[1]|'"'+$property.name->toOne()+'"'] );
}


//  Renu : Core function to fix, completely gutted
function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentPropertyMapping(documentPropertyMappings:DocumentPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], oldSrcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let propertyReturnType = $property->cast(@Property<Nil,Any|*>).genericType.rawType->toOne();
   $propertyReturnType->match(
                                 [
                                    p:DataType[1] | //let currentTreeNode = $oldSrcOperation.currentDocumentTreeNode->toOne();
                                                    // ---------------------------------------------------
                                                    // Potentially add missing columns in the union!  // Duplicated Code??
                                                    let documentElement = $oldSrcOperation.data.alias.documentElement->toOne();
                                                    let propName = $documentElement->getPropertyName($property, $documentPropertyMappings, $extensions);

                                                    let result  = pair($propName, $oldSrcOperation);

                                                    let srcOperation = $result.second;
                                                    // ---------------------------------------------------

                                                    let mappingImpl = $documentPropertyMappings->at(0).documentStoreElement;

                                                    let relElement = $oldSrcOperation.data.alias.documentElement->toOne();

                                                    let res = if (
                                                                      $relElement->instanceOf(SelectDocumentQuery)
                                                                        &&
                                                                      ($mappingImpl->instanceOf(meta::external::store::document::metamodel::Operation) || $mappingImpl->instanceOf(meta::external::store::document::metamodel::Literal))
                                                                        &&
                                                                      $relElement->cast(@SelectDocumentQuery).fields->filter(c|$c->instanceOf(meta::external::store::document::metamodel::Alias))->cast(@meta::external::store::document::metamodel::Alias).name->contains($propName)
                                                                    
                                                                    ,
                                                                    |
                                                                      let newField = ^Field(name=$propName, type=^meta::external::store::document::metamodel::StringTypeReference(list=true));                                                                      
                                                                      if ($state.inFilter,
                                                                       |^$srcOperation(filteringOperation+=$newField),
                                                                       |^$srcOperation(fields+=$newField)
                                                                    );
                                                                    ,
                                                                    |
                                                                      $mappingImpl->processColumnsInDocumentStoreElements($state, $srcOperation, 'nodeId', $context, $extensions);
                                                                  );

                                                    let selectDocumentQuery = if($state.inFilter,
                                                                        | ^$res(filteringOperation = $res.filteringOperation->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions)),
                                                                        | ^$res(filteringOperation = [], fields = $res.fields->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions))
                                                                      );

                                                    $selectDocumentQuery;
                                                    
                                                    

                                                    //^$res(fields = $res.fields->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions));

                                                                  //function  meta::external::store::document::functions::pureToDocumentStoreQuery::processColumnsInDocumentStoreElements(z:DocumentStoreElement[1], state:State[1], srcOperation:SelectDocumentQuery[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1] 

//                                                    let res = if (
//                                                                  ($relElement->instanceOf(SelectDocumentQuery) &&
//                                                                  ($mappingImpl->instanceOf(meta::external::store::document::metamodel::Function) || $mappingImpl->instanceOf(Literal)) &&
//                                                                   $relElement->cast(@SelectDocumentQuery).fields->filter(c|$c->instanceOf(Alias))->cast(@Alias).name->contains($propName))
//                                                                  ,
//                                                                  | // We should not process the property mapping as it should have been done in the embedded selectSQLQuery....
//                                                                    let sel = $srcOperation;
//                                                                    //let embeddedSelect = $currentTreeNode.alias.relationalElement->cast(@SelectSQLQuery);
//                                                                    // Warning the type of the column is bogus here....
//                                                                    let newField = ^Field(name=$propName, type=^meta::relational::metamodel::datatype::Integer());
//                                                                    if ($state.inFilter,
//                                                                       |^$srcOperation(select = ^$sel(filteringOperation+=$newField)),
//                                                                       |^$srcOperation(select = ^$sel(fields+=$newField));
//                                                                  ,
//                                                                  | // Process the property mapping...
//                                                                    let srcOperationWithMilestoneProcessingState=$srcOperation->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.DATATYPE_PROPERTY);
//                                                                    $mappingImpl->processColumnsInRelationalOperationElements($state, $srcOperationWithMilestoneProcessingState, $nodeId, $aggFromMap, true, $context, $extensions);
//                                                               );
//                                                    let sel = $res;
//                                                    let firstStep = if ($state.inFilter,
//                                                                        |^$res(select = ^$sel(filteringOperation = $sel.filteringOperation->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions)));,
//                                                                        |^$res(select = ^$sel(filteringOperation = [], fields = $sel.fields->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions)));
//                                                                       );
//                                                    let secondStep = $mappingImpl->match([
//                                                                                         //r : RelationalOperationElementWithJoin[1] | $firstStep;,
//                                                                                         a : Any[*]                                | ^$firstStep(positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first()),
//                                                                                                                                                 currentTreeNode = $newCurrentTreeNode->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first());
//                                                                                        ]);
//                                                    let newSel = $secondStep.select;
//                                                    if ($srcOperation.select.filteringOperation->isEmpty() || $srcOperation.select.leftSideOfFilter->isEmpty(),
//                                                       |if (!$srcOperation.select.leftSideOfFilter->isEmpty(),
//                                                          |^$secondStep(select = ^$newSel(leftSideOfFilter=[])),
//                                                          |$secondStep
//                                                        ),
//                                                       |^$secondStep(select = ^$newSel(savedFilteringOperation = $newSel.savedFilteringOperation
//                                                                                                                ->concatenate(pair($sel.leftSideOfFilter->toOne(), $srcOperation.select.filteringOperation->toOne()))
//                                                                                                                ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
//                                                                             )
//                                                        )
//                                                    );
                                                      //$srcOperation;
                                                    ,
                                    c:Class<Any>[1] |let srcOperation = $oldSrcOperation;

                                                     //let isUnionSubType = $oldSrcOperation.currentTreeNode.alias.relationalElement->toOne()->instanceOf(Union) && $relationalPropertyMappings->size() == 1;
//                                                     let updatedDocumentPropertyMappings = $documentPropertyMappings);
//
//                                                      let res =
//                                                            let joinTree = $documentPropertyMappings->at(0).documentStoreElement.joinTreeNode->toOne();
//                                                            let targetAlias = $joinTree.join->findTarget($srcOperation.currentTreeNode->toOne(), $extensions);
//                                                            let extraColumns = $joinTree.join.operation->extractCollectionAlias()->filter(t|$t.alias != $targetAlias);
//                                                            let yy = manageIsolation($srcOperation, $extraColumns, $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions);
//                                                            let srcOperationWithMilestoneProcessingState=$yy->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY);
//                                                            doJoinToClass($relationalPropertyMappings->at(0), $c, $srcOperationWithMilestoneProcessingState, $joinType, $nodeId, $state, $context, $extensions);
                                                    $srcOperation;
                                  ]
                             );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::usePropertyName(element:DocumentStoreElement[1], property:AbstractProperty<Any>[1], documentPropertyMappings:DocumentPropertyMapping[*], extensions:Extension[*]):DocumentStoreElement[1]
{
  $element->match(   [
                        l:Literal[1]|$l,
                        ll:LiteralList[1]|$ll,
                        j:JoinStrings[1]|^$j(strings=$j.strings->map(s | $s->usePropertyName($property, $documentPropertyMappings, $extensions)));,
                        s:SelectDocumentQuery[1]|^$s(filteringOperation = $s.filteringOperation->map(f|$f->usePropertyName($property, $documentPropertyMappings, $extensions)));,
                        t:CollectionAlias[1]| $t,
                        //a:Alias[1]|^$a(relationalElement = $a.relationalElement->usePropertyName($property, $relationalPropertyMappings, $extensions));,
                        //d:DynaFunction[1]|newDynaFunction($d.name, $d.parameters->map(p | $p->usePropertyName($property, $relationalPropertyMappings, $extensions))),
                        //op:UnaryOperation[1]|^$op(nested=$op.nested->usePropertyName($property, $documentPropertyMappings, $extensions)),
                        op:BinaryOperation[1]|^$op(left=$op.left->usePropertyName($property, $documentPropertyMappings, $extensions), right=$op.right->usePropertyName($property, $documentPropertyMappings, $extensions)),
                        //op:VariableArityOperation[1]|^$op(args=$op.args->map(arg | $arg->usePropertyName($property, $relationalPropertyMappings, $extensions))),
                        fn:FieldName[1] |$fn,
                        f:Field[1]| $f
                    ]
                 )
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let setImplementation = $expression.parametersValues->at(0)->cast(@ExtendedRoutedValueSpecification).sets->toOne();
   processGetAll($expression, $setImplementation, $expression.parametersValues, $state, $vars, $context, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(expression: FunctionExpression[1], setImplementation:SetImplementation[1], parameters:ValueSpecification[*], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
  let nodeId = 'nodeId';
   let processRootSetImpl = {r:RootDocumentInstanceSetImplementation[1] |let milestoningContext = []; //getMilestoningContextForAll($expression,$r, $parameters, $state, $vars, $context, $extensions);  
                                                                          // removed $milestoningContext parameters
                                                                           processGetAll($r, $r.class, $nodeId, true, -1, !$state.inProject, $state, $context, $extensions);};

   $setImplementation->match([r:RootDocumentInstanceSetImplementation[1]| $processRootSetImpl->eval($r)
                              // r:meta::pure::router::clustering::CrossSetImplementation[1]| let newTable = ^VarCrossSetPlaceHolder(varName=$r.varName, name=$r.varName, schema=^Schema(name='default', database=^Database()), crossSetImplementation = $r);
                              //                                                              let treeNode = ^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = $newTable));
                              //                                                              ^SelectWithCursor(select = ^SelectSQLQuery(data = $treeNode), currentTreeNode = $treeNode);,
                              // o:OperationSetImplementation[1]|let setImpls = $o->resolveOperation($state.mapping)->cast(@RootDocumentInstanceSetImplementation);
                              //                                 if($setImpls->size()==1,| $processRootSetImpl->eval($setImpls->at(0))
                              //                                                        ,| let milestoningContext = []; //getMilestoningContextForAll($expression,$o, $parameters, $state, $vars, $context, $extensions);
                              //                                                           //let union = buildUnion($setImpls, [], false, $state.inProject, $milestoningContext, $nodeId, $state, $context, $extensions);
                              //                                                           let propMap = $setImpls->at(0)->cast(@DocumentInstanceSetImplementation)->dataTypePropertyMappings();
                              //                                                           let newRoot = ^RootJoinDocumentTreeNode(alias = ^CollectionAlias(name='unionBase', documentElement=$union));
                              //                                                           let fullCols = $union.queries->at(0).columns->cast(@Alias).name->filter(n | $n != 'u_type');
                              //                                                           ^SelectWithCursor( select = ^SelectSQLQuery( columns = ^Alias(name= 'u_type', relationalElement = ^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name='u_type', type=^meta::relational::metamodel::datatype::Integer())))
                              //                                                                                                                  ->concatenate($fullCols->map(p|^Alias(name=$p, relationalElement =^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name=$p, type=^meta::relational::metamodel::datatype::Integer()))))),
                              //                                                                                                        data = $newRoot,
                              //                                                                                                        filteringOperation = []
                              //                                                                                                      ),
                              //                                                                              currentTreeNode = $newRoot,
                              //                                                                              milestoningContext=$milestoningContext);
                              //                                                         );
                           ]);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(viewSpecification:DocumentMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1],  state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let newState = ^$state(inProject=false, inProjectFunctions=false, processingProjectionThread=false,  inFilter=false); //shouldIsolate=false,
   processDocumentMappingSpecification($viewSpecification, $c, $nodeId, $addPk, $pkOffset, $addAllColumns, $newState, $context, $extensions); //removed $milestoningContext,
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentMappingSpecification(viewSpecification:DocumentMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let mainCollection = $viewSpecification.mainDocumentRelation->processDocumentRelation($c, $nodeId, $addPk, $pkOffset, $addAllColumns, $state, $context, $extensions);  //removed $milestoningContext,

  //  let innerJoinFilterExists = $viewSpecification->getFilter().joinTreeNode.joinType == JoinType.INNER;  // Not supporting joins
  //  let currentRelationalElement = if ($innerJoinFilterExists,
  //                                     | getRelationalElementWithInnerJoin($viewSpecification, $mainCollection, $c, $nodeId, $state, $context, $extensions),
  //                                     | $mainCollection
  //                                 );
   let innerJoinFilterExists = false;
   let currentDocumentElement = $mainCollection;

   let currentNode = ^RootJoinDocumentTreeNode(alias=^CollectionAlias(name = $mainCollection->cast(@meta::external::store::document::metamodel::NamedDocumentRelation).name, documentElement = $currentDocumentElement));

  //  let base = ^SelectWithCursor(
  //     select = ^SelectSQLQuery(
  //                     data = $currentNode
  //                 ),
  //     currentTreeNode = $currentNode
  //  );

   let base = ^SelectDocumentQuery(data = $currentNode);

   let quoteColumnAliases = false; // shouldQuoteColumnAliases($viewSpecification);
   // let requiresAllProperties = ($addAllColumns || (!$viewSpecification->getGroupBy()->isEmpty()) || ($viewSpecification->getDistinct()->toOne()));
   let requiresAllProperties = true;

   let properties = if($requiresAllProperties, | columnNamesWithDocumentElement($viewSpecification, $c, $state)->map(c | let newQuery = $c.second->processColumnsInDocumentStoreElements($state, $base, $nodeId, $context, $extensions);
                                                                                                           rebuildSelectDocumentQuery($c.first, [], $newQuery, $quoteColumnAliases);)
                                             , | [] );

  //  let pks = if($addPk && $viewSpecification->getGroupBy()->isEmpty() && ($viewSpecification->getDistinct()->isEmpty() || $viewSpecification->getDistinct()->toOne() == false),
  //                 | let pks = viewSpecificationPrimaryKey($viewSpecification);
  //                   $pks->map(pm|let offset = $pks->indexOf($pm);
  //                                let newQuery = $pm->processColumnsInRelationalOperationElements($state, $base, $nodeId, ^List<ColumnGroup>(), false, $context, $extensions);
  //                                if($state.importDataFlow == true,
  //                                   |rebuildSelectWithCursor([], if($pkOffset == -1,
  //                                                                   |if($state.importDataFlowCurrentSetOffsetInUnion->isEmpty() || $state.importDataFlowImplementationCount == 1,
  //                                                                       |[],
  //                                                                       |$state.importDataFlowCurrentSetOffsetInUnion->toOne()->toString()
  //                                                                    ),
  //                                                                   |$pkOffset->toString()
  //                                                                ), $newQuery, $quoteColumnAliases),
  //                                   |rebuildSelectWithCursor('pk_'+$offset->toString(), if($pkOffset == -1,|[],|$pkOffset->toString()), $newQuery, $quoteColumnAliases)
  //                                );
  //                         );,
  //                 | $base
  //              );
  // Not supporting groupby
  // let pks = $base;

   //let groupByQuery = $base->applyGroupBy($viewSpecification, $nodeId);

   //let filterQuery = if ($innerJoinFilterExists, | $groupByQuery, | $groupByQuery->applyTypeFilter($viewSpecification, $nodeId, $state, $context, $extensions));

   // TODO: Ideally, should try to isolate pk & property queries in all cases. Restrict to graphFetch flow for now
   /*
   let pksAndProperties = if ($state.graphFetchFlow == true,
                              | $pks->concatenate($properties)->mergeDocumentQueryData($nodeId, ^$state(shouldIsolate=true), $context, $extensions),
                              | $pks->concatenate($properties)
                          );
                          */

   //let merged = $properties->mergeDocumentQueryData($nodeId, $state, $context, $extensions);
  //  let fks = if ($viewSpecification->getDistinct() == true && !$viewSpecification->instanceOf(View),
  //                    | collectAdditionalJoinColumnsForSource($viewSpecification, $state.mapping,  $merged.data->toOne(), $merged.columns->cast(@Alias)),
  //                    | if ($state.importDataFlowAddFks == true,
  //                          |$state.importDataFlowFksByTable->toOne()->get($mainTable).values->map(c|^Alias(name=$c.name, relationalElement=^TableAliasColumn(alias=$merged.data.alias->toOne(), columnName=$c.name, column=$c))),
  //                          |[]
  //                      )
  //                );
  // Not supporting distinct & import DataFlowAddFks yet
   //let fks = ^Alias(name = 'dummyAlias', documentElement=$currentDocumentElement);

   //let addedFks = if ($state.importDataFlowAddFks == true, |$fks->map(a|^$a(name='fk_'+$a.name)), |$fks);

   let s = ^SelectDocumentQuery(
                  distinct = false,
                  fields = $properties.fields,
                  data = $properties.data->at(0),
                  filteringOperation = $properties.filteringOperation
                  //savedFilteringOperation = $merged.savedFilteringOperation,
                  //extraFilteringOperation = $merged.extraFilteringOperation,
                  //groupBy = $merged.groupBy
               );
   // No milestoning
   //if(!$milestoningContext->isEmpty() ,|applyMilestoningTypeFilters($s, $milestoningContext->toOne(), $state, $innerJoinFilterExists, $extensions),|$s);
   $s;

}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentRelation(r: DocumentStoreElement[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1] //milestoningContext: TemporalMilestoningContext[0..1], 
{
   $r->match([
               s:SelectDocumentQuery[1] | $s,
               t:Collection[1] | $t
               //u:Union[1] | $u,
               //v:View[1]  | let selectWithCursor = processRelationalMappingSpecification($v, $c, $nodeId, $addPk, $pkOffset, true, $milestoningContext, ^$state(inFilter=false), $context, $extensions);
               //             let select = $selectWithCursor.select;
               //             let selectWithFiltersProcessed = ^$select(filteringOperation=$select.filteringOperation->concatenate($select.extraFilteringOperation))->pushSavedFilteringOperation($extensions);
               //             ^ViewSelectSQLQuery(view=$v, name=$v.name, columns = $selectWithFiltersProcessed.columns, selectSQLQuery = $selectWithFiltersProcessed, schema=$v.mainTable.schema);,
               //s:SemiStructuredArrayFlatten[1] | $s
             ]);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::documentmappingspecification::columnNamesWithDocumentElement(vs: DocumentMappingSpecification[1], c:Class<Any>[0..1], state: State[1]):Pair<String, DocumentStoreElement>[*]
{
   $vs->match([
               r:RootDocumentInstanceSetImplementation[1] | $r->dataTypePropertyMappings()
                                                              ->filter(x | if($state.graphFetchFlow == true, | $x.property->in($state.graphFetchProperties), | true))
                                                              ->map(pm|pair($pm.property.name->toOne(),$pm->cast(@DocumentPropertyMapping).documentStoreElement))
               // v:View[1] | $v.columnMappings->map(cm|pair($cm.columnName, $cm.relationalOperationElement));
              ]);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processColumnsInDocumentStoreElements(z:DocumentStoreElement[1], state:State[1], srcOperation:SelectDocumentQuery[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]  // removed aggFromMap:List<ColumnGroup>[1], cancelJoinOnUnion:Boolean[1], 
{
   $srcOperation->validate([], $extensions);
   let result = $z->match(
               [
                  f:Field[1] |
                              let currentTreeNode = $srcOperation.data->toOne();

                              let alias = $currentTreeNode.alias;
                              let documentElement = $alias.documentElement;

                              // Make sure the column is available a potentially SQL
                              let newSrcOperation = $documentElement->match([
                                //  s:SelectSQLQuery[1] | if ($s.columns->map(c|$c->match([t:TableAliasColumn[1]|$t.column.name,
                                //                                                        a:Alias[1]|$a.relationalElement->match([t:TableAliasColumn[1]|$t.column.name, d:DynaFunction[1]|$d.name, l:Literal[1]|$a.name])
                                //                                                       ])
                                //                                       )->contains($t.column.name),
                                //                          | $srcOperation;,
                                //                          |// Add the missing columns in the nested select (coming most likely from isolation)
                                //                           // 1. find the right alias within the nested SQL ...
                                //                           // the alias we are trying to find might be from a view
                                //                           let allNodes = $s.data->toOne()->getAllNodes()->cast(@RelationalTreeNode);
                                //                           let aliasesToUse = $t.column->extractColumnAliasesInRelationalTreeNodes($t.alias.relationalElement, $allNodes, $context, $extensions);  
                                //                           assert($aliasesToUse->size() == 1, | 'Found too many (or not enough) tables that could support the column '+$t.column.name+' in the nested SQL '+$s->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions));
                                //                           let newSQL = ^$s(columns+=^Alias(name=$t.column.name, relationalElement=$aliasesToUse->toOne()));
                                //                           let newTreeNode = ^$currentTreeNode(alias = ^$alias(relationalElement = $newSQL));
                                //                           let newData = if ($currentTreeNode->instanceOf(RootJoinTreeNode),
                                //                                                |$newTreeNode,
                                //                                                |$srcOperation.select.data->toOne()->replaceJoin($currentTreeNode->toOne()->cast(@JoinTreeNode), $newTreeNode->cast(@JoinTreeNode))
                                //                                         );
                                //                           let oldToNew = $srcOperation.select.data->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias->zip($newData->getAllNodes()->cast(@RelationalTreeNode).alias)->map(o|^OldAliasToNewAlias(first=$o.first.name, second=$o.second));
                                //                           let opSelect = $srcOperation.select;

                                //                           ^$srcOperation(
                                //                                 select = ^$opSelect(
                                //                                                data = $newData->cast(@RootJoinTreeNode),
                                //                                                leftSideOfFilter = if($opSelect.leftSideOfFilter->isEmpty(),|[],|$opSelect.leftSideOfFilter->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                //                                                savedFilteringOperation = $opSelect.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newData), $p.second->reprocessAliases($oldToNew)))
                                //                                          ),
                                //                                 positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                //                                 currentTreeNode = $newTreeNode
                                //                           );
                                //                       );
                                 s:SelectDocumentQuery[1] | $srcOperation;,
                                 a:Any[1]| $srcOperation;
                              ]);

                              let newOpSelect = $newSrcOperation; //.select;
                              let field = ^Field(name=$f.name, type=$f.type, owner=$f.owner);
                              if ($state.inFilter,| ^$newOpSelect(filteringOperation = $field),|^$newOpSelect(fields = $field, filteringOperation = $field));
                              ,
                  d:DynaFunction[1]| let newSelect = if ($d.parameters->isEmpty(),
                                                      | let select = $srcOperation;
                                                         $state.inFilter->if(|^$select(filteringOperation = $d),|^$select(fields = $d));
                                                         ,
                                                      |  let sqlThreads = $d.parameters->map(p|$p->processColumnsInDocumentStoreElements($state, $srcOperation, buildNodeId($nodeId,'_dy'+$d.parameters->indexOf($p)->toString()), $context, $extensions));
                                                         let merged = $sqlThreads->mergeDocumentQueryData($nodeId, $state, $context, $extensions);
                                                         let pFunc = ^$d(parameters = $state.inFilter->if(|$merged.filteringOperation,|$merged.fields));
                                                         $state.inFilter->if(|^$merged(filteringOperation=$pFunc),|^$merged(fields=$pFunc));
                                                    );
                                     $newSelect;
                                     ,
                  l:Literal[1]| let select = $srcOperation;
                                $state.inFilter->if(|^$select(filteringOperation = $l),|^$select(fields = $l));
                                                      
                  // r:RelationalOperationElementWithJoin[1]|
                  //             let col = $r->extractElement();
                  //             let currentData = $srcOperation.select.data->toOne();
                  //             let isDynaFunction = $col->instanceOf(DynaFunction);
                  //             let joinTreeNode = $r.joinTreeNode->toOne();
                  //             let opWithCol = if ($isDynaFunction,
                  //                |
                  //                   let dynaFunction = $col->cast(@DynaFunction);
                  //                   let extraColumns=$col->extractTableAliasColumns();
                  //                   let op = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                  //                   let opWithCol = $dynaFunction->processColumnsInRelationalOperationElements($state, $op, $nodeId, $aggFromMap, $cancelJoinOnUnion, $context, $extensions);
                  //                   let pCol = $state.inFilter->if(|$opWithCol.select.filteringOperation,|$opWithCol.select.columns)->toOne();
                  //                   pair($opWithCol,$pCol->cast(@RelationalOperationElement));
                  //                ,|
                  //                   let op = if($joinTreeNode == [] || ($cancelJoinOnUnion && $srcOperation.currentTreeNode.alias.relationalElement->toOne()->instanceOf(Union)),
                  //                               | $srcOperation,
                  //                               | let extraColumns=$col->filter(p|$p->instanceOf(TableAliasColumn))->cast(@TableAliasColumn);
                  //                                 let newOp = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                  //                                 let savedFilteringOperation = $srcOperation.select.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newOp.select.data->toOne()), $p.second));
                  //                                 let newOpSelect = $newOp.select;
                  //                                 let newOpSelectUpdated = ^$newOpSelect(savedFilteringOperation+=$savedFilteringOperation);
                  //                                 ^$newOp(select=$newOpSelectUpdated);
                  //                               );
                  //                   let pCol = $col->reprocessAliases(^OldAliasToNewAlias(first=$col->cast(@TableAliasColumn).alias.relationalElement->cast(@NamedRelation).name, second=$op.alias->toOne()));
                  //                   pair($op,$pCol->cast(@RelationalOperationElement));
                  //                 );

                  //            let op = $opWithCol.first;
                  //            let opSelect = $op.select;
                  //            let pCol = $opWithCol.second;

                  //            ^$op(
                  //                select = $state.inFilter->if(|^$opSelect(filteringOperation = $pCol),|^$opSelect(columns = $pCol))
                  //            );,
                  // s:SemiStructuredPropertyAccess[1] | let select = $srcOperation.select;
                  //                                     let processedOperand = $state.inFilter->if(|$select.filteringOperation,|$select.columns)->toOne();
                  //                                     let updatedPropertyAccess = ^$s(operand = $processedOperand);
                  //                                     ^$srcOperation(select = $state.inFilter->if(|^$select(filteringOperation = $updatedPropertyAccess),|^$select(columns = $updatedPropertyAccess)));
               ]
            );
   $result->validate([], $extensions);
   $result;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::rebuildSelectDocumentQuery(name:String[0..1], suffix:String[0..1], newQuery: SelectDocumentQuery[1], quotes:Boolean[1]):SelectDocumentQuery[1]
{
   let newName = if($name->isEmpty(),
                    |$newQuery.fields->toOne()->cast(@Field).name,
                    |$name->toOne()
                 )+
                 if($suffix->isEmpty(),
                    |'',
                    |'_'+$suffix->toOne()
                 );
   ^SelectDocumentQuery(
                     fields = ^Alias(name = if($quotes,
                                                |'"'+$newName+'"',
                                                |$newName
                                             ),
                                      documentElement = $newQuery.fields->toOne()
                               ),
                     data = $newQuery.data,
                     filteringOperation = []
                     //extraFilteringOperation=$newQuery.select.extraFilteringOperation
               );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::applyGroupBy(base:SelectDocumentQuery[1], viewSpecification:DocumentMappingSpecification[1], nodeId:String[1]):SelectDocumentQuery[1]
{
  // let groupByMapping = $viewSpecification->getGroupBy();
  //  if ($groupByMapping->isEmpty(), | $base,
  //                                  | let baseSelect = $base.select;
  //                                    let lastNode = $base.currentTreeNode->toOne()->findLastJoinTreeNode();
  //                                    let columns = $groupByMapping.columns->map(c | $c->reprocessAliases(^OldAliasToNewAlias(first=$c->cast(@TableAliasColumn).alias.name, second=$lastNode.alias->toOne())));
  //                                    ^$base(select=^$baseSelect(groupBy=$columns)););
  $base;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::applyTypeFilter(base:SelectDocumentQuery[1], viewSpecification:DocumentMappingSpecification[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
  // let filterMapping = $viewSpecification->getFilter();
  // if ($filterMapping->isEmpty(),
  //       | $base,
  //       | let baseFilterQuery =
  //             if ($filterMapping->toOne().joinTreeNode->isEmpty(),
  //                 | $base;
  //                ,| applyJoinInTree($base.select.data->toOne(), $base.currentTreeNode->toOne(), $filterMapping->toOne().joinTreeNode->toOne(), $base, $nodeId, JoinType.LEFT_OUTER, true, false, [], $state, $context, $extensions);
  //              );
  //         let select = $baseFilterQuery.select;

  //         let lastNode = $baseFilterQuery.currentTreeNode->toOne()->findLastJoinTreeNode();
  //         ^$baseFilterQuery(
  //                  select = ^$select(
  //                               savedFilteringOperation += pair($lastNode, $filterMapping.filter.operation->toOne()->reprocessAliases(^OldAliasToNewAlias(first=$lastNode.alias.relation->cast(@Table).name, second=$lastNode.alias->toOne())))
  //                           )
  //                  );
  //    );
  // Not supporting basefilter query, will need it for consistency
     $base;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::mergeDocumentQueryData(preQuerySet:SelectDocumentQuery[*], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
    let hasIsolations = false; // $preQuerySet->map(p|$p.data->getAllNodeNames()->filter(n|$n->startsWith('__iso'))->makeString('|'))->removeDuplicates()->size() > 1;

    let res = $preQuerySet->tail()->fold(
      {
         q,a |
               if ($q != [] && !$q.data->isEmpty()
                   ,|
                      let new_a = $a;//if ($shouldIsolate,|$a->possiblyIsolateSubJoins($nodeId),|$a);
                      //let new_q = $q_moved;//if ($a->isIsolated() || $shouldIsolate,|$q->possiblyIsolateSubJoins($nodeId),|$q);
                      let new_q = $q;

                      let id = buildNodeId($nodeId, '_m' + $preQuerySet->indexOf($q)->toString());

                      let merged = merge(
                                           ^MergeResultContainer(
                                              node = $new_a.data->toOne(),
                                              fields = $new_q.fields,
                                              filteringOperation = $new_q.filteringOperation//,
                                            ),
                                            $new_q.data->toOne(),
                                            $id,
                                            $state,
                                            $context,
                                            $extensions
                                        );

                      ^$new_a
                         (
                            fields = $new_a.fields,
                            data = $merged.node->cast(@RootJoinDocumentTreeNode),
                            filteringOperation = $new_a.filteringOperation->concatenate($merged.filteringOperation)
                         );
                   ,|
                        ^$a
                         (
                            fields = $a.fields->concatenate($q.fields),
                            filteringOperation += $q.filteringOperation
                         );
               );
        }, $preQuerySet->first()->toOne()
    );

   print(if(!$context.debug, |'', |$context.space+'   Merge Result: '+$res->printDebugQuery($context.space, $extensions))
        );

   $res;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::merge(parentTargetTreeNode:MergeResultContainer[1], sourceTreeNode:DocumentTreeNode[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):MergeResultContainer[1]
{
   
        let newNode = $parentTargetTreeNode.node;
       ^$parentTargetTreeNode
        (
           node = $newNode,
           fields = $parentTargetTreeNode.fields,
           filteringOperation = $parentTargetTreeNode.filteringOperation
        );
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::buildNodeId(startNode:String[1], preToAdd:String[1]):String[1]
{
   let toAdd = if($preToAdd == '_i0',|'_d',|$preToAdd);
   let res = if ($startNode == '',
      |$toAdd,
      |let lastIndexParsed = $startNode->lastIndexOf('#');
       let existingNumber = if($lastIndexParsed == -1,
                                 | // No #
                                   pair(1, $startNode->length());,
                                 | let number = $startNode->substring($lastIndexParsed+1,$startNode->length());
                                   if ($number->indexOf('_') == -1,
                                      |// Extract the value from the #
                                       pair($number->parseInteger(), $lastIndexParsed),
                                      |// We have a # but it's not terminal
                                       pair(1, $startNode->length())
                                   );
                            );
       let lastIndex = $existingNumber.second;
       let lastUnder = $startNode->lastIndexOf('_');
       let lastPattern = $startNode->substring($lastUnder, $lastIndex);
       if ($toAdd == $lastPattern,
          |let number = $existingNumber.first+1;
           $startNode->substring(0, $lastIndex)+'#'+$number->toString();,
          |$startNode+$toAdd;
       );
   );
   $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processMap(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let res = processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context, $extensions);

   // do we need manangeIsolation?
   //let mainQuery = $res.element->toOne()->cast(@SelectWithCursor)->manageIsolation([], $nodeId, false, $state, $context, $extensions);//$res.element->toOne()->cast(@SelectWithCursor);


   let mainQuery = $res.element->toOne()->cast(@SelectDocumentQuery);
   let mainQueryWithFields = ^$mainQuery(fields=[]);

   let newCurrentPropertyMapping = if ($res.currentPropertyMapping->isEmpty(), | [], | $res.currentPropertyMapping);

   let func = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->match([
                  e:ExtendedRoutedValueSpecification[1]|$e.value->reactivate();,
                  a:Any[*]|$a
                ]);

/*
   let newQuery = if($func->cast(@meta::pure::metamodel::function::Function<Any>)->toOne()->containsAggregationFunctionInFunction($state.supportedFunctions),
                     |addPkForAggregation($f, $newCurrentPropertyMapping, $mainQueryWithColumns, $state, $nodeId, $context, $extensions),
                     |$mainQueryWithColumns
                  );
                  */
   let newQuery = $mainQueryWithFields;

/*
   let milestoningContext=$newQuery.milestoningContext->concatenate($operation.milestoningContext)->first();

   let isSemiStructuredPropertyMapping = ($newCurrentPropertyMapping->size() >= 1) && $newCurrentPropertyMapping->forAll(pm | $pm->instanceOf(SemiStructuredRelationalPropertyMapping));
   let extraColumn = if($isSemiStructuredPropertyMapping && ($select.columns->size() == 1),
                        | $select.columns->toOne()->reprocessAliases(^OldAliasToNewAlias(first = $mainQuery.currentTreeNode.alias.name->toOne(), second = $newQuery.currentTreeNode.alias->toOne())),
                        | []);
*/
   $func->match(
                [
                  p:Property<Nil,Any|*>[1]|processProperty($p, $f.parametersValues->at(0)->byPassRouterInfo()->cast(@ValueSpecification).genericType.rawType->toOne()->cast(@Class<Any>), $newCurrentPropertyMapping, $state.propertyMappingFromRouter, ^$newQuery(fields=[]), $state, $context->shift(), $extensions),
                  // not sure if we need QualifiedProperty
                  //q:QualifiedProperty<Any>[1]|processQualifiedProperty($q, $newCurrentPropertyMapping, ^$newQuery(fields=[]), $vars, ^$state(qualifierBase=$res->toOne()), $context->shift(), $extensions)->toOne(),
                  f:FunctionDefinition<Any>[1]| let sourceOp = ^$newQuery(fields=[]);
                                                let stateUpdatedWithInputQuery = $state->updateFunctionParamScope($f.classifierGenericType.typeArguments.rawType->toOne()->cast(@FunctionType),$sourceOp);
                                                let inScopeVarsWithPlaceholdersState = $f->addPlaceHoldersForLambdaOpenVariables($vars, $stateUpdatedWithInputQuery);
                                                processValueSpecificationReturnPropertyMapping($f.expressionSequence->at(0), $newCurrentPropertyMapping, $sourceOp, $vars, $inScopeVarsWithPlaceholdersState, $context->shift(), $extensions)->toOne();
                  // processPath seems to use joinType
                  /*
                  pa:Path<Nil,Any|*>[1] | let res = processPath($pa, 'map', '_map', $newQuery, $vars, $state, $nodeId, $aggFromMap, $context->shift(), $extensions);
                                          if($state.inFilter || $res.element->cast(@SelectDocumentQuery).fields->isEmpty(), | $res, | let selectDocumentQuery = $res.element->cast(@SelectDocumentQuery);
                                                                   let select = $selectDocumentQuery;
                                                                   let newField = $select.fields->toOne()->cast(@Alias).documentStoreElement;
                                                                   ^$res(element=^$selectDocumentQuery(columns=$newColumn));
                                                                   );
                  */
                ]);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::instanceValueAtParameter(expression : FunctionExpression[1], index : Integer[1]) : Any[1]
{
    instanceValuesAtParameter($expression,$index,[],[])->at(0);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::defaultState(mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1]):State[1]
{
   //filterChainDepth=0,
   ^State(inScopeVars=$inScopeVars, supportedFunctions=getSupportedFunctions(), mapping=$mapping, inProject=false, inProjectFunctions=false, inFilter=false, processingProjectionThread=false, shouldIsolate=true);   //contextBasedSupportedFunctions=getContextBasedSupportedFunctions());
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::toSelectDocumentQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], execCtx: DocumentStoreExecutionContext[0..1], debug:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   toSelectDocumentQuery($functionExpression, $mapping, $inScopeVars, $debug, $execCtx->documentStoreExecutionContextToState(defaultState($mapping, $inScopeVars)), $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::toSelectDocumentQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], state:State[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let sel = $functionExpression
      ->processQuery($state, $debug, $extensions);
      //->applyPostProcessingForTempTableAsDriver($state, $debug, $extensions)
      //->manageDeepMapClassColumns($functionExpression, $debug, $state, $extensions);

    $sel;
  //$sel->pushSavedFilteringOperation($extensions); //->pushExtraFilteringOperation($extensions); //->orderImmediateChildNodeByJoinAliasDependencies();

}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::processQuery(functionExpression:FunctionExpression[1], state:State[1], debug:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   processValueSpecification( $functionExpression,
                              [],
                              ^SelectDocumentQuery(),
                              newMap([]->cast(@Pair<VariableExpression, ValueSpecification>), VariableExpression->classPropertyByName('name')->cast(@Property<VariableExpression,String|1>)),
                              $state,
                              $debug,
                              $extensions
                            )->cast(@SelectDocumentQuery)->toOne();
}


function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::documentStoreExecutionContextToState(execCtx:DocumentStoreExecutionContext[0..1], s:State[1]):State[1]
{
   if ($execCtx->isEmpty(),
       |$s,
       |^$s
        (
           //preserveJoinOrder = $execCtx.preserveJoinOrder,
           //addDriverTablePkForProject = $execCtx.addDriverTablePkForProject,
           //insertDriverTablePkInTempTable = $execCtx.insertDriverTablePkInTempTable,
           //useTempTableAsDriver = $execCtx.useTempTableAsDriver,
           //importDataFlow = $execCtx.importDataFlow,
           importDataFlowAddFks = $execCtx.importDataFlowAddFks
           //importDataFlowFksByTable = $execCtx.importDataFlowFksByTable,
           //importDataFlowImplementationCount = $execCtx.importDataFlowImplementationCount
        )
   )
}

/*
function meta::external::store::document::functions::pureToDocumentStoreQuery::pushSavedFilteringOperation(s:SelectDocumentQuery[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   if ($s.savedFilteringOperation->isEmpty(),
         |$s,
         |^$s(
               //savedFilteringOperation = [],
               filteringOperation = $s.filteringOperation->concatenate($s.savedFilteringOperation.second)->andFilters($extensions)
          )
   );
}
*/

//function meta::external::store::document::functions::pureToDocumentStoreQuery::pushExtraFilteringOperation(s:SelectDocumentQuery[1], extensions:Extension[*]):SelectDocumentQuery[1]
//{
//   if ($s.extraFilteringOperation->isEmpty(),
//         |$s,
//         |^$s(
//               extraFilteringOperation = [],
//               filteringOperation=$s.filteringOperation->concatenate($s.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second)->andFilters($extensions)
//          )
//   );
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::combineFilters(s:DocumentStoreElement[*], and:Boolean[1], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   let ns = $s->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
   if ($ns->isEmpty(),
         |[],
         |if ($ns->size() == 1,
            | $ns->toOne(),
            | let dynaName = if($and,| 'and',| 'or');
              newAndOrDynaFunctionRelaxedBrackets($dynaName, $ns->reverse());
         )
   );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::andFilters(s:DocumentStoreElement[*], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   $s->combineFilters(true, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::orFilters(s:DocumentStoreElement[*], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   $s->combineFilters(false, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::newAndOrDynaFunctionRelaxedBrackets(funcName: String[1], params: DocumentStoreElement[*]): DynaFunction[1]
{
   let potentiallyWrapedParams = $params->map(p | $p->match([ d: DynaFunction[1] | if($d.name->in(['and','or']) && $d.name != $funcName, | ^DynaFunction(name='group', parameters=$d), | $d),
                                                              r: DocumentStoreElement[1] | $r
                                                            ])
                                              );
   ^DynaFunction(name = $funcName, parameters = $potentiallyWrapedParams);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::buildUniqueName(elements:DocumentStoreElement[*], alias:Boolean[1], extensions:Extension[*]):String[1]
{
   $elements->buildUniqueName($alias, true, $extensions)
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::buildUniqueName(elements:DocumentStoreElement[*], alias:Boolean[1], selectFields:Boolean[1], extensions:Extension[*]):String[1]
{
   let uniqueName = $elements->map(e | $e->match($extensions->map(e|$e.moduleExtension('documentStore')->cast(@DocumentStoreExtension).pureToDocumentQuery_buildUniqueName)->map(f | $f->eval($alias, $selectFields, $extensions))->concatenate(
      [
         n:RootJoinDocumentTreeNode[1]|$n->getAllNodes()->map(a|$a->match([j:RootJoinDocumentTreeNode[1]|if($alias,|$j.alias.name,|$j.alias.documentElement->buildUniqueName($alias, $selectFields, $extensions))]))->makeString('_'),  //,j:JoinDocumentTreeNode[1]|$j.joinName
         s:SelectDocumentQuery[1]|'s('+if($selectFields,|$s.fields->buildUniqueName($alias, $selectFields, $extensions)+',',|'')+$s.data->buildUniqueName($alias, $selectFields, $extensions)+','+$s.filteringOperation->buildUniqueName($alias, $selectFields, $extensions)+')',
         //u:UnaryOperation[1]| $u->type()->toOne().name->toOne() + $u.nested->buildUniqueName($alias, $selectFields, $extensions),
         i:BinaryOperation[1]|$i->type()->toOne().name->toOne() + '_' + $i.left->buildUniqueName($alias, $selectFields, $extensions) + '_' + $i.right->buildUniqueName($alias, $selectFields, $extensions),
         a:Alias[1]|if($alias,|$a.name,|$a.documentElement->buildUniqueName($alias, $selectFields, $extensions)),
         //c:ColumnName[1]|$c.name,
         n:NamedDocumentRelation[1]|$n.name,
         //u:Union[1]|$u.queries->map(q|$q->buildUniqueName($alias, $selectColumns, $extensions))->joinStrings(),
         //c:TableAliasColumn[1]|$c.alias->buildUniqueName($alias, $selectColumns, $extensions)+$c.column.name;,
         l:Literal[1]| $l.value->toString(),    //if($l.value->instanceOf(VarPlaceHolder),|$l.value->cast(@VarPlaceHolder).name,|$l.value->toString()),
         l:LiteralList[1]|  $l.values->map(l|$l->buildUniqueName($alias, $selectFields, $extensions))->joinStrings(),
         //v:VariableArityOperation[1]|$v->type()->toOne().name->toOne() + '_' + $v.args->buildUniqueName($alias, $selectColumns, $extensions),
         d:DynaFunction[1]| $d.name +'_'+$d.parameters->buildUniqueName($alias, $selectFields, $extensions)
         //f:FreeMarkerOperationHolder[1]| $f.name +'_'+$f.parameters->buildUniqueName($alias, $selectColumns, $extensions),
         //wc:WindowColumn[1]| $wc.columnName+'_'+ $wc.func->buildUniqueName($alias,$selectColumns, $extensions),
         //j:JoinStrings[1]|'join_'+$j.strings->buildUniqueName($alias, $selectColumns, $extensions)+$j.prefix->buildUniqueName($alias, $selectColumns, $extensions)+$j.separator->buildUniqueName($alias, $selectColumns, $extensions)+$j.suffix->buildUniqueName($alias, $selectColumns, $extensions),
         //rj:RelationalOperationElementWithJoin[1]| $rj.joinTreeNode->toOne().joinName+ $rj.relationalOperationElement->buildUniqueName($alias, $selectColumns, $extensions),
         //ssp:SemiStructuredPropertyAccess[1]|'ssp('+$ssp.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssp.property->buildUniqueName($alias, $selectColumns, $extensions)+']'+if($ssp.index->isEmpty(),|'',|'['+$ssp.index->toOne()->buildUniqueName($alias, $selectColumns, $extensions)+']')+')',
         //ssa:SemiStructuredArrayElementAccess[1]|'ssa('+$ssa.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssa.index->buildUniqueName($alias, $selectColumns, $extensions)+'])',
         //ssf:SemiStructuredArrayFlatten[1]|'ss_flatten('+$ssf.navigation->buildUniqueName($alias, $selectColumns, $extensions)+')',
         //ssf:SemiStructuredArrayFlattenOutput[1]|'ss_flatten_output('+$ssf.tableAliasColumn->buildUniqueName($alias, $selectColumns, $extensions)+')',
         //v:VarPlaceHolder[1]| $v.name
      ])->toOneMany()
   ))->joinStrings('_');

   let maxSize = 535;
   if($uniqueName->length() > $maxSize, |$uniqueName->substring(0, $maxSize - 35) + '___' + $uniqueName->substring($maxSize - 35)->meta::pure::functions::hash::hash(meta::pure::functions::hash::HashType.MD5), |$uniqueName);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::addPlaceHoldersForLambdaOpenVariables(fn:FunctionDefinition<Any>[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1]):State[1]
{
   let inScopeVars = $state.inScopeVars;
   $fn->match([
                  l:LambdaFunction<Any>[1] | let placeHolders = $l.openVariables->map(v |if($inScopeVars->get($v)->isEmpty(),
                                                                                             |pair($v, ^List<Any>(values=[^VarPlaceHolder(name=$v,type = $l->functionReturnType().rawType->toOne())]));,
                                                                                             | []
                                                                                         )
                                                                                     );
                                             ^$state(inScopeVars=$inScopeVars->putAll($placeHolders));,
                  o:FunctionDefinition<Any>[1] | $state;
   ]);
}
function meta::external::store::document::functions::pureToDocumentStoreQuery::processFilter(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{  
  let leftSidePure = $expression.parametersValues->at(0);
  let leftSideOp = processValueSpecificationReturnPropertyMapping($leftSidePure, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne();
  let leftSide = $leftSideOp.element->cast(@SelectDocumentQuery);

  let rootData = $leftSide.data->toOne();
  let tree = $rootData;

  let rootSelect = ^SelectDocumentQuery(
    filteringOperation = if(isGetAll($leftSidePure),
                                                          |$leftSide.filteringOperation,
                                                          |$state.inFilter->if( | $leftSide.filteringOperation,
                                                                                | let byPassedLeft = $leftSidePure->byPassRouterInfo();
                                                                                  let isDataTypeInput = $byPassedLeft.genericType.rawType->isNotEmpty() && $byPassedLeft.genericType.rawType->toOne()->instanceOf(DataType);
                                                                                  let isSemiStructuredPropertyMapping = ($leftSideOp.currentPropertyMapping->size() >= 1) && $leftSideOp.currentPropertyMapping->forAll(pm | $pm->instanceOf(meta::external::store::document::mapping::SemiStructuredDocumentPropertyMapping));
                                                                                  if ($isDataTypeInput || $isSemiStructuredPropertyMapping, | $leftSide.fields, | []);)),
    data=$tree
  );

  let filterFunction = $expression->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->at(0)->cast(@FunctionDefinition<Any>);
  let filterFunctionExpression = $filterFunction.expressionSequence->at(0);

  let inScopeVarsWithPlaceholdersState = $filterFunction->addPlaceHoldersForLambdaOpenVariables($vars, $state);

  let rightSide = processValueSpecification($filterFunctionExpression, $currentPropertyMapping, $rootSelect, $vars, ^$inScopeVarsWithPlaceholdersState(inFilter=true), $context, $extensions)->toOne()->cast(@SelectDocumentQuery);

  let merged = [$leftSide, $rightSide]->cast(@SelectDocumentQuery)->mergeDocumentQueryData('', $state, $context, $extensions);

  let mergedWithCollapsedFilteringOperation = ^$merged(filteringOperation = $merged.filteringOperation->tail()->fold({f,a|[$a->toOne(),$f]->andFilters($extensions)}, $merged.filteringOperation->head()));

  $mergedWithCollapsedFilteringOperation;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processEquals(
                 expression : FunctionExpression[1],
                 currentPropertyMapping:PropertyMapping[*],
                 operation : SelectDocumentQuery[1],
                 vars : Map<VariableExpression, ValueSpecification>[1],
                 state:State[1],
                 context : DebugContext[1],
                 extensions:Extension[*]
         ) : DocumentStoreElement[1]
{
   let leftParam = $expression.parametersValues->at(0);
   let rightParam = $expression.parametersValues->at(1);

   assert($leftParam.multiplicity->hasUpperBound() && ($leftParam.multiplicity->getUpperBound() <= 1)
          ,|'Left multiplicity error. Please use \'exists\' instead of \'==\' in the expression: '+$leftParam->asString()+' == '+$rightParam->asString());

   assert($rightParam.multiplicity->hasUpperBound() && ($rightParam.multiplicity->getUpperBound() <= 1)
          ,|'Right multiplicity error. Please use \'exists\' instead of \'==\' in the expression: '+$leftParam->asString()+' == '+$rightParam->asString());

   validateParamHasDataTypeReturnType($leftParam);
   validateParamHasDataTypeReturnType($rightParam);

   let left = processValueSpecificationReturnPropertyMapping($leftParam, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne();
   let right = processValueSpecificationReturnPropertyMapping($rightParam, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne();

   let mergedNoSQL = mergeDocumentQueryData([$left.element, $right.element]->map(x | $x->extractDocumentQuery()), '', $state, $context, $extensions);
   
   let leftVal = $state.inFilter->if(|$mergedNoSQL.filteringOperation->at(0),|$mergedNoSQL.fields->at(0));
   let rightVal = $state.inFilter->if(|$mergedNoSQL.filteringOperation->at(1),|$mergedNoSQL.fields->at(1));

   let filteringOperation = if($leftVal->hasReferenceToEnum() || $rightVal->hasReferenceToEnum(),
                                      |let firstVal  = ^EnumProcessingHolder(param = $leftParam, processedParam = $leftVal, currentPropertyMapping = $left);
                                       let secondVal = ^EnumProcessingHolder(param = $rightParam, processedParam = $rightVal, currentPropertyMapping = $right);
                                       processEqualsForEnum($firstVal, $secondVal, $context);,
                                      |if($leftVal->hasOptionalVarPlaceHolderValue() && $rightVal->hasOptionalVarPlaceHolderValue(),                                                   
                                          |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$leftVal,
                                                                                                                              ^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [$leftVal,$rightVal]),^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 0)])]),   
                                                                                                                              ^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 0)]),^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 1)])])]),
                                          |if($rightVal->hasOptionalVarPlaceHolderValue(),                                        
                                              |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]), ^DynaFunction(name = 'isNull', parameters = [$leftVal])]),                                                                                                                                                           
                                              |if($leftVal->hasOptionalVarPlaceHolderValue(),
                                                  |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$leftVal, ^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]), ^DynaFunction(name = 'isNull', parameters = [$rightVal])]),      
                                                  |^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]));                                           
                                              );
                                          );
                                     );
    
    if ($state.inFilter, | ^$mergedNoSQL(fields=$operation.fields, filteringOperation = $filteringOperation), |  ^$mergedNoSQL(fields=$filteringOperation));
                     
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::validateParamHasDataTypeReturnType(vs:ValueSpecification[1]): Boolean[1]
{
    let type = $vs->match([
                            e : ExtendedRoutedValueSpecification[1] | $e.value.genericType.rawType,
                            vs:ValueSpecification[1] | $vs.genericType.rawType
                         ]);

   assert($type->isEmpty() || $type->toOne()->instanceOf(DataType) || ($type->toOne() == Enum) || ($type->toOne() == Nil), | 'Filter expressions are only supported for Primitives and Enums. Filter contains a parameter of type ' + if($type->isEmpty(),|'',|$type->toOne()->toString()));
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::extractDocumentQuery(src:DocumentStoreElement[1]):SelectDocumentQuery[0..1]
{
   $src->match(
                  [
                     o:SelectDocumentQuery[1] | $o,
                     l:Literal[1] | []
                  ]
              )
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::hasReferenceToEnum(e:DocumentStoreElement[1]):Boolean[1]
{
  $e->hasEnumValue() || $e->hasEnumerationVarPlaceHolderValue()
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::hasEnumValue(e:DocumentStoreElement[1]):Boolean[1]
{
  $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(Enum)
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::hasEnumerationVarPlaceHolderValue(e:DocumentStoreElement[1]):Boolean[1]
{
  $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(VarPlaceHolder) && $e->cast(@Literal).value->cast(@VarPlaceHolder).type->instanceOf(Enumeration)
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::hasOptionalVarPlaceHolderValue(e:DocumentStoreElement[1]):Boolean[1]
{  
   $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(VarPlaceHolder) && $e->cast(@Literal).value->cast(@VarPlaceHolder).multiplicity->isNotEmpty() && $e->cast(@Literal).value->cast(@VarPlaceHolder).multiplicity->toOne()->isZeroOne();
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::generateFreeMarkerForEnumParam(propertyMapping:OperationWithParentPropertyMapping[1], enumParam:DocumentStoreElement[1]):FreeMarkerOperationHolder[1]
{  
  ^FreeMarkerOperationHolder(name = 'enumMap_' + fetchEnumFullPath($propertyMapping.currentPropertyMapping->cast(@DocumentPropertyMapping).transformer->cast(@EnumerationMapping<Any>)), parameters = [$enumParam->cast(@Literal)])
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::generateFreeMarkerOpSelectorForEnumParam(firstVal:FreeMarkerOperationHolder[1], secondVal:DocumentStoreElement[1]):FreeMarkerOperationHolder[1]
{
  ^FreeMarkerOperationHolder(name = 'equalEnumOpSelector', parameters = [$firstVal, ^DynaFunction(name = 'in', parameters = [$secondVal, $firstVal]), ^DynaFunction(name = 'equal', parameters = [$secondVal, $firstVal])])
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::isGetAll(v:ValueSpecification[1]):Boolean[1]
{
   let extracted = $v->match([e:ExtendedRoutedValueSpecification[1]|$e.value, v:ValueSpecification[1]|$v]);
   $extracted->instanceOf(FunctionExpression) && $extracted->cast(@FunctionExpression).functionName == 'getAll';
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::enumToStoreValue(enumWrapper : Literal[1],
        enumPropWrapper : ValueSpecification[1],
        currentPropertyMapping:PropertyMapping[*]):DocumentStoreElement[1]
{
    let enum = $enumWrapper->cast(@Literal).value;
    let expr = $enumPropWrapper->byPassRouterInfo()->cast(@SimpleFunctionExpression);

    let enumPropMapping = $currentPropertyMapping->at(0)->cast(@DocumentPropertyMapping);

    if ($expr.func.name == 'getEnum',
          | [],
          | let property = $expr.func->match([
                                      p:Property<Nil,Any|*>[1]|$p,
                                      n:NativeFunction<Any>[1]|
                                                                assert($n == map_T_m__Function_1__V_m_ || $n == map_T_$0_1$__Function_1__V_$0_1$_ || $n == map_T_MANY__Function_1__V_MANY_);
                                                               let lambda = $expr.parametersValues->evaluateAndDeactivate()->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->cast(@LambdaFunction<Any>);
                                                               $lambda.expressionSequence->at(0)->evaluateAndDeactivate()->byPassRouterInfo()->cast(@FunctionExpression).func->cast(@Property<Nil,Any|*>);
                                     ]);
             assertEquals($enumPropMapping.property, $property, 'The mapping must be for the enum property');
             );

    let sourceVal = if ($enumPropMapping->instanceOf(meta::external::store::document::mapping::SemiStructuredDocumentPropertyMapping),
                        | $enum->id(),
                        | $enumPropMapping.transformer->toOne()->cast(@EnumerationMapping<Any> ).toSourceValues($enum)
                    );

    if ($sourceVal->size() == 1,
        | ^Literal(value=$sourceVal->toOne()),
        | ^LiteralList( values=$sourceVal->map(e | ^Literal(value = $e)) )
    );
}

/*
function meta::external::store::document::functions::pureToDocumentStoreQuery::findOneNode(oldTarget:DocumentTreeNode[1], oldNode:DocumentTreeNode[1], newNode:DocumentTreeNode[1]):DocumentTreeNode[1]
{
   let res = findNode($oldTarget, $oldNode, $newNode);
   assert($res->size() == 1, | 'Found '+$res->size()->toString()+' nodes\n'+'to find:'+$oldTarget->printNodeWithChildren()+'\nold:'+$oldNode->printNodeWithChildren()+'\nnew:'+$newNode->printNodeWithChildren());
   $res->toOne();
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::findNode(oldTarget:DocumentTreeNode[1], oldNode:DocumentTreeNode[1], newNode:DocumentTreeNode[1]):DocumentTreeNode[*]
{
   if ($oldTarget == $oldNode,
         | $newNode,
         | findNodeByChild($oldTarget,$oldNode,$newNode));
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::findNodeByChild(oldTarget:DocumentTreeNode[1], oldNode:DocumentTreeNode[1], newNode:DocumentTreeNode[1]):JoinTreeNode[0..1]
{
   let indexOfOldTarget= $oldNode.children->indexOf($oldTarget);
   let res = if($indexOfOldTarget != -1,
         |  if($newNode.children->size() > $indexOfOldTarget,| $newNode.children->at($indexOfOldTarget),
                      |if ($newNode->instanceOf(JoinTreeNode) && $newNode->cast(@JoinTreeNode).joinName->startsWith('__iso'),
                         |$newNode,
                         |if($newNode.children->size() == 1 && $newNode.children->at(0)->instanceOf(JoinTreeNode) && $newNode.children->at(0)->cast(@JoinTreeNode).joinName->startsWith('__iso'),
                             |$newNode.children->at(0),
                             |[]
                          )
                       )
                    )->cast(@JoinTreeNode);,
         |range(0, $oldNode.children->size(), 1)->map(i|if ($newNode.children->size() > $i, |$oldTarget->findNodeByChild($oldNode.children->at($i), $newNode.children->at($i)),|[]))->first()->cast(@JoinTreeNode);
    );
    assert($res->size() <= 1, | 'Found '+$res->size()->toString()+' nodes\n'+'to find:'+$oldTarget->printNodeWithChildren()+'\nold:'+$oldNode->printNodeWithChildren()+'\nnew:'+$newNode->printNodeWithChildren());
    $res->first();
}
*/

function meta::external::store::document::functions::pureToDocumentStoreQuery::processEqualsForEnum(firstVal : EnumProcessingHolder[1], secondVal : EnumProcessingHolder[1], context : DebugContext[1]) : DocumentStoreElement[1]
{  
    let hasOnlyEnumValues = [$firstVal, $secondVal]->forAll(e|$e.processedParam->hasEnumValue());  
    if($hasOnlyEnumValues,
        | ^DynaFunction(name = 'equal', parameters = [$firstVal, $secondVal]->map(v|^Literal(value=$v.processedParam->cast(@Literal).value->toString()))),
        | let enumVar = [$firstVal, $secondVal]->partition(e|$e.processedParam->hasEnumerationVarPlaceHolderValue());
          let hasEnumVarAndEnumProp = $enumVar.first.values->isNotEmpty() && $enumVar.second.values.currentPropertyMapping->toOne()->map(e|$e->cast(@OperationWithParentPropertyMapping).currentPropertyMapping->isNotEmpty() && $e->cast(@OperationWithParentPropertyMapping).currentPropertyMapping->cast(@DocumentPropertyMapping).transformer->toOne()->instanceOf(EnumerationMapping))->toOne();
          let hasEnumVarAndEnumVal = $enumVar.first.values->isNotEmpty() && $enumVar.second.values.processedParam->toOne()->hasEnumValue();
          if($hasEnumVarAndEnumProp,
              | let enumParamFreeMarker = generateFreeMarkerForEnumParam($enumVar.second.values.currentPropertyMapping->toOne(), $enumVar.first.values.processedParam->toOne());
                generateFreeMarkerOpSelectorForEnumParam($enumParamFreeMarker, $enumVar.second.values.processedParam->toOne());,
              | if($hasEnumVarAndEnumVal,
                    | let literal = $enumVar.first.values.processedParam->cast(@Literal).value->cast(@VarPlaceHolder); 
                      ^DynaFunction(name = 'equal', parameters = [^Literal(value=^VarPlaceHolder(name=$literal.name->toOne(),type = $literal.type->toOne(),multiplicity = $literal.multiplicity->toOne())), ^Literal(value = $enumVar.second.values.processedParam->cast(@Literal).value->toOne()->toString())]);,
                    | // Case 3 - EnumVal & EnumClassProp
                      let hasEnumProp = [$firstVal, $secondVal]->partition(e|$e.processedParam->hasEnumValue());
                      let sourceVal = enumToStoreValue($hasEnumProp.first.values.processedParam->cast(@Literal)->toOne(), $hasEnumProp.second.values.param->toOne()->evaluateAndDeactivate(), $hasEnumProp.second.values.currentPropertyMapping.currentPropertyMapping);
                      $sourceVal->match([
                                          l:Literal[1] |  ^DynaFunction(name = 'equal', parameters = [$hasEnumProp.second.values.processedParam->toOne(), $l]),
                                          ll: LiteralList[1] | ^DynaFunction(name = 'in', parameters = [$hasEnumProp.second.values.processedParam->toOne(), $ll])
                                        ]);
                  );
            );
      );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processDynaFunction(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let funcName = $f.func.functionName->toOne();

   let isIfTrueFalseStmt = $f.func == if_Boolean_1__Function_1__Function_1__T_m_ || $state.inIf == true;
   let paramIsIfTrueFalseStmt = {paramIndex:Integer[1]|$state.inIf == true && $paramIndex->in([1,2])};

   let processedParams = if($f->isIfForEnum($state.inFilter),| processIfForEnum($f, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)
                                                            ,| let zippedParameters = $f.parametersValues->size()->range()->zip($f.parametersValues);
                                                               pair(^List<DocumentStoreElement>(values=$zippedParameters->map(pv| let updatedState = if($paramIsIfTrueFalseStmt->eval($pv.first),|^$state(inIfTrueFalseStmt=true),|$state);
                                                                                                                                        $pv.second->processValueSpecification($currentPropertyMapping, $operation, $vars, $updatedState, $context, $extensions);)),{res:DocumentStoreElement[1]|$res}););

   let parameterNoSQL = $processedParams.first.values->map(x | extractDocumentQuery($x));//$f.parametersValues->map(pv|$pv->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context))->map(x | extractSelectSQLQuery($x));

   let mergedNoSQL = if ($parameterNoSQL->isEmpty(),
                     | $operation,
                     | let sqls = if ($parameterNoSQL->size() > 1,
                           | let zippedParameterNoSQLs = $parameterNoSQL->size()->range()->zip($parameterNoSQL);
                             $zippedParameterNoSQLs->map(s| let updatedState = if($isIfTrueFalseStmt,|^$state(inIfTrueFalseStmt=true, shouldIsolate=true),|^$state(shouldIsolate=true));
                                                          $s.second;);,
                           | $parameterNoSQL
                       );
                       let nsqls =
                                     if($f.func.functionName->toOne() != 'or',
                                       |$sqls,
                                       |$sqls->map(s|$s->moveExtraFilterToFilter($extensions))
                                     );
                       $nsqls->mergeDocumentQueryData('', $state, $context, $extensions);
               );

   let res = $state.inFilter->if(
                           | let unSupportedBiTemporalProcessing = $mergedNoSQL.filteringOperation->isEmpty();
                             if($unSupportedBiTemporalProcessing ,| $mergedNoSQL
                                                                 ,| ^$mergedNoSQL(filteringOperation = newDynaFunction($f.func.functionName->toOne(), if($parameterNoSQL->isEmpty(), | [], |$mergedNoSQL.filteringOperation))));,
                           | ^$mergedNoSQL
                             (
                                fields = newDynaFunction($f.func.functionName->toOne(), $mergedNoSQL.fields)
                             )
                        );

   $processedParams.second->eval($res);
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::newDynaFunction(name: String[1], params: DocumentStoreElement[*]): DynaFunction[1]
{
   if($name->in(['and','or']),
               | newAndOrDynaFunctionWrappedInGroup($name, $params),
               | ^DynaFunction(name = $name, parameters = $params)
     );
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::newAndOrDynaFunctionWrappedInGroup(name: String[1], params: DocumentStoreElement[*]): DynaFunction[1]
{
   ^DynaFunction(name = 'group', parameters = ^DynaFunction(name = $name, parameters = $params));
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::isIfForEnum(f:FunctionExpression[1], inFilter:Boolean[1]):Boolean[1]
{
   $f.func.functionName->toOne()=='if' && !$inFilter && $f.genericType.rawType->toOne()->instanceOf(Enumeration)
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::moveExtraFilterToFilter(s:SelectDocumentQuery[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let filters = $s.filteringOperation;
   ^$s(
         filteringOperation = if ($filters->size() > 1,|^DynaFunction(name = 'group', parameters = $filters->andFilters($extensions)->toOne()),|$filters)
   );
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::processIfForEnum(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):Pair<List<DocumentStoreElement>,meta::pure::metamodel::function::Function<{DocumentStoreElement[1]->DocumentStoreElement[1]}>>[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'Processing "if for enum"\n'));

   let execSides = $f.parametersValues->tail()->map(p|pair($p,$p->byPassRouterInfo()->cast(@InstanceValue).values->cast(@LambdaFunction<Any>)->toOne()));
   let propertyMappings = $execSides.second.expressionSequence->map(e|
                                                               let classPropertyPair = $e->findPropertySequence()->first();
                                                               if(!$classPropertyPair->isEmpty(),| let class = $classPropertyPair.first;
                                                                                                   let propertyName = $classPropertyPair.second.name->toOne();
                                                                                                   let classMapping = $state.mapping.classMappingByClass($class->toOne());
                                                                                                   $classMapping->cast(@PropertyMappingsImplementation).propertyMappingsByPropertyName($propertyName);
                                                                                                ,|[]);
                                                             );

   let distinctTransformers = $propertyMappings->filter(m|$m->instanceOf(DocumentPropertyMapping))->cast(@DocumentPropertyMapping).transformer->distinct();
   let semiStructuredMappings = $propertyMappings->filter(m|$m->instanceOf(DocumentPropertyMapping))->forAll(x|$x->instanceOf(SemiStructuredDocumentPropertyMapping));

   assertFalse($distinctTransformers->size() > 1, 'Unable to determine a unique Enum property mapping for an if stmt (returning an Enum)');
   if ($semiStructuredMappings,
       | print(if(!$context.debug, |'', |$context.space+'  Ignoring distinct transformer check as all property mappings are semi structured property mappings\n'));,
       | assertFalse($distinctTransformers->isEmpty(), 'Unable to determine the Enum property mapping for an if stmt (returning an Enum)');
   );

   print(if(!$context.debug, |'',
            | $context.space+'  Found '+$distinctTransformers->size()->toString()+' distinct transformers\n'));

   let foundEnumPropertyMapping = $propertyMappings->at(0);
   let isEnumConstantSide = {l:LambdaFunction<Any>[1] |
         $l.expressionSequence->match([
            sfe : SimpleFunctionExpression[1]| $sfe.func == extractEnumValue_Enumeration_1__String_1__T_1_,
            iv : InstanceValue[1]|$iv.values->size() == 1 && $iv.values->toOne()->instanceOf(Enum),
            vs:ValueSpecification[*]|false
            ]);
         };

   let pred = $f.parametersValues->at(0)->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $context, $extensions);
   let sides = $execSides->map(s|$s.first->processValueSpecification(if($isEnumConstantSide->eval($s.second),
                                                                        |print(if(!$context.debug, |'', | $context.space+'  Enum in if is a constant\n'));
                                                                         $foundEnumPropertyMapping;,
                                                                        |print(if(!$context.debug, |'', | $context.space+'  Enum in if is NOT a constant\n'));
                                                                         $currentPropertyMapping;
                                                                     ), $operation, $vars, $state, $context, $extensions));
   pair(^List<DocumentStoreElement>(values=$pred->concatenate($sides)),{r:DocumentStoreElement[1]|^OperationWithParentPropertyMapping(element=$r, currentPropertyMapping=$foundEnumPropertyMapping)});
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processNot(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   processUnary($f, $currentPropertyMapping, $operation, {a|^DynaFunction(name = 'not', parameters = $a)}, $vars, $state, $context, $extensions)->cast(@SelectDocumentQuery)->moveExtraFilterToFilter($extensions)
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processUnary(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], f:meta::pure::metamodel::function::Function<{DocumentStoreElement[1]->DocumentStoreElement[1]}>[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let existingNoSqlQuery = processValueSpecification($expression.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne()->cast(@SelectDocumentQuery);
   //let existingSqlQuery = $nested.select;
   $state.inFilter->if(
                  |^$existingNoSqlQuery(
                        filteringOperation = $f->eval($existingNoSqlQuery.filteringOperation->toOne())
                    )
                  ,
                  |^$existingNoSqlQuery(
                        fields = $f->eval($existingNoSqlQuery.fields->toOne())
                    )
               );
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::PureFunctionToDocumentStoreFunctionPair extends Pair<meta::pure::metamodel::function::Function<Any>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>
{
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::EnumProcessingHolder
{
  param : ValueSpecification[1];
  processedParam : DocumentStoreElement[1];
  currentPropertyMapping : OperationWithParentPropertyMapping[1];
}

// TODO: DO WE NEED THIS??
Class meta::external::store::document::mapping::SemiStructuredDocumentPropertyMapping extends DocumentPropertyMapping
{
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::MergeResultContainer
{
   node : DocumentTreeNode[1];
   fields : DocumentStoreElement[*];
   filteringOperation : DocumentStoreElement[*];
   //savedFilteringOperation : Pair<DocumentTreeNode, DocumentStoreElement>[*];
   //leftSideOfFilter : DocumentStoreElement[0..1];
   //extraFilteringOperation : DocumentStoreElement[*];
   //oldToNewAliases : OldAliasToNewAlias[*];
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::OldAliasToNewAlias extends Pair<String, CollectionAlias>{}