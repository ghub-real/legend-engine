// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;
import meta::pure::extension::*;
import meta::pure::router::printer::*;
import meta::pure::functions::collection::*;
import meta::external::store::document::metamodel::*;
import meta::external::store::document::extension::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::external::store::document::mapping::functions::*;
//import meta::external::store::service::executionPlan::generation::*;
import meta::external::store::document::metamodel::runtime::*;
import meta::external::store::document::extension::documentQueryToString::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::documentmappingspecification::*;


//Class meta::external::store::document::functions::pureToDocumentStoreQuery::DocumentStoreQuery
//{
//   processingParam        :  String[0..1];
//   processingValue        :  Value[0..1];
//   processedParamValueMap :  Map<String, Value>[1];
//   recordsToBeRead        :  Integer[0..1];
//}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::State
{
   mapping:Mapping[1];
   propertyMappingFromRouter : PropertyMapping[*];
   graphFetchFlow : Boolean[0..1];
   inScopeVars:Map<String, List<Any>>[1];
   supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1];
   graphFetchProperties : Property<Nil,Any|*>[*];
   inFilter:Boolean[1];
   leftSideOfQualifier : ValueSpecification[0..1];
   inGetterFlow:Boolean[0..1];
   functionExpressionStack : FunctionExpression[*];
   inProject:Boolean[1]; 
   importDataFlowAddFks: Boolean[0..1];
   inProjectFunctions: Boolean[1];
   processingProjectionThread: Boolean[1];
   shouldIsolate: Boolean[0..1];
   qualifierBase:OperationWithParentPropertyMapping[0..1];
   functionReferenceScope : FunctionParamScope[0..1];
}


Class meta::external::store::document::functions::pureToDocumentStoreQuery::FunctionParamScope
{
   parent : FunctionParamScope[0..1];
   varToSelect : Map<String,SelectDocumentQuery>[0..1];
   varExpressionToSelect :  Pair<VariableExpression,FunctionParamScope>[*];

   resolveFunctionReferenceByName(s : String[1]){
      let resolved = if(!$this.varToSelect->isEmpty(),|$this.varToSelect->toOne()->get($s),|[]);
      if ($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByName($s),|[]),|$resolved->toOne());
   }:SelectDocumentQuery[0..1];

   resolveFunctionReferenceByVar(v : VariableExpression[1]){
      let resolved = $this.varExpressionToSelect->filter(p|$p.first.name == $v.name)->first();
      if($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByVar($v),|[]),|$resolved.second->toOne());
   }:FunctionParamScope[0..1];
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processNoOp(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1],  context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   //Ignores the function and only processes the first parameter
   processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->toOne()
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processValueSpecification(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*],  operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
   processValueSpecificationReturnPropertyMapping($vs, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions)->map(r | $r.element);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processValueSpecificationReturnPropertyMapping(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let res = $vs->evaluateAndDeactivate()->match(
             [
                 r:ExtendedRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, ^$state(propertyMappingFromRouter = $r.propertyMapping), $context, $extensions),
                 r:FunctionRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                 f:FunctionExpression[1] | processFunctionExpression($f, $currentPropertyMapping, $operation, $vars, ^$state(functionExpressionStack+=$f),  $context, $extensions),
                 i:InstanceValue[1] | let elements = processInstanceValue($i, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions);
                                      $elements->map(e | ^OperationWithParentPropertyMapping(element=$e));,
                 v:VariableExpression[1] | processVariableExpression($v,$currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                 n:NoSetRoutedValueSpecification[1]|$n.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $context, $extensions)                 
             ]);
    $res.element->map(e|$e->match([c:ClassInstanceHolder[1]|true, s:SelectDocumentQuery[1]|$s->validate($vs, $extensions)]));
    $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processVariableExpression(v:VariableExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   print(if(!$context.debug, |'', | $context.space+'>Process Variable Expression, name:' + $v.name + '\n'));
   if ($v.name == 'this' && $state.qualifierBase->isNotEmpty(), | let op = $state.qualifierBase->toOne();
                            let sel = $op.element->cast(@SelectDocumentQuery);
                            //let sel = $elem.select;
                            ^$op(element = ^$sel(filteringOperation = []));,
                          | let res = $v->resolve($vars, $state.inScopeVars)->evaluateAndDeactivate();

                            let resolvedOperation = if(!$state.functionReferenceScope->isEmpty(), //attempt to resolve the variable name to a SelectWithCursor recorded in either this or a parent scope
                                                            | let resolvedOperation = $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name);
                                                              if(!$resolvedOperation->isEmpty(),| $resolvedOperation,|$operation)->toOne();,
                                                            | $operation);

                            let nres = if($res->isNotEmpty() && $res->toOne()->instanceOf(InstanceValue) && $res->cast(@InstanceValue).values->size() == 1 && //$res->cast(@InstanceValue).values->at(0)->instanceOf(VarPlaceHolder) &&
                                          !$state.functionReferenceScope->isEmpty() && $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name)->isNotEmpty(),
                                          |//The open variable is managed in the scope of the expression, so we should not stub it
                                           [],
                                          |$res
                                        );

                            if($nres->isEmpty(),                                                   //true for function params e.g. $e in '[]->filter(e|$e...)'
                                       |$operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                                                             a:DocumentStoreElement[1] | ^OperationWithParentPropertyMapping(
                                                                                                    element=$resolvedOperation,
                                                                                                    currentPropertyMapping=$currentPropertyMapping
                                                                                               )
                                                          ]),
                                       |$nres->toOne()->match(
                                                                [
                                                                   e:VariableExpression[1]| ^OperationWithParentPropertyMapping(element=$operation);,
                                                                   a:Any[1]|                     //the resolved VariableExpression (ValueSpecification) is processed with respect to the $state recorded at the time the owning QualifiedProperty is processed e.g. address in 'Firm.all->filter(f|$f.employeesByAddress($f.address));' employeesByAddress(address: Address[1]){..}'
                                                                            let possiblyNewState = if(!$state.functionReferenceScope ->isEmpty(),
                                                                                                                    | let resolvedVariableExpression=$state.functionReferenceScope->toOne().resolveFunctionReferenceByVar($v);
                                                                                                                      if(!$resolvedVariableExpression->isEmpty(),|^$state(functionReferenceScope=$resolvedVariableExpression->toOne()),|$state);,
                                                                                                                    | $state
                                                                                                     )->toOne();
                                                                            processValueSpecificationReturnPropertyMapping($nres->toOne(), $currentPropertyMapping, $resolvedOperation, $vars, $possiblyNewState, $context->shift(), $extensions);
                                                                ]);
                             );
                          )->cast(@OperationWithParentPropertyMapping);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processFunctionExpression(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
  print(if(!$context.debug, |'', | $context.space+'>Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'));
  let res  = $functionExpression.func->match ([
                                    p:Property<Nil,Any|*>[1] | processPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);,
                                    //q:QualifiedProperty<Any>[1] | processQualifiedPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);,
                                    a:Any[1]| processFunctionExpressionForNonPropertyFunction($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions);
                                   ]);

 print(if(!$context.debug, |'', | $context.space+'>End Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'+$res.element->cast(@SelectDocumentQuery)->map(s | $s->printDebugQuery($context.space, $extensions))->joinStrings(', ')));

  $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processFunctionExpressionForNonPropertyFunction(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let func = findSupportedFunction($functionExpression, $state.supportedFunctions);
   if ( (!$func->isEmpty()), | let params1 = [^List<Any>(values=$functionExpression), ^List<Any>(values=$currentPropertyMapping)];
                                   let params = $params1->concatenate([$operation, $vars, $state, $context]->map(v | ^List<Any>(values=$v)))->concatenate(^List<Any>(values = $extensions));
                                   $func->toOne()->evaluate($params)->cast(@DocumentStoreElement)->toOne()->wrapIfNecessary();
       , |


      if($functionExpression.func->instanceOf(FunctionDefinition),
         |let expression = $functionExpression.func->cast(@FunctionDefinition<Any>).expressionSequence;
              assertEquals(1, $expression->size(), | 'Functions with more than one functionExpression are not supported yet! The function \'' + $functionExpression.func->toString() + '\' has ' + $expression->size()->toString() + ' expressions.');
              processValueSpecificationReturnPropertyMapping($expression->toOne(), $currentPropertyMapping, $operation, $functionExpression->mapVariables($vars, $state.inScopeVars), ^$state(inScopeVars=^Map<String, List<Any>>()), $context->shift(), $extensions);
         ,
         |fail('No MQL translation exists for the PURE function \''+$functionExpression.func.name->toOne()+'\'. \nIf you would like to add a SQL translation for the function then follow the step-by-step guide on the PURE wiki.'); $operation->wrapIfNecessary();
          );
   );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processInstanceValue(i:InstanceValue[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
   processValue($i.values, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processValue(vals:Any[*], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[*]
{
    let select = $operation;
    if ($vals->isEmpty(), | $state.inFilter->if(|^$select(filteringOperation = ^meta::external::store::document::metamodel::Literal(value=^DocumentNull())),|^$select(fields = ^meta::external::store::document::metamodel::Literal(value=^DocumentNull())))
                        , | $vals->map(v | $v->match([
                                  s:String[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$s)),|^$select(fields = ^Literal(value=$s))),
                                  n:Number[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$n)),|^$select(fields = ^Literal(value=$n))),
                                  d:Date[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$d)),|^$select(fields = ^Literal(value=$d))),
                                  b:Boolean[1] | $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$b)),|^$select(fields = ^Literal(value=$b))),
                                  //e:Enum[1] | let ev = mapEnumValue($e, $currentPropertyMapping, $context); ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$ev)),|^$select(columns = ^Literal(value=$ev))));,
                                  v:ValueSpecification[1] | processValueSpecification($v, $currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                                  l:LambdaFunction<Any>[1] | $l.expressionSequence->at(0)->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $context, $extensions),
                                  a:Any[1] | ^ClassInstanceHolder(value=$a);
                             ])) );
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::validate(s:SelectDocumentQuery[1], v:ValueSpecification[0..1], extensions:Extension[*]):Boolean[1]
{
   let allNodes = if($s.data->isEmpty(),|[],|$s.data->toOne()->getAllNodes())->cast(@DocumentTreeNode);
   // validateNode('currentTreeNode', $s, $s.currentTreeNode, $v, $allNodes, $extensions);
   // What exactly do we validate here?
   true;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::validateNode(nodeName:String[1], s:SelectDocumentQuery[1], node:DocumentTreeNode[0..1], v:ValueSpecification[0..1], allNodes:DocumentTreeNode[*], extensions:Extension[*]):Boolean[1]
{
   if ($node->isEmpty(),
      |true,
      |
         assert(
              $allNodes->contains($node->toOne()),
              |'\nfail:\n\nNODE VALIDATION ERROR: '+$nodeName+'\n\n'+$allNodes->map(n|$n->printNode())->makeString(', ')+'\n\nDOESN\'T CONTAIN:\n\n'+$node->printNode()+
               '\n\nIN:\n\n\''+$s->printDebugQuery('', $extensions)+
               'VS: \''+if($v->isEmpty(),|'',|$v->toOne()->meta::pure::router::printer::asString()+'\'');
             );
   );
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::OperationWithParentPropertyMapping extends DocumentStoreElement
{
   element : DocumentStoreElement[1];
   currentPropertyMapping : PropertyMapping[*];
}

Class meta::external::store::document::functions::pureToDocumentStoreQuery::ClassInstanceHolder extends DocumentStoreElement
{
   value : Any[1];
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::shift(d:DebugContext[1]):DebugContext[1]
{
   ^$d(space = $d.space+'   ');
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::findSupportedFunction(fe:FunctionExpression[1], supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1]):meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>[0..1]
{
   $supportedFunctions->get($fe.func)
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::getSupportedFunctions():Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>[1]
{
   newMap([
      ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__T_MANY_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_),
      ^PureFunctionToRelationalFunctionPair(first=meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_, second=meta::external::store::document::functions::pureToDocumentStoreQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectDocumentQuery_1__Map_1__State_1__DebugContext_1__Extension_MANY__DocumentStoreElement_1_)
      ]);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processPropertyFunctionExpression(fe:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let propertyOwner = $fe.parametersValues->at(0)->map(p|$p->byPassRouterInfo());

   print(if(!$context.debug, |'', | $context.space+'>Process Property Function Expression: ' + $fe.func.name->toOne() + ', property owner:' + $propertyOwner.genericType->genericTypeClass().name->toOne() + ', inFilter:' + $state.inFilter->toString() + '\n'));

   let leftSide = processValueSpecificationReturnPropertyMapping($fe.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions)->toOne();
   $leftSide.element->match(
                     [
                        c : ClassInstanceHolder[1] |
                              let val = $fe.func->cast(@Property<Nil,Any|*>)->eval($c.value);
                              let element = processValue($val, $currentPropertyMapping, $operation, $vars, $state, $context->shift(), $extensions)->toOne();
                              ^OperationWithParentPropertyMapping(element=$element);,
                        sel : SelectDocumentQuery[1] |
                                let toCheckVals = if ($state.inFilter, |$sel.filteringOperation, |$sel.fields);
                                let property = $fe.func->cast(@AbstractProperty<Any>);
                                let propertyOwnerClass = $propertyOwner.genericType->genericTypeClass();
                                let baseOperation = if($currentPropertyMapping->isEmpty()
                                                                ,| $leftSide.currentPropertyMapping
                                                                ,| $currentPropertyMapping
                                                   )->match([
                                                         o:OtherwiseEmbeddedDocumentInstanceSetImplementation[1] | let navigateToOtherwiseMapping = $o.propertyMappingsByPropertyName($property.name->toOne())->isEmpty();
                                                                                                                    ^OperationWithParentPropertyMapping
                                                                                                                     (
                                                                                                                        element = $sel,
                                                                                                                        currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                                                                      );
                                                                                                                     ,

                                                         a:Any[*]|^OperationWithParentPropertyMapping
                                                                  (
                                                                     element = $sel,
                                                                     currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                  );
                                                      ]);
                              processProperty(
                                           $property,
                                           $propertyOwnerClass,
                                           $baseOperation.currentPropertyMapping,
                                           $state.propertyMappingFromRouter,
                                           $baseOperation.element->cast(@SelectDocumentQuery),
                                           $state,
                                           $context->shift(),
                                           $extensions
                                      );
                           

                     ]
                   );
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::printDebugQuery(select:SelectDocumentQuery[1], space:String[1], extensions:Extension[*]):String[1]
{
   $select->meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(meta::external::store::document::metamodel::runtime::DatabaseType.Mongo, $extensions);
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::wrapIfNecessary(operation:DocumentStoreElement[1]):OperationWithParentPropertyMapping[1]
{
   $operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                       a:DocumentStoreElement[1] | ^OperationWithParentPropertyMapping(element=$operation)
                     ])
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::getAllNodes(s:TreeNode[1]):TreeNode[*]
{
   $s->concatenate($s.childrenData->map(k|$k->getAllNodes()));
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::printNode(t:DocumentTreeNode[0..1]):String[1]
{
   if($t->isEmpty(),|'',|$t->match([a:RootJoinDocumentTreeNode[1]|'root',j:JoinDocumentTreeNode[1]| '('+$j.alias.name+')']));
}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::printNodeWithChildren(t:DocumentTreeNode[0..1]):String[1]
{
   $t->printNode()+'['+if($t->isEmpty(),|'',|$t.children->map(c|$c->printNodeWithChildren())->makeString(','))+']';
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processProperty(property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], currentPropertyMapping:PropertyMapping[*], propertyMappingFromRouter:PropertyMapping[*], srcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
// Uses function from relational package: function meta::relational::mapping::findPropertyMapping
   let propertyMappings = findPropertyMapping($property, $propertyOwnerClass, $currentPropertyMapping, $propertyMappingFromRouter, $state.mapping->toOne(),$context);
   let res = processPropertyMapping($propertyMappings, $propertyOwnerClass, $srcOperation, $state, $context, $extensions);
   ^OperationWithParentPropertyMapping(element=$res, currentPropertyMapping=$propertyMappings);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, createDbConfig($dbType, [], false), ^Format(newLine='', indent=''), ^Config(), $extensions);
}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), ^Format(newLine='', indent=''), ^Config(), $extensions);
//}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], config:Config[1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), $config, $extensions);
//}
//
//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
//{
//   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), ^Config(), $extensions);
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), $config, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1],  dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, $dbConfig, $format, $generationState, ^Config(), $extensions);
}

//function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):String[1]
//{
//   $relationalOperationElement->processOperation($sgc.dbConfig, $sgc.format, $sgc.generationState, $sgc.config, $sgc.extensions);
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::collectionToString(collection:Collection[1], dbConfig : DbConfig[1]):String[1]
{
   let collectionName = $dbConfig.collectionNameToIdentifier($collection.name);
   $dbConfig.identifierProcessor($collectionName);
}

function  meta::external::store::document::functions::pureToDocumentStoreQuery::processOperation(documentStoreElement:DocumentStoreElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config:Config[1], extensions:Extension[*]):String[1]
{
   let sgc = ^SqlGenerationContext(dbConfig=$dbConfig, format=$format, generationState=$generationState, config=$config, extensions=$extensions);
   $documentStoreElement->match($extensions->map(e|$e.moduleExtension('documentStore')->cast(@DocumentStoreExtension).documentQueryToString_processOperation)->map(f | $f->eval($dbConfig, $format, $generationState, $config, $extensions))->concatenate(
                                       [
                                          //v:VarPlaceHolder[1]| '${'+$v.name+'}',
                                          //v:VarSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          //v:VarCrossSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          //w:WindowColumn[1]|$dbConfig.windowColumnProcessor($w, $sgc),
                                          //s:ViewSelectSQLQuery[1]|'('+$s.selectSQLQuery->processOperation($dbConfig, $format, $generationState, $config, $extensions)+')',
                                          c:Collection[1]|$c->collectionToString($dbConfig),
                                          //js:JoinStrings[1] | $dbConfig.joinStringsProcessor($js, ^$sgc(config=^Config())),
                                          alias:Alias[1]|
                                                let innerTerm = $alias.documentElement->match([
                                                   //r : VarSetPlaceHolder[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions),
                                                   s : SelectDocumentQuery[1]|$s->processSelectDocumentQuery($sgc, true),
                                                   r : DocumentStoreElement[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions)
                                                ]);

                                                let identifier = $dbConfig.identifierProcessor($alias.name);

                                                let sqlOp = $alias.documentElement->instanceOf(SelectDocumentQuery);

                                                '%s%s%s as %s'->format([
                                                      if ($sqlOp,|'(',|''),
                                                      $innerTerm,
                                                      if ($sqlOp,|')',|''),
                                                      $identifier
                                                      ]);
                                             ,
//                                          c:TableAliasColumn[1]|let doubleQuote = if($config.useQuotesForTableAliasColumn == false, |'', |'"');
//                                                                if(!$config.generateJoin->isEmpty() && $config.generateJoin->toOne(),|if ($config.generateJoinTarget == $c.alias,
//                                                                                                                                          |'{target}.',
//                                                                                                                                          |let schema = $c.alias.relationalElement->match([t:Table[1]|$t.schema.name, v:View[1]|$v.schema.name]);
//                                                                                                                                           if ($schema == 'default',|'',|$schema+'.');
//                                                                                                                                      )
//                                                                                                                                    ,|''
//                                                                ) + if ($config.generateJoinTarget == $c.alias, |'',|$dbConfig.identifierProcessor($doubleQuote+$c.alias.name->toOne()+$doubleQuote) + '.') + processColumnName($c.column.name->toOne(), $dbConfig);,
                                          l:Literal[1]| processLiteral($l, $dbConfig),
                                          ll:LiteralList[1] | $ll.values->map(e | $e->processOperation($dbConfig, $format, $generationState, $config, $extensions))->joinStrings('(', ', ', ')'),
                                          s:SelectDocumentQuery[1]| $s->processSelectDocumentQuery($sgc, false),
//                                          u:UnionAll[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ALL ')+')',
//                                          u:Union[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ')+')',
//                                          f:FreeMarkerOperationHolder[1]|processFreeMarkerOperationHolder($f, $dbConfig, $format, $generationState, $config, false, $extensions),
//                                          d:DynaFunction[1]|processDynaFunction($d, $sgc),
                                          f:FieldName[1]|$dbConfig.identifierProcessor($f.name->toOne()),
//                                          s:SemiStructuredObjectNavigation[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
//                                          s:SemiStructuredArrayFlatten[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
//                                          s:SemiStructuredArrayFlattenOutput[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          {f:  meta::external::store::document::metamodel::Function[1]| assert(false, 'Don\'t know how to handle %s', $f->type()); 'TO DO'; }
                                       ])->toOneMany()
                                     );
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processPropertyMapping(propertyMapping:PropertyMapping[*], propertyOwnerClass:Class<Any>[1], srcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'*>Process Property: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') ' +'NODEID_NA'+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'   (Q)Source Operation>  '+$srcOperation->cast(@SelectDocumentQuery)->printDebugQuery($context.space, $extensions)));
   let res = $propertyMapping->match([
               //s:SemiStructuredRelationalPropertyMapping[*] | processSemiStructuredRelationalPropertyMapping($s, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               r:DocumentPropertyMapping[*] | processDocumentPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $context->shift(), $extensions),
               //r:CrossSetImplementationPropertyMapping[*] | processCrossPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               e:EmbeddedDocumentInstanceSetImplementation[*] | if(($state.inGetterFlow == true) && $e->size() == 1 && $e->toOne()->instanceOf(OtherwiseEmbeddedDocumentInstanceSetImplementation),
                                                                     | processDocumentPropertyMapping($e->toOne()->cast(@OtherwiseEmbeddedDocumentInstanceSetImplementation).otherwisePropertyMapping->cast(@DocumentPropertyMapping), $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $context->shift(), $extensions);,
                                                                     | $srcOperation;
                                                                  )
             ]);

   print(if(!$context.debug, |'',
            | $context.space+'<*Process Property Result: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') ' +'NODEID_NA'+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'            '+$res->cast(@SelectDocumentQuery)->printDebugQuery($context.space, $extensions)));

   $res;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::getPropertyName(documentElement:DocumentStoreElement[1],property:AbstractProperty<Any>[1], documentPropertyMappings:DocumentPropertyMapping[*], extensions:Extension[*]):String[1]
{
   $documentElement->match(
            [//u:Union[1]| '"'+ $relationalPropertyMappings.relationalOperationElement->buildUniqueName(false, $extensions)+'"',
             a:Any[1]|'"'+$property.name->toOne()+'"'] );
}


//  Renu : Core function to fix, completely gutted
function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentPropertyMapping(documentPropertyMappings:DocumentPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], oldSrcOperation:SelectDocumentQuery[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let propertyReturnType = $property->cast(@Property<Nil,Any|*>).genericType.rawType->toOne();
   let firstStep = $propertyReturnType->match(
                                 [
                                    p:DataType[1] | //let currentTreeNode = $oldSrcOperation.currentDocumentTreeNode->toOne();
                                                    // ---------------------------------------------------
                                                    // Potentially add missing columns in the union!  // Duplicated Code??
                                                    let documentElement = $oldSrcOperation.data.alias.documentElement->toOne();
                                                    let propName = $documentElement->getPropertyName($property, $documentPropertyMappings, $extensions);
                                                    let result  = pair($propName, $oldSrcOperation);

                                                    let srcOperation = $result.second;
                                                    //let propName = $result.first;
                                                    // ---------------------------------------------------

                                                    let mappingImpl = $documentPropertyMappings->at(0).documentStoreElement;

                                                    //let newCurrentTreeNode = $srcOperation.currentTreeNode->toOne();
                                                    let relElement = $oldSrcOperation.data.alias.documentElement->toOne();

//                                                    let res = if (
//                                                                  ($relElement->instanceOf(SelectDocumentQuery) &&
//                                                                  ($mappingImpl->instanceOf(meta::external::store::document::metamodel::Function) || $mappingImpl->instanceOf(Literal)) &&
//                                                                   $relElement->cast(@SelectDocumentQuery).fields->filter(c|$c->instanceOf(Alias))->cast(@Alias).name->contains($propName))
//                                                                  ,
//                                                                  | // We should not process the property mapping as it should have been done in the embedded selectSQLQuery....
//                                                                    let sel = $srcOperation;
//                                                                    //let embeddedSelect = $currentTreeNode.alias.relationalElement->cast(@SelectSQLQuery);
//                                                                    // Warning the type of the column is bogus here....
//                                                                    let newField = ^Field(name=$propName, type=^meta::relational::metamodel::datatype::Integer());
//                                                                    if ($state.inFilter,
//                                                                       |^$srcOperation(select = ^$sel(filteringOperation+=$newField)),
//                                                                       |^$srcOperation(select = ^$sel(fields+=$newField));
//                                                                  ,
//                                                                  | // Process the property mapping...
//                                                                    let srcOperationWithMilestoneProcessingState=$srcOperation->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.DATATYPE_PROPERTY);
//                                                                    $mappingImpl->processColumnsInRelationalOperationElements($state, $srcOperationWithMilestoneProcessingState, $nodeId, $aggFromMap, true, $context, $extensions);
//                                                               );
//                                                    let sel = $res;
//                                                    let firstStep = if ($state.inFilter,
//                                                                        |^$res(select = ^$sel(filteringOperation = $sel.filteringOperation->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions)));,
//                                                                        |^$res(select = ^$sel(filteringOperation = [], fields = $sel.fields->at(0)->usePropertyName($property, $documentPropertyMappings, $extensions)));
//                                                                       );
//                                                    let secondStep = $mappingImpl->match([
//                                                                                         //r : RelationalOperationElementWithJoin[1] | $firstStep;,
//                                                                                         a : Any[*]                                | ^$firstStep(positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first()),
//                                                                                                                                                 currentTreeNode = $newCurrentTreeNode->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first());
//                                                                                        ]);
//                                                    let newSel = $secondStep.select;
//                                                    if ($srcOperation.select.filteringOperation->isEmpty() || $srcOperation.select.leftSideOfFilter->isEmpty(),
//                                                       |if (!$srcOperation.select.leftSideOfFilter->isEmpty(),
//                                                          |^$secondStep(select = ^$newSel(leftSideOfFilter=[])),
//                                                          |$secondStep
//                                                        ),
//                                                       |^$secondStep(select = ^$newSel(savedFilteringOperation = $newSel.savedFilteringOperation
//                                                                                                                ->concatenate(pair($sel.leftSideOfFilter->toOne(), $srcOperation.select.filteringOperation->toOne()))
//                                                                                                                ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
//                                                                             )
//                                                        )
//                                                    );
                                                      $srcOperation;
                                                    ,
                                    c:Class<Any>[1] |let srcOperation = $oldSrcOperation;

                                                     //let isUnionSubType = $oldSrcOperation.currentTreeNode.alias.relationalElement->toOne()->instanceOf(Union) && $relationalPropertyMappings->size() == 1;
//                                                     let updatedDocumentPropertyMappings = $documentPropertyMappings);
//
//                                                      let res =
//                                                            let joinTree = $documentPropertyMappings->at(0).documentStoreElement.joinTreeNode->toOne();
//                                                            let targetAlias = $joinTree.join->findTarget($srcOperation.currentTreeNode->toOne(), $extensions);
//                                                            let extraColumns = $joinTree.join.operation->extractCollectionAlias()->filter(t|$t.alias != $targetAlias);
//                                                            let yy = manageIsolation($srcOperation, $extraColumns, $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions);
//                                                            let srcOperationWithMilestoneProcessingState=$yy->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY);
//                                                            doJoinToClass($relationalPropertyMappings->at(0), $c, $srcOperationWithMilestoneProcessingState, $joinType, $nodeId, $state, $context, $extensions);
                                                    $srcOperation;
                                  ]
                             );
                             //     ->manageMilestoningContextPropogationForProperties();

//     let newSel = $firstStep;
//
//     let finalResult = if ($oldSrcOperation.filteringOperation->isEmpty() || $newSel.leftSideOfFilter->isEmpty(),
//        |if (!$oldSrcOperation.leftSideOfFilter->isEmpty(),
//                |^$firstStep(leftSideOfFilter=[]),
//                |$firstStep
//         ),
//        |  //firstStep can result in (saved) milestoning filtering operations which need to be processed along with the existing src saved filtering operations
//            let savedFilteringOpWithOldAndNewOps=$newSel.savedFilteringOperation->map(p| let existingOrNewNode=if($oldSrcOperation.select.savedFilteringOperation->contains($p),|$p.first->findOneNode($oldSrcOperation.select.data->toOne(), $newSel.data->toOne()),|$p.first);pair($existingOrNewNode, $p.second);)
//                                                                               ->concatenate(pair($newSel.leftSideOfFilter->toOne(), $oldSrcOperation.select.filteringOperation->toOne()))
//                                                                               ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
//
//           ^$firstStep(select = ^$newSel(savedFilteringOperation = $savedFilteringOpWithOldAndNewOps));
//     );
     let finalResult = if (!$oldSrcOperation.leftSideOfFilter->isEmpty(),
                     |^$firstStep(leftSideOfFilter=[]),
                     |$firstStep);
     $finalResult->validate([], $extensions);
     $finalResult;

}

function meta::external::store::document::functions::pureToDocumentStoreQuery::usePropertyName(element:DocumentStoreElement[1], property:AbstractProperty<Any>[1], documentPropertyMappings:DocumentPropertyMapping[*], extensions:Extension[*]):DocumentStoreElement[1]
{
  $element->match(   [
                        l:Literal[1]|$l,
                        ll:LiteralList[1]|$ll,
                        j:JoinStrings[1]|^$j(strings=$j.strings->map(s | $s->usePropertyName($property, $documentPropertyMappings, $extensions)));,
                        s:SelectDocumentQuery[1]|^$s(filteringOperation = $s.filteringOperation->map(f|$f->usePropertyName($property, $documentPropertyMappings, $extensions)));,
                        t:CollectionAlias[1]| $t,
                        //a:Alias[1]|^$a(relationalElement = $a.relationalElement->usePropertyName($property, $relationalPropertyMappings, $extensions));,
                        //d:DynaFunction[1]|newDynaFunction($d.name, $d.parameters->map(p | $p->usePropertyName($property, $relationalPropertyMappings, $extensions))),
                        //op:UnaryOperation[1]|^$op(nested=$op.nested->usePropertyName($property, $documentPropertyMappings, $extensions)),
                        op:BinaryOperation[1]|^$op(left=$op.left->usePropertyName($property, $documentPropertyMappings, $extensions), right=$op.right->usePropertyName($property, $documentPropertyMappings, $extensions)),
                        //op:VariableArityOperation[1]|^$op(args=$op.args->map(arg | $arg->usePropertyName($property, $relationalPropertyMappings, $extensions))),
                        fn:FieldName[1] |$fn
                    ]
                 )
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectDocumentQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
   let setImplementation = $expression.parametersValues->at(0)->cast(@ExtendedRoutedValueSpecification).sets->toOne();
   processGetAll($expression, $setImplementation, $expression.parametersValues, $state, $vars, $context, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(expression: FunctionExpression[1], setImplementation:SetImplementation[1], parameters:ValueSpecification[*], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1]
{
  let nodeId = 'nodeId';
   let processRootSetImpl = {r:RootDocumentInstanceSetImplementation[1] |let milestoningContext = []; //getMilestoningContextForAll($expression,$r, $parameters, $state, $vars, $context, $extensions);  
                                                                          // removed $milestoningContext parameters
                                                                           processGetAll($r, $r.class, $nodeId, true, -1, !$state.inProject, $state, $context, $extensions);};

   $setImplementation->match([r:RootDocumentInstanceSetImplementation[1]| $processRootSetImpl->eval($r)
                              // r:meta::pure::router::clustering::CrossSetImplementation[1]| let newTable = ^VarCrossSetPlaceHolder(varName=$r.varName, name=$r.varName, schema=^Schema(name='default', database=^Database()), crossSetImplementation = $r);
                              //                                                              let treeNode = ^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = $newTable));
                              //                                                              ^SelectWithCursor(select = ^SelectSQLQuery(data = $treeNode), currentTreeNode = $treeNode);,
                              // o:OperationSetImplementation[1]|let setImpls = $o->resolveOperation($state.mapping)->cast(@RootDocumentInstanceSetImplementation);
                              //                                 if($setImpls->size()==1,| $processRootSetImpl->eval($setImpls->at(0))
                              //                                                        ,| let milestoningContext = []; //getMilestoningContextForAll($expression,$o, $parameters, $state, $vars, $context, $extensions);
                              //                                                           //let union = buildUnion($setImpls, [], false, $state.inProject, $milestoningContext, $nodeId, $state, $context, $extensions);
                              //                                                           let propMap = $setImpls->at(0)->cast(@DocumentInstanceSetImplementation)->dataTypePropertyMappings();
                              //                                                           let newRoot = ^RootJoinDocumentTreeNode(alias = ^CollectionAlias(name='unionBase', documentElement=$union));
                              //                                                           let fullCols = $union.queries->at(0).columns->cast(@Alias).name->filter(n | $n != 'u_type');
                              //                                                           ^SelectWithCursor( select = ^SelectSQLQuery( columns = ^Alias(name= 'u_type', relationalElement = ^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name='u_type', type=^meta::relational::metamodel::datatype::Integer())))
                              //                                                                                                                  ->concatenate($fullCols->map(p|^Alias(name=$p, relationalElement =^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name=$p, type=^meta::relational::metamodel::datatype::Integer()))))),
                              //                                                                                                        data = $newRoot,
                              //                                                                                                        filteringOperation = []
                              //                                                                                                      ),
                              //                                                                              currentTreeNode = $newRoot,
                              //                                                                              milestoningContext=$milestoningContext);
                              //                                                         );
                           ]);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::processGetAll(viewSpecification:DocumentMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1],  state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let newState = ^$state(inProject=false, inProjectFunctions=false, processingProjectionThread=false,  inFilter=false); //shouldIsolate=false,
   processDocumentMappingSpecification($viewSpecification, $c, $nodeId, $addPk, $pkOffset, $addAllColumns, $newState, $context, $extensions); //removed $milestoningContext,
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentMappingSpecification(viewSpecification:DocumentMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let mainCollection = $viewSpecification.mainDocumentRelation->processDocumentRelation($c, $nodeId, $addPk, $pkOffset, $addAllColumns, $state, $context, $extensions);  //removed $milestoningContext,

  //  let innerJoinFilterExists = $viewSpecification->getFilter().joinTreeNode.joinType == JoinType.INNER;  // Not supporting joins
  //  let currentRelationalElement = if ($innerJoinFilterExists,
  //                                     | getRelationalElementWithInnerJoin($viewSpecification, $mainCollection, $c, $nodeId, $state, $context, $extensions),
  //                                     | $mainCollection
  //                                 );
   let innerJoinFilterExists = false;
   let currentDocumentElement = $mainCollection;

   let currentNode = ^RootJoinDocumentTreeNode(alias=^CollectionAlias(name = 'root', documentElement = $currentDocumentElement));

  //  let base = ^SelectWithCursor(
  //     select = ^SelectSQLQuery(
  //                     data = $currentNode
  //                 ),
  //     currentTreeNode = $currentNode
  //  );

   let base = ^SelectDocumentQuery(data = $currentNode);

   let quoteColumnAliases = false; // shouldQuoteColumnAliases($viewSpecification);
   // let requiresAllProperties = ($addAllColumns || (!$viewSpecification->getGroupBy()->isEmpty()) || ($viewSpecification->getDistinct()->toOne()));
   let requiresAllProperties = true;

   let properties = if($requiresAllProperties, | columnNamesWithDocumentElement($viewSpecification, $c, $state)->map(c | let newQuery = $c.second->processColumnsInDocumentStoreElements($state, $base, $nodeId, $context, $extensions);
                                                                                                           rebuildSelectDocumentQuery($c.first, [], $newQuery, $quoteColumnAliases);)
                                             , | [] );

  //  let pks = if($addPk && $viewSpecification->getGroupBy()->isEmpty() && ($viewSpecification->getDistinct()->isEmpty() || $viewSpecification->getDistinct()->toOne() == false),
  //                 | let pks = viewSpecificationPrimaryKey($viewSpecification);
  //                   $pks->map(pm|let offset = $pks->indexOf($pm);
  //                                let newQuery = $pm->processColumnsInRelationalOperationElements($state, $base, $nodeId, ^List<ColumnGroup>(), false, $context, $extensions);
  //                                if($state.importDataFlow == true,
  //                                   |rebuildSelectWithCursor([], if($pkOffset == -1,
  //                                                                   |if($state.importDataFlowCurrentSetOffsetInUnion->isEmpty() || $state.importDataFlowImplementationCount == 1,
  //                                                                       |[],
  //                                                                       |$state.importDataFlowCurrentSetOffsetInUnion->toOne()->toString()
  //                                                                    ),
  //                                                                   |$pkOffset->toString()
  //                                                                ), $newQuery, $quoteColumnAliases),
  //                                   |rebuildSelectWithCursor('pk_'+$offset->toString(), if($pkOffset == -1,|[],|$pkOffset->toString()), $newQuery, $quoteColumnAliases)
  //                                );
  //                         );,
  //                 | $base
  //              );
  // Not supporting groupby
  let pks = $base;

   let groupByQuery = $base->applyGroupBy($viewSpecification, $nodeId);

   let filterQuery = if ($innerJoinFilterExists, | $groupByQuery, | $groupByQuery->applyTypeFilter($viewSpecification, $nodeId, $state, $context, $extensions));

   // TODO: Ideally, should try to isolate pk & property queries in all cases. Restrict to graphFetch flow for now
   let pksAndProperties = if ($state.graphFetchFlow == true,
                              | $pks->concatenate($properties)->mergeDocumentQueryData($nodeId, ^$state(shouldIsolate=true), $context, $extensions),
                              | $pks->concatenate($properties)
                          );

   let merged = $pksAndProperties->concatenate($filterQuery)->mergeDocumentQueryData($nodeId, $state, $context, $extensions);
  //  let fks = if ($viewSpecification->getDistinct() == true && !$viewSpecification->instanceOf(View),
  //                    | collectAdditionalJoinColumnsForSource($viewSpecification, $state.mapping,  $merged.data->toOne(), $merged.columns->cast(@Alias)),
  //                    | if ($state.importDataFlowAddFks == true,
  //                          |$state.importDataFlowFksByTable->toOne()->get($mainTable).values->map(c|^Alias(name=$c.name, relationalElement=^TableAliasColumn(alias=$merged.data.alias->toOne(), columnName=$c.name, column=$c))),
  //                          |[]
  //                      )
  //                );
  // Not supporting distinct & import DataFlowAddFks yet
   let fks = ^Alias(name = 'dummyAlias', documentElement=$currentDocumentElement);

   let addedFks = if ($state.importDataFlowAddFks == true, |$fks->map(a|^$a(name='fk_'+$a.name)), |$fks);

   let s = ^SelectDocumentQuery(
                  distinct = false,
                  fields = $merged.fields->concatenate($addedFks),
                  data = $merged.data,
                  filteringOperation = $merged.filteringOperation
                  //savedFilteringOperation = $merged.savedFilteringOperation,
                  //extraFilteringOperation = $merged.extraFilteringOperation,
                  //groupBy = $merged.groupBy
               );
   // No milestoning
   //if(!$milestoningContext->isEmpty() ,|applyMilestoningTypeFilters($s, $milestoningContext->toOne(), $state, $innerJoinFilterExists, $extensions),|$s);
   $s;

}

function meta::external::store::document::functions::pureToDocumentStoreQuery::processDocumentRelation(r: DocumentStoreElement[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):DocumentStoreElement[1] //milestoningContext: TemporalMilestoningContext[0..1], 
{
   $r->match([
               s:SelectDocumentQuery[1] | $s,
               t:Collection[1] | $t
               //u:Union[1] | $u,
               //v:View[1]  | let selectWithCursor = processRelationalMappingSpecification($v, $c, $nodeId, $addPk, $pkOffset, true, $milestoningContext, ^$state(inFilter=false), $context, $extensions);
               //             let select = $selectWithCursor.select;
               //             let selectWithFiltersProcessed = ^$select(filteringOperation=$select.filteringOperation->concatenate($select.extraFilteringOperation))->pushSavedFilteringOperation($extensions);
               //             ^ViewSelectSQLQuery(view=$v, name=$v.name, columns = $selectWithFiltersProcessed.columns, selectSQLQuery = $selectWithFiltersProcessed, schema=$v.mainTable.schema);,
               //s:SemiStructuredArrayFlatten[1] | $s
             ]);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::documentmappingspecification::columnNamesWithDocumentElement(vs: DocumentMappingSpecification[1], c:Class<Any>[0..1], state: State[1]):Pair<String, DocumentStoreElement>[*]
{
   $vs->match([
               r:RootDocumentInstanceSetImplementation[1] | $r->dataTypePropertyMappings()
                                                              ->filter(x | if($state.graphFetchFlow == true, | $x.property->in($state.graphFetchProperties), | true))
                                                              ->map(pm|pair($pm.property.name->toOne(),$pm->cast(@DocumentPropertyMapping).documentStoreElement))
               // v:View[1] | $v.columnMappings->map(cm|pair($cm.columnName, $cm.relationalOperationElement));
              ]);
}

function  meta::external::store::document::functions::pureToDocumentStoreQuery::processColumnsInDocumentStoreElements(z:DocumentStoreElement[1], state:State[1], srcOperation:SelectDocumentQuery[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]  // removed aggFromMap:List<ColumnGroup>[1], cancelJoinOnUnion:Boolean[1], 
{
   $srcOperation->validate([], $extensions);
   let result = $z->match(
               [
                  f:Field[1] |
                              let currentTreeNode = $srcOperation.data->toOne();

                              let alias = $currentTreeNode.alias;
                              let documentElement = $alias.documentElement;

                              // Make sure the column is available a potentially SQL
                              let newSrcOperation = $documentElement->match([
                                //  s:SelectSQLQuery[1] | if ($s.columns->map(c|$c->match([t:TableAliasColumn[1]|$t.column.name,
                                //                                                        a:Alias[1]|$a.relationalElement->match([t:TableAliasColumn[1]|$t.column.name, d:DynaFunction[1]|$d.name, l:Literal[1]|$a.name])
                                //                                                       ])
                                //                                       )->contains($t.column.name),
                                //                          | $srcOperation;,
                                //                          |// Add the missing columns in the nested select (coming most likely from isolation)
                                //                           // 1. find the right alias within the nested SQL ...
                                //                           // the alias we are trying to find might be from a view
                                //                           let allNodes = $s.data->toOne()->getAllNodes()->cast(@RelationalTreeNode);
                                //                           let aliasesToUse = $t.column->extractColumnAliasesInRelationalTreeNodes($t.alias.relationalElement, $allNodes, $context, $extensions);  
                                //                           assert($aliasesToUse->size() == 1, | 'Found too many (or not enough) tables that could support the column '+$t.column.name+' in the nested SQL '+$s->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions));
                                //                           let newSQL = ^$s(columns+=^Alias(name=$t.column.name, relationalElement=$aliasesToUse->toOne()));
                                //                           let newTreeNode = ^$currentTreeNode(alias = ^$alias(relationalElement = $newSQL));
                                //                           let newData = if ($currentTreeNode->instanceOf(RootJoinTreeNode),
                                //                                                |$newTreeNode,
                                //                                                |$srcOperation.select.data->toOne()->replaceJoin($currentTreeNode->toOne()->cast(@JoinTreeNode), $newTreeNode->cast(@JoinTreeNode))
                                //                                         );
                                //                           let oldToNew = $srcOperation.select.data->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias->zip($newData->getAllNodes()->cast(@RelationalTreeNode).alias)->map(o|^OldAliasToNewAlias(first=$o.first.name, second=$o.second));
                                //                           let opSelect = $srcOperation.select;

                                //                           ^$srcOperation(
                                //                                 select = ^$opSelect(
                                //                                                data = $newData->cast(@RootJoinTreeNode),
                                //                                                leftSideOfFilter = if($opSelect.leftSideOfFilter->isEmpty(),|[],|$opSelect.leftSideOfFilter->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                //                                                savedFilteringOperation = $opSelect.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newData), $p.second->reprocessAliases($oldToNew)))
                                //                                          ),
                                //                                 positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                //                                 currentTreeNode = $newTreeNode
                                //                           );
                                //                       );
                                 s:SelectDocumentQuery[1] | $srcOperation,
                                 a:Any[1]|$srcOperation
                              ]);

                              let newOpSelect = $newSrcOperation; //.select;
                              //let column = ^TableAliasColumn(alias=$newSrcOperation.alias->toOne(), column=$t.column);
                              let field = ^Field(name=$f.name, type=$f.type, owner=$f.owner);
                              // ^$newSrcOperation(
                              //       select = $state.inFilter->if(|^$newOpSelect(filteringOperation = $column),|^$newOpSelect(columns = $column))
                              // )
                              ^$newOpSelect(fields = $field);
                              ,
                  d:DynaFunction[1]| let newSelect = if ($d.parameters->isEmpty(),
                                                      | let select = $srcOperation;
                                                         $state.inFilter->if(|^$select(filteringOperation = $d),|^$select(fields = $d));
                                                         ,
                                                      |  let sqlThreads = $d.parameters->map(p|$p->processColumnsInDocumentStoreElements($state, $srcOperation, buildNodeId($nodeId,'_dy'+$d.parameters->indexOf($p)->toString()), $context, $extensions));
                                                         let merged = $sqlThreads->mergeDocumentQueryData($nodeId, $state, $context, $extensions);
                                                         let pFunc = ^$d(parameters = $state.inFilter->if(|$merged.filteringOperation,|$merged.fields));
                                                         $state.inFilter->if(|^$merged(filteringOperation=$pFunc),|^$merged(fields=$pFunc));
                                                    );
                                    //  ^$srcOperation(select = $newSelect,
                                    //                 currentTreeNode = $srcOperation.currentTreeNode->toOne()->findOneNode($srcOperation.select.data->toOne(), $newSelect.data->toOne()),
                                    //                 positionBeforeLastApplyJoinTreeNode = if ($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($srcOperation.select.data->toOne(), $newSelect.data->toOne()))
                                    //          );
                                     $newSelect;
                                     ,
                  l:Literal[1]| let select = $srcOperation;
                                $state.inFilter->if(|^$select(filteringOperation = $l),|^$select(fields = $l));
                                                      
                  // r:RelationalOperationElementWithJoin[1]|
                  //             let col = $r->extractElement();
                  //             let currentData = $srcOperation.select.data->toOne();
                  //             let isDynaFunction = $col->instanceOf(DynaFunction);
                  //             let joinTreeNode = $r.joinTreeNode->toOne();
                  //             let opWithCol = if ($isDynaFunction,
                  //                |
                  //                   let dynaFunction = $col->cast(@DynaFunction);
                  //                   let extraColumns=$col->extractTableAliasColumns();
                  //                   let op = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                  //                   let opWithCol = $dynaFunction->processColumnsInRelationalOperationElements($state, $op, $nodeId, $aggFromMap, $cancelJoinOnUnion, $context, $extensions);
                  //                   let pCol = $state.inFilter->if(|$opWithCol.select.filteringOperation,|$opWithCol.select.columns)->toOne();
                  //                   pair($opWithCol,$pCol->cast(@RelationalOperationElement));
                  //                ,|
                  //                   let op = if($joinTreeNode == [] || ($cancelJoinOnUnion && $srcOperation.currentTreeNode.alias.relationalElement->toOne()->instanceOf(Union)),
                  //                               | $srcOperation,
                  //                               | let extraColumns=$col->filter(p|$p->instanceOf(TableAliasColumn))->cast(@TableAliasColumn);
                  //                                 let newOp = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                  //                                 let savedFilteringOperation = $srcOperation.select.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newOp.select.data->toOne()), $p.second));
                  //                                 let newOpSelect = $newOp.select;
                  //                                 let newOpSelectUpdated = ^$newOpSelect(savedFilteringOperation+=$savedFilteringOperation);
                  //                                 ^$newOp(select=$newOpSelectUpdated);
                  //                               );
                  //                   let pCol = $col->reprocessAliases(^OldAliasToNewAlias(first=$col->cast(@TableAliasColumn).alias.relationalElement->cast(@NamedRelation).name, second=$op.alias->toOne()));
                  //                   pair($op,$pCol->cast(@RelationalOperationElement));
                  //                 );

                  //            let op = $opWithCol.first;
                  //            let opSelect = $op.select;
                  //            let pCol = $opWithCol.second;

                  //            ^$op(
                  //                select = $state.inFilter->if(|^$opSelect(filteringOperation = $pCol),|^$opSelect(columns = $pCol))
                  //            );,
                  // s:SemiStructuredPropertyAccess[1] | let select = $srcOperation.select;
                  //                                     let processedOperand = $state.inFilter->if(|$select.filteringOperation,|$select.columns)->toOne();
                  //                                     let updatedPropertyAccess = ^$s(operand = $processedOperand);
                  //                                     ^$srcOperation(select = $state.inFilter->if(|^$select(filteringOperation = $updatedPropertyAccess),|^$select(columns = $updatedPropertyAccess)));
               ]
            );
   $result->validate([], $extensions);
   $result;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::rebuildSelectDocumentQuery(name:String[0..1], suffix:String[0..1], newQuery: SelectDocumentQuery[1], quotes:Boolean[1]):SelectDocumentQuery[1]
{
   let newName = if($name->isEmpty(),
                    |$newQuery.fields->toOne()->cast(@Field).name,
                    |$name->toOne()
                 )+
                 if($suffix->isEmpty(),
                    |'',
                    |'_'+$suffix->toOne()
                 );
   ^SelectDocumentQuery(
                     fields = ^Alias(name = if($quotes,
                                                |'"'+$newName+'"',
                                                |$newName
                                             ),
                                      documentElement = $newQuery.fields->toOne()
                               ),
                     data = $newQuery.data,
                     filteringOperation = []
                     //extraFilteringOperation=$newQuery.select.extraFilteringOperation
               );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::applyGroupBy(base:SelectDocumentQuery[1], viewSpecification:DocumentMappingSpecification[1], nodeId:String[1]):SelectDocumentQuery[1]
{
  // let groupByMapping = $viewSpecification->getGroupBy();
  //  if ($groupByMapping->isEmpty(), | $base,
  //                                  | let baseSelect = $base.select;
  //                                    let lastNode = $base.currentTreeNode->toOne()->findLastJoinTreeNode();
  //                                    let columns = $groupByMapping.columns->map(c | $c->reprocessAliases(^OldAliasToNewAlias(first=$c->cast(@TableAliasColumn).alias.name, second=$lastNode.alias->toOne())));
  //                                    ^$base(select=^$baseSelect(groupBy=$columns)););
  $base;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::applyTypeFilter(base:SelectDocumentQuery[1], viewSpecification:DocumentMappingSpecification[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
  // let filterMapping = $viewSpecification->getFilter();
  // if ($filterMapping->isEmpty(),
  //       | $base,
  //       | let baseFilterQuery =
  //             if ($filterMapping->toOne().joinTreeNode->isEmpty(),
  //                 | $base;
  //                ,| applyJoinInTree($base.select.data->toOne(), $base.currentTreeNode->toOne(), $filterMapping->toOne().joinTreeNode->toOne(), $base, $nodeId, JoinType.LEFT_OUTER, true, false, [], $state, $context, $extensions);
  //              );
  //         let select = $baseFilterQuery.select;

  //         let lastNode = $baseFilterQuery.currentTreeNode->toOne()->findLastJoinTreeNode();
  //         ^$baseFilterQuery(
  //                  select = ^$select(
  //                               savedFilteringOperation += pair($lastNode, $filterMapping.filter.operation->toOne()->reprocessAliases(^OldAliasToNewAlias(first=$lastNode.alias.relation->cast(@Table).name, second=$lastNode.alias->toOne())))
  //                           )
  //                  );
  //    );
  // Not supporting basefilter query, will need it for consistency
     $base;
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::mergeDocumentQueryData(preQuerySet:SelectDocumentQuery[*], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'   Merge\n'+$preQuerySet->map(q|$q.leftSideOfFilter->size()->toString()+' '+$q->meta::external::store::document::extension::documentQueryToString::documentQueryToString(meta::external::store::document::metamodel::runtime::DatabaseType.Mongo, $extensions))->makeString($context.space+'     [\n'+$context.space+'       ','\n'+$context.space+'       ','\n'+$context.space+'     ]')+'\n'));

   let hasIsolations = false; // $preQuerySet->map(p|$p.data->getAllNodeNames()->filter(n|$n->startsWith('__iso'))->makeString('|'))->removeDuplicates()->size() > 1;
//   let querySet = $preQuerySet->map(q|let selfJoinAddedPreviously = if($q.data->isNotEmpty(),|$q.data->toOne()->addedSelfJoin(),|false);
//                                    $q->manageIsolation([], [], $nodeId, false, ^$state(shouldIsolate = ($state.shouldIsolate || $hasIsolations) && !$selfJoinAddedPreviously), $context, $extensions););
//
//   print(if(!$context.debug, |'',
//            | $context.space+'   Merge(hasIsolations:'+$hasIsolations->toString()+')\n'+$querySet->map(q|$q.leftSideOfFilter->size()->toString()+' '+$q->meta::external::store::document::extension::documentQueryToString::documentQueryToString(meta::relational::runtime::DatabaseType.H2, $extensions))->makeString($context.space+'     [\n'+$context.space+'       ','\n'+$context.space+'       ','\n'+$context.space+'     ]')+'\n'));
//
//   $querySet->map(q|$q->validate($extensions));
//
//   let res = $querySet->tail()->fold(
//      {
//         q,a |
//               print(if(!$context.debug, |'',
//                        | $context.space+'     (A): '+$a->printDebugQuery($context.space, $extensions)+
//                          $context.space+'     (Q): '+$q->printDebugQuery($context.space, $extensions)
//                       )
//                    );
//               let q_moved = if($q.columns->filter(c|$c->instanceOf(Alias) && $c->cast(@Alias).relationalElement->instanceOf(WindowColumn))->map(w|$a.filteringOperation->extractTableAliasColumns().column.name->contains($w->cast(@Alias).name))->contains(true),|$q->moveSelectQueryToSubSelect($q.data,[],'root',$context, $extensions),|$q);
//               if ($q != [] && !$q.data->isEmpty()
//                   ,|
//                      // let shouldIsolate = shouldIsolateSubJoins($a, $q, $context->shift());
//                      let new_a = $a;//if ($shouldIsolate,|$a->possiblyIsolateSubJoins($nodeId),|$a);
//                      let new_q = $q_moved;//if ($a->isIsolated() || $shouldIsolate,|$q->possiblyIsolateSubJoins($nodeId),|$q);
//
//                      let id = buildNodeId($nodeId, '_m'+$querySet->indexOf($q)->toString());
//
//                      let merged = merge(
//                                           ^MergeResultContainer(
//                                              node = $new_a.data->toOne(),
//                                              columns = $new_q.columns,
//                                              filteringOperation = $new_q.filteringOperation,
//                                              savedFilteringOperation = $new_q.savedFilteringOperation,
//                                              extraFilteringOperation = $new_q.extraFilteringOperation,
//                                              groupBy = $new_q.groupBy
//                                            ),
//                                            $new_q.data->toOne(),
//                                            $id,
//                                            $state,
//                                            $context,
//                                            $extensions
//                                        );
//                    let newGroupBy = $new_a.groupBy->concatenate($merged.groupBy)->removeDuplicates();
//
//                    let newNodeAliases = $merged.node->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias;
//                    let remap = $newNodeAliases->map(n |^OldAliasToNewAlias(first=$n.name,second=$n));
//
//                    ^$new_a
//                         (
//                            columns = $new_a.columns->concatenate($merged.columns)->removeDuplicates({a,b|$a->match([a:Alias[1]|$a.name,a:Any[1]|'']) == $b->match([b:Alias[1]|$b.name,b:Any[1]|'x'])}),
//                            data = $merged.node->cast(@RootJoinTreeNode),
//                            filteringOperation = $new_a.filteringOperation->reprocessAliases($remap)->concatenate($merged.filteringOperation),
//                            savedFilteringOperation = $new_a.savedFilteringOperation->map(p|pair($p.first, $p.second->reprocessAliases($remap)))->concatenate($merged.savedFilteringOperation),
//                            extraFilteringOperation = $new_a.extraFilteringOperation->reprocessAliases($remap)->concatenate($merged.extraFilteringOperation),
//                            groupBy = $newGroupBy
//                         );
//                   ,| let cols = $a.columns->filter(c|$c->instanceOf(WindowColumn));
//                        ^$a
//                         (
//                            columns = $a.columns->concatenate($q.columns)->filter(c|!$c->instanceOf(WindowColumn))->removeDuplicates({a,b|$a->match([a:Alias[1]|$a.name,a:Any[1]|'']) == $b->match([b:Alias[1]|$b.name,b:Any[1]|'x'])})->concatenate($cols),
//                            filteringOperation += $q.filteringOperation,
//                            savedFilteringOperation += $q.savedFilteringOperation,
//                            extraFilteringOperation += $q.extraFilteringOperation,
//                            groupBy = if ($q.groupBy->isEmpty(), | $a.groupBy, | $q.groupBy)
//                         );
//               );
//      }, $querySet->first()->toOne()
//   );
//
//   let filtered = ^$res
//   (
//      leftSideOfFilter = if($querySet->at(0).leftSideOfFilter->isEmpty(),|[],|$querySet->at(0).leftSideOfFilter->toOne()->findOneNode($querySet->at(0).data->toOne(), $res.data->toOne())),
//      savedFilteringOperation = $res.savedFilteringOperation->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
//                                                            ->map(p| let originalQuery = $querySet->filter(q|!$q.data->isEmpty() && $q.data->toOne()->getAllNodes()->contains($p.first));
//                                                                     pair(if ($originalQuery->isEmpty(),|$p.first,|$p.first->findOneNode($originalQuery->at(0).data->toOne(), $res.data->toOne())), $p.second);
//                                                             ),
//      extraFilteringOperation = $res.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
//   );
//
//
//   $filtered->validate($extensions);
//
//   print(if(!$context.debug, |'', |$context.space+'   Merge Result: '+$filtered->printDebugQuery($context.space, $extensions))
//        );
//
//   $filtered;
    $preQuerySet->at(0);
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::buildNodeId(startNode:String[1], preToAdd:String[1]):String[1]
{
   let toAdd = if($preToAdd == '_i0',|'_d',|$preToAdd);
   let res = if ($startNode == '',
      |$toAdd,
      |let lastIndexParsed = $startNode->lastIndexOf('#');
       let existingNumber = if($lastIndexParsed == -1,
                                 | // No #
                                   pair(1, $startNode->length());,
                                 | let number = $startNode->substring($lastIndexParsed+1,$startNode->length());
                                   if ($number->indexOf('_') == -1,
                                      |// Extract the value from the #
                                       pair($number->parseInteger(), $lastIndexParsed),
                                      |// We have a # but it's not terminal
                                       pair(1, $startNode->length())
                                   );
                            );
       let lastIndex = $existingNumber.second;
       let lastUnder = $startNode->lastIndexOf('_');
       let lastPattern = $startNode->substring($lastUnder, $lastIndex);
       if ($toAdd == $lastPattern,
          |let number = $existingNumber.first+1;
           $startNode->substring(0, $lastIndex)+'#'+$number->toString();,
          |$startNode+$toAdd;
       );
   );
   $res;
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::instanceValueAtParameter(expression : FunctionExpression[1], index : Integer[1]) : Any[1]
{
    instanceValuesAtParameter($expression,$index,[],[])->at(0);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::defaultState(mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1]):State[1]
{
   //filterChainDepth=0,
   ^State(inScopeVars=$inScopeVars, supportedFunctions=getSupportedFunctions(), mapping=$mapping, inProject=false, inProjectFunctions=false, inFilter=false, processingProjectionThread=false, shouldIsolate=true);   //contextBasedSupportedFunctions=getContextBasedSupportedFunctions());
}


function meta::external::store::document::functions::pureToDocumentStoreQuery::toSelectDocumentQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], execCtx: DocumentStoreExecutionContext[0..1], debug:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   toSelectDocumentQuery($functionExpression, $mapping, $inScopeVars, $debug, $execCtx->documentStoreExecutionContextToState(defaultState($mapping, $inScopeVars)), $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::toSelectDocumentQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], state:State[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let sel = $functionExpression
      ->processQuery($state, $debug, $extensions);
      //->applyPostProcessingForTempTableAsDriver($state, $debug, $extensions)
      //->manageDeepMapClassColumns($functionExpression, $debug, $state, $extensions);

  $sel->pushSavedFilteringOperation($extensions); //->pushExtraFilteringOperation($extensions); //->orderImmediateChildNodeByJoinAliasDependencies();

}

function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::processQuery(functionExpression:FunctionExpression[1], state:State[1], debug:DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   processValueSpecification( $functionExpression,
                              [],
                              ^SelectDocumentQuery(),
                              newMap([]->cast(@Pair<VariableExpression, ValueSpecification>), VariableExpression->classPropertyByName('name')->cast(@Property<VariableExpression,String|1>)),
                              $state,
                              $debug,
                              $extensions
                            )->cast(@SelectDocumentQuery)->toOne();
}


function <<access.private>> meta::external::store::document::functions::pureToDocumentStoreQuery::documentStoreExecutionContextToState(execCtx:DocumentStoreExecutionContext[0..1], s:State[1]):State[1]
{
   if ($execCtx->isEmpty(),
       |$s,
       |^$s
        (
           //preserveJoinOrder = $execCtx.preserveJoinOrder,
           //addDriverTablePkForProject = $execCtx.addDriverTablePkForProject,
           //insertDriverTablePkInTempTable = $execCtx.insertDriverTablePkInTempTable,
           //useTempTableAsDriver = $execCtx.useTempTableAsDriver,
           //importDataFlow = $execCtx.importDataFlow,
           importDataFlowAddFks = $execCtx.importDataFlowAddFks
           //importDataFlowFksByTable = $execCtx.importDataFlowFksByTable,
           //importDataFlowImplementationCount = $execCtx.importDataFlowImplementationCount
        )
   )
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::pushSavedFilteringOperation(s:SelectDocumentQuery[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   if ($s.savedFilteringOperation->isEmpty(),
         |$s,
         |^$s(
               savedFilteringOperation = [],
               filteringOperation = $s.filteringOperation->concatenate($s.savedFilteringOperation.second)->andFilters($extensions)
          )
   );
}

//function meta::external::store::document::functions::pureToDocumentStoreQuery::pushExtraFilteringOperation(s:SelectDocumentQuery[1], extensions:Extension[*]):SelectDocumentQuery[1]
//{
//   if ($s.extraFilteringOperation->isEmpty(),
//         |$s,
//         |^$s(
//               extraFilteringOperation = [],
//               filteringOperation=$s.filteringOperation->concatenate($s.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second)->andFilters($extensions)
//          )
//   );
//}

function meta::external::store::document::functions::pureToDocumentStoreQuery::combineFilters(s:DocumentStoreElement[*], and:Boolean[1], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   let ns = $s->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
   if ($ns->isEmpty(),
         |[],
         |if ($ns->size() == 1,
            | $ns->toOne(),
            | let dynaName = if($and,| 'and',| 'or');
              newAndOrDynaFunctionRelaxedBrackets($dynaName, $ns->reverse());
         )
   );
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::andFilters(s:DocumentStoreElement[*], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   $s->combineFilters(true, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::orFilters(s:DocumentStoreElement[*], extensions:Extension[*]):DocumentStoreElement[0..1]
{
   $s->combineFilters(false, $extensions);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::newAndOrDynaFunctionRelaxedBrackets(funcName: String[1], params: DocumentStoreElement[*]): DynaFunction[1]
{
   let potentiallyWrapedParams = $params->map(p | $p->match([ d: DynaFunction[1] | if($d.name->in(['and','or']) && $d.name != $funcName, | ^DynaFunction(name='group', parameters=$d), | $d),
                                                              r: DocumentStoreElement[1] | $r
                                                            ])
                                              );
   ^DynaFunction(name = $funcName, parameters = $potentiallyWrapedParams);
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::buildUniqueName(elements:DocumentStoreElement[*], alias:Boolean[1], extensions:Extension[*]):String[1]
{
   $elements->buildUniqueName($alias, true, $extensions)
}

function meta::external::store::document::functions::pureToDocumentStoreQuery::buildUniqueName(elements:DocumentStoreElement[*], alias:Boolean[1], selectFields:Boolean[1], extensions:Extension[*]):String[1]
{
   let uniqueName = $elements->map(e | $e->match($extensions->map(e|$e.moduleExtension('documentStore')->cast(@DocumentStoreExtension).pureToDocumentQuery_buildUniqueName)->map(f | $f->eval($alias, $selectFields, $extensions))->concatenate(
      [
         n:RootJoinDocumentTreeNode[1]|$n->getAllNodes()->map(a|$a->match([j:RootJoinDocumentTreeNode[1]|if($alias,|$j.alias.name,|$j.alias.documentElement->buildUniqueName($alias, $selectFields, $extensions))]))->makeString('_'),  //,j:JoinDocumentTreeNode[1]|$j.joinName
         s:SelectDocumentQuery[1]|'s('+if($selectFields,|$s.fields->buildUniqueName($alias, $selectFields, $extensions)+',',|'')+$s.data->buildUniqueName($alias, $selectFields, $extensions)+','+$s.filteringOperation->buildUniqueName($alias, $selectFields, $extensions)+')',
         //u:UnaryOperation[1]| $u->type()->toOne().name->toOne() + $u.nested->buildUniqueName($alias, $selectFields, $extensions),
         i:BinaryOperation[1]|$i->type()->toOne().name->toOne() + '_' + $i.left->buildUniqueName($alias, $selectFields, $extensions) + '_' + $i.right->buildUniqueName($alias, $selectFields, $extensions),
         a:Alias[1]|if($alias,|$a.name,|$a.documentElement->buildUniqueName($alias, $selectFields, $extensions)),
         //c:ColumnName[1]|$c.name,
         n:NamedDocumentRelation[1]|$n.name,
         //u:Union[1]|$u.queries->map(q|$q->buildUniqueName($alias, $selectColumns, $extensions))->joinStrings(),
         //c:TableAliasColumn[1]|$c.alias->buildUniqueName($alias, $selectColumns, $extensions)+$c.column.name;,
         l:Literal[1]| $l.value->toString(),    //if($l.value->instanceOf(VarPlaceHolder),|$l.value->cast(@VarPlaceHolder).name,|$l.value->toString()),
         l:LiteralList[1]|  $l.values->map(l|$l->buildUniqueName($alias, $selectFields, $extensions))->joinStrings(),
         //v:VariableArityOperation[1]|$v->type()->toOne().name->toOne() + '_' + $v.args->buildUniqueName($alias, $selectColumns, $extensions),
         d:DynaFunction[1]| $d.name +'_'+$d.parameters->buildUniqueName($alias, $selectFields, $extensions)
         //f:FreeMarkerOperationHolder[1]| $f.name +'_'+$f.parameters->buildUniqueName($alias, $selectColumns, $extensions),
         //wc:WindowColumn[1]| $wc.columnName+'_'+ $wc.func->buildUniqueName($alias,$selectColumns, $extensions),
         //j:JoinStrings[1]|'join_'+$j.strings->buildUniqueName($alias, $selectColumns, $extensions)+$j.prefix->buildUniqueName($alias, $selectColumns, $extensions)+$j.separator->buildUniqueName($alias, $selectColumns, $extensions)+$j.suffix->buildUniqueName($alias, $selectColumns, $extensions),
         //rj:RelationalOperationElementWithJoin[1]| $rj.joinTreeNode->toOne().joinName+ $rj.relationalOperationElement->buildUniqueName($alias, $selectColumns, $extensions),
         //ssp:SemiStructuredPropertyAccess[1]|'ssp('+$ssp.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssp.property->buildUniqueName($alias, $selectColumns, $extensions)+']'+if($ssp.index->isEmpty(),|'',|'['+$ssp.index->toOne()->buildUniqueName($alias, $selectColumns, $extensions)+']')+')',
         //ssa:SemiStructuredArrayElementAccess[1]|'ssa('+$ssa.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssa.index->buildUniqueName($alias, $selectColumns, $extensions)+'])',
         //ssf:SemiStructuredArrayFlatten[1]|'ss_flatten('+$ssf.navigation->buildUniqueName($alias, $selectColumns, $extensions)+')',
         //ssf:SemiStructuredArrayFlattenOutput[1]|'ss_flatten_output('+$ssf.tableAliasColumn->buildUniqueName($alias, $selectColumns, $extensions)+')',
         //v:VarPlaceHolder[1]| $v.name
      ])->toOneMany()
   ))->joinStrings('_');

   let maxSize = 535;
   if($uniqueName->length() > $maxSize, |$uniqueName->substring(0, $maxSize - 35) + '___' + $uniqueName->substring($maxSize - 35)->meta::pure::functions::hash::hash(meta::pure::functions::hash::HashType.MD5), |$uniqueName);
}




Class meta::external::store::document::functions::pureToDocumentStoreQuery::PureFunctionToRelationalFunctionPair extends Pair<meta::pure::metamodel::function::Function<Any>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectDocumentQuery[1], Map<VariableExpression, ValueSpecification>[1], State[1], DebugContext[1], Extension[*]->DocumentStoreElement[1]}>>
{
}