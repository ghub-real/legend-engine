// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::document::metamodel::*;
import meta::external::shared::format::binding::*;

Class meta::external::store::document::metamodel::DocumentStore extends meta::pure::store::set::SetBasedStore
{
    collections : NamedDocumentRelation[*];
    collection(name:String[1])
    {
        $this.collections->filter(t|$t.name == $name)->first();
    }:NamedDocumentRelation[0..1];
}

Class <<typemodifiers.abstract>> meta::external::store::document::metamodel::DocumentStoreElement
{
   //owner    : DocumentStore[0..1];
   //id       : String[0..1];
}

Class meta::external::store::document::metamodel::DocumentRelation extends DocumentStoreElement, meta::pure::store::set::SetRelation
{
   fields : DocumentStoreElement[*];
   primaryKey : Field[*];
}


Class <<typemodifiers.abstract>> meta::external::store::document::metamodel::NamedDocumentRelation extends DocumentRelation
{
   name     : String[1];
   id       : String[0..1];
}

Class meta::external::store::document::metamodel::Collection extends meta::external::store::document::metamodel::NamedDocumentRelation
{
   //fields  : Field[*];
   field(fieldName:String[1])
   {
        $this.fields->cast(@Field)->filter(c | $c.name == $fieldName )->first();
   }:Field[0..1];
}

Class meta::external::store::document::metamodel::CollectionFragment extends meta::external::store::document::metamodel::NamedDocumentRelation
{
    // TODO: Move to abstract class
   //fields: Field[*];
   field(fieldName:String[1])
   {
        $this.fields->cast(@Field)->filter(c | $c.name == $fieldName )->first();
   }:Field[0..1];
}

Class meta::external::store::document::metamodel::Field extends meta::external::store::document::metamodel::DocumentStoreElement, meta::pure::store::set::SetColumn
{
    <<equality.Key>> name : String[1];
    <<equality.Key>> type : meta::external::store::document::metamodel::TypeReference[1];
    nullable : Boolean[0..1];
    owner : DocumentRelation[0..1];
}


// Technically - this could be moved to common?? (as it is similar to servicestore typeref)
Class <<typemodifiers.abstract>> meta::external::store::document::metamodel::TypeReference
{
  list     : Boolean[1];
}

Class meta::external::store::document::metamodel::CoreDataType extends meta::external::store::document::metamodel::TypeReference
{
}

Class meta::external::store::document::metamodel::StringTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::BooleanTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::IntegerTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::LongTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::DateTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::DoubleTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::DecimalTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::ObjectIdTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
}

Class meta::external::store::document::metamodel::ObjectTypeReference extends meta::external::store::document::metamodel::CoreDataType
{
   type    : Class<Any>[1];
   binding : Binding[1];
}



Class meta::external::store::document::metamodel::CollectionAlias extends Alias
{
   setMappingOwner : meta::pure::mapping::PropertyMappingsImplementation[0..1];
   documentStore    : DocumentStore[0..1];
   documentRelation(){$this.documentElement->cast(@DocumentRelation)}:DocumentRelation[1];
}

Class meta::external::store::document::metamodel::Alias extends DocumentStoreElement
{
   <<equality.Key>> name : String[1];
   <<equality.Key>> documentElement : DocumentStoreElement[1];
}

//Equivalent of SQLQuery
Class meta::external::store::document::metamodel::DocumentQuery extends meta::external::store::document::metamodel::DocumentStoreElement
{
}


Class {doc.doc = 'Equivalent of select query'}
meta::external::store::document::metamodel::SelectDocumentQuery extends meta::external::store::document::metamodel::DocumentQuery, meta::external::store::document::metamodel::DocumentRelation
{
    distinct : Boolean[0..1];
    data : RootJoinDocumentTreeNode[0..1];
    filteringOperation : DocumentStoreElement[*];
    leftSideOfFilter : DocumentTreeNode[0..1];
    savedFilteringOperation : Pair<DocumentTreeNode, DocumentStoreElement>[*];
    // orderBy
    // groupBy
    // havingOperation
    // leftSideOfFilter
    //
}

Class meta::external::store::document::metamodel::DocumentTreeNode extends meta::pure::functions::collection::TreeNode
{
    alias : CollectionAlias[1];
//   Not yet implemented
   children()
    {
        $this.childrenData->cast(@JoinDocumentTreeNode)
    }:JoinDocumentTreeNode[*];
//    childByJoinName(s:String[1])
//    {
//        $this.children()->filter(c| $c.join.name == $s)->first()
//    }:JoinTreeNode[0..1];
}

Class meta::external::store::document::metamodel::RootJoinDocumentTreeNode extends DocumentTreeNode, DocumentRelation
{
// This is what you typially instantiate - so that you get the children from the DocumentTreeNode
}

Class meta::external::store::document::metamodel::JoinDocumentTreeNode extends DocumentTreeNode
{
// Not supporting
}


Class meta::external::store::document::metamodel::Literal extends meta::external::store::document::metamodel::DocumentStoreElement
{
   <<equality.Key>> value:Any[1];
}

Class meta::external::store::document::metamodel::LiteralList extends meta::external::store::document::metamodel::DocumentStoreElement
{
   <<equality.Key>> values:Literal[*];
}

Class meta::external::store::document::metamodel::DocumentNull
{
   //Used to make sure that any two Document field Null instances are equal
   <<equality.Key>> key:Nil[0];
   toString()
   {
      'DocumentNull'
   }:String[1];
}


Class meta::external::store::document::metamodel::Function extends DocumentStoreElement
{
}

Class meta::external::store::document::metamodel::Operation extends meta::external::store::document::metamodel::Function
{
}

Class meta::external::store::document::metamodel::DynaFunction extends Operation
{
    <<equality.Key>> name : String[1];
    <<equality.Key>> parameters : DocumentStoreElement[*];
}

Class meta::external::store::document::metamodel::BinaryOperation extends meta::external::store::document::metamodel::Operation
{
    <<equality.Key>> left:DocumentStoreElement[1];
    <<equality.Key>> right:DocumentStoreElement[1];
}

Class meta::external::store::document::metamodel::FieldName extends meta::external::store::document::metamodel::DocumentStoreElement
{
    <<equality.Key>> name : String[1];
}


Class meta::external::store::document::metamodel::JoinStrings extends meta::external::store::document::metamodel::Operation
{
    strings:DocumentStoreElement[*];
    prefix:DocumentStoreElement[0..1];
    separator:DocumentStoreElement[0..1];
    suffix:DocumentStoreElement[0..1];
}