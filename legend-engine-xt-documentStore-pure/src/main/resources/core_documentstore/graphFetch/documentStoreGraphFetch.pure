// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;

import meta::external::store::document::graphFetch::executionPlan::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::external::store::document::metamodel::*;
import meta::external::store::document::metamodel::runtime::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::*;
import meta::external::store::document::extension::documentQueryToString::*;
import meta::external::store::document::functions::typeInference::*;
import meta::external::store::document::mapping::functions::*;


Class meta::external::store::document::graphFetch::executionPlan::DocumentStoreGraphFetchExecutionNode extends LocalGraphFetchExecutionNode
{
   //<<doc.deprecated>> relationalNode : ExecutionNode[0..1];
   children : DocumentStoreGraphFetchExecutionNode[*];
}

//Class <<doc.deprecated>> meta::relational::graphFetch::executionPlan::RelationalTempTableGraphFetchExecutionNode extends RelationalGraphFetchExecutionNode
//{
//   tempTableName : String[1];
//   columns : SQLResultColumn[*];
//}
//
//Class <<doc.deprecated>>  meta::relational::graphFetch::executionPlan::RelationalRootGraphFetchExecutionNode extends RelationalTempTableGraphFetchExecutionNode
//{
//}
//
//Class <<doc.deprecated>> meta::relational::graphFetch::executionPlan::RelationalCrossRootGraphFetchExecutionNode extends RelationalTempTableGraphFetchExecutionNode
//{
//   parentTempTableName : String[1];
//   parentTempTableColumns : SQLResultColumn[*];
//}

Class meta::external::store::document::graphFetch::executionPlan::DocumentStoreClassQueryTempTableGraphFetchExecutionNode extends DocumentStoreGraphFetchExecutionNode  // By pass the temp table class RelationalTempTableGraphFetchExecutionNode
{
}

Class meta::external::store::document::graphFetch::executionPlan::DocumentStorePrimitiveQueryGraphFetchExecutionNode extends DocumentStoreGraphFetchExecutionNode
{
}

Class meta::external::store::document::graphFetch::executionPlan::DocumentStoreRootQueryTempTableGraphFetchExecutionNode extends DocumentStoreClassQueryTempTableGraphFetchExecutionNode
{
  batchSize : Integer[0..1];
  enableConstraints : Boolean[1];
  checked : Boolean[1];
  //tempCollectionName: String[1];
}

// Class meta::relational::graphFetch::executionPlan::DocumentStoreCrossRootQueryTempTableGraphFetchExecutionNode extends RelationalClassQueryTempTableGraphFetchExecutionNode
// {
//   parentTempTableName    : String[1];
//   parentTempTableColumns : SQLResultColumn[*];
// }

//function <<access.private>> meta::relational::graphFetch::executionPlan::tempTableName(index: Integer[1]):String[1]
//{
//   'temp_table_node_' + toString($index)
//}
//
//function <<access.private>> meta::relational::graphFetch::executionPlan::crossTempTableName(index: Integer[1]):String[1]
//{
//   'cross_temp_table_node_' + toString($index)
//}

function meta::external::store::document::graphFetch::executionPlan::planRootGraphFetchExecutionDocumentStore(sq: StoreQuery[1], ext: RoutedValueSpecification[0..1], clusteredTree: ClusteredGraphFetchTree[1], orderedPaths: String[*], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], enableConstraints: Boolean[1], checked: Boolean[1], extensions: Extension[*], debug: DebugContext[1]): LocalGraphFetchExecutionNode[1]
{
   let fe           = $sq.fe->evaluateAndDeactivate();
   let lhsFe        = $fe.parametersValues->evaluateAndDeactivate()->at(0)->byPassRouterInfo()->cast(@FunctionExpression);
   let rootTree     = $clusteredTree->byPassClusteringInfo()->cast(@RoutedRootGraphFetchTree<Any>);
   let setImpls     = $rootTree.sets->cast(@RootDocumentInstanceSetImplementation);
   let store        = $sq.store->cast(@DocumentStore);
   let dbConnection = $runtime->connectionByElement($store)->toOne()->cast(@meta::external::store::document::runtime::connections::TestDocumentStoreConnection)->map(x | ^$x(element = $store));
   //let dbConnection = $runtime->connectionByElement($store)->toOne()->cast(@DatabaseConnection)->map(x | ^$x(element = $store));
   let oneRuntime   = ^Runtime(connections = [$dbConnection]);
   let batchSize    = if($fe.func == graphFetch_T_MANY__RootGraphFetchTree_1__Integer_1__T_MANY_, | $fe->instanceValueAtParameter(2)->cast(@Integer), | 1000);

   let simplePrimitiveProperties = $rootTree.subTrees->filter(x | !$x->cast(@RoutedPropertyGraphFetchTree).propertyMapping->toOne()->cast(@DocumentPropertyMapping).documentStoreElement->cast(@Field).type->instanceOf(meta::external::store::document::metamodel::ObjectIdTypeReference))->cast(@PropertyGraphFetchTree).property->cast(@Property<Nil,Any|*>);

   /* Assert conditions on sets */
   $setImpls->map(x | $x->assertConditionsOnSetImpl($simplePrimitiveProperties));

   /* Generate Document Query */
   let pureToDocumentQueryState      = createPureToDocumentQueryState($simplePrimitiveProperties, $sq.inScopeVars, $mapping, $exeCtx);
   let selectDocumentQuery    = $lhsFe->toSelectDocumentQuery($mapping, $sq.inScopeVars, $debug, $pureToDocumentQueryState, $extensions);

   let mongoDBConnection = ^meta::external::store::document::metamodel::runtime::DatabaseConnection(
     type=meta::external::store::document::metamodel::runtime::DatabaseType.Mongo,
     element='element'
    );
   
   let documentNode       = $selectDocumentQuery->meta::external::store::document::graphFetch::executionPlan::buildDocumentQueryExecutionNode($mongoDBConnection, $extensions);
   
   // TODO
   //let postProcessorResult = $selectDocumentQuery->toOne()->cast(@SelectSQLQuery)->postProcessSQLQuery($store, $ext, $mapping, $oneRuntime, $exeCtx, $extensions);
   //let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);

   /* Create execution node */
   // noSqlNode       = $postProcessedQuery->buildSQLExecutionNode($dbConnection, $extensions);
   //let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   //let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);


   ^DocumentStoreRootQueryTempTableGraphFetchExecutionNode
   (
      resultType     = $rootTree->resultTypeFromGraphFetchTree(),
      nodeIndex      = 0,
      graphFetchTree = $rootTree,
      batchSize      = $batchSize,
      //tempCollectionName  = 'root',
      //columns        = $sqlNode.resultColumns->filter(x | $x.label->startsWith('"pk_'))->map(x | ^SQLResultColumn(label = $x.label->substring(1, $x.label->length() - 1), dataType = $x.dataType->toOne())),
      //children       = $rootTree->generateRelationalChildGraphNodes($rootTree->nodePathName(), $setImpls, $simplePrimitiveProperties, $orderedPaths, $store, $mapping, $oneRuntime, $sq.inScopeVars, $exeCtx, $extensions, $debug),
      executionNodes = $documentNode,
      enableConstraints = $enableConstraints,
      checked = $checked
   );
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::generateRelationalChildGraphNodes(tree: RoutedGraphFetchTree[1], treePath: String[1], setImpls: DocumentInstanceSetImplementation[*], simplePrimitiveProperties: Property<Nil,Any|*>[*], orderedPaths: String[*], store: DocumentStore[1], mapping: Mapping[1], runtime: Runtime[1], inScopeVars: Map<String, List<Any>>[1], exeCtx: ExecutionContext[1], extensions:Extension[*], debug: DebugContext[1]): DocumentStoreGraphFetchExecutionNode[*]
{
   $tree.subTrees->cast(@RoutedPropertyGraphFetchTree)->map({st |
      let property = $st.property;

      if (!$simplePrimitiveProperties->contains($st.property),
          | if ($property->isPrimitiveValueProperty(),
                | $st->planGraphFetchExecutionPrimitiveChild($tree, $treePath, $orderedPaths, $setImpls, $store, $mapping, $runtime, $inScopeVars, $exeCtx, $extensions, $debug),
                | []
                // TODO: | $st->planGraphFetchExecutionNonPrimitiveChild($tree, $treePath, $orderedPaths, $setImpls, $store, $mapping, $runtime, $inScopeVars, $exeCtx, $extensions, $debug)
            ),
          | []
      );
   });
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::assertConditionsOnSetImpl(setImpl: DocumentInstanceSetImplementation[1], simplePrimitiveProperties: Property<Nil,Any|*>[*]):Boolean[1]
{
   let r = $setImpl->match([
      e: EmbeddedDocumentInstanceSetImplementation[1] | $e.setMappingOwner,
      r: RootDocumentInstanceSetImplementation[1] | $r
   ]);
   
   // assert($r.resolvePrimaryKey()->isNotEmpty(), | 'Primary Key definition is must in graph fetch flow');
   // assert($r->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty(), | 'Store group by not allowed in graph fetch flow');
   // assert($r->meta::relational::functions::pureToSqlQuery::getDistinct() != true,  | 'Store distinct not allowed in graph fetch flow');
   
   $simplePrimitiveProperties->forAll({prop |
      assert($setImpl.propertyMappingsByPropertyName($prop.name->toOne())->isNotEmpty(),    //$prop->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype() ||
             | 'Property "' + $prop.name->toOne() + '" is not mapped in the set: "' + $setImpl.id + '"')
   });
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::planGraphFetchExecutionPrimitiveChild(currentTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], parentPath: String[1], orderedPaths: String[*], parentSets: DocumentInstanceSetImplementation[*], store: DocumentStore[1], mapping: Mapping[1], runtime: Runtime[1], inScopeVars: Map<String, List<Any>>[1], exeCtx : ExecutionContext[1], extensions:Extension[*], debug : DebugContext[1]): DocumentStorePrimitiveQueryGraphFetchExecutionNode[1]
{
   let currentPath = $parentPath + '.' + $currentTree->nodePathName();

   /* Assertions */
   assert($parentPath->in($orderedPaths),   | 'Unknown path ' + $parentPath  + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));
   assert($currentPath->in($orderedPaths),  | 'Unknown path ' + $currentPath + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));

   let parentIdx        = $orderedPaths->indexOf($parentPath);
   let currentIdx       = $orderedPaths->indexOf($currentPath);
   let currentIdxString = $currentIdx->toString();

   /* Generate Sql Query */
   let primitiveQuery     = generatePrimitivePropertyQuery($parentSets, $currentTree, $parentTree, $mapping, $inScopeVars, $debug, $extensions);  //$mc,

   let resultFieldName  = '"node_' + $currentIdxString + '_result"';
   let namedFieldQuery   = ^$primitiveQuery(fields = ^Alias(name = $resultFieldName, documentElement = $primitiveQuery.fields->toOne()));
   //let changedDriverQuery = $namedColumnQuery->changeDriverToTempWithPkProjection(tempTableName($parentIdx), $parentSets, $extensions);
   //let shouldManageAgg    = $currentTree.property->instanceOf(QualifiedProperty) && $currentTree.property->containsAggregationFunctionInFunction(defaultState($mapping, $inScopeVars).supportedFunctions);
   //let managedAggQuery    = if ($shouldManageAgg,
   //                             | ^$changedDriverQuery
   //                               (
   //                                  groupBy = $changedDriverQuery.columns->filter(x | $x->cast(@Alias).name != $resultColumnnName)
   //                               ),
   //                             | ^$changedDriverQuery
   //                               (
   //                                  filteringOperation = andFilters($changedDriverQuery.filteringOperation->concatenate($changedDriverQuery.columns->cast(@Alias)->filter(x | $x.name == $resultColumnnName)->map(x | ^DynaFunction(name = 'isNotNull', parameters =  $x.relationalElement))->toOne()), $extensions)
   //                               )
   //                         );

   //let postProcessorResult = $managedAggQuery->postProcessSQLQuery($store, [], $mapping, $runtime, $exeCtx, $extensions);
   //let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);
   let postProcessedQuery = $namedFieldQuery->cast(@SelectDocumentQuery);

   /* Create execution node */
   // let dbConnection  = $runtime.connections->toOne()->cast(@meta::relational::runtime::TestDatabaseConnection);
   let mongoDBConnection = ^meta::external::store::document::metamodel::runtime::DatabaseConnection(
     type=meta::external::store::document::metamodel::runtime::DatabaseType.Mongo,
     element='element'
    );
   let sqlNode       = $postProcessedQuery->buildDocumentQueryExecutionNode($mongoDBConnection, $extensions);

   //let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   //let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);

   ^DocumentStorePrimitiveQueryGraphFetchExecutionNode
   (
      resultType     = ^ResultType(type = $currentTree.property->functionReturnType().rawType->toOne()),
      nodeIndex      = $currentIdx,
      parentIndex    = $parentIdx,
      graphFetchTree = $currentTree
      //executionNodes = $wrappedNode
   );
}


function <<access.private>> meta::external::store::document::graphFetch::executionPlan::buildDocumentQueryExecutionNode(query: SelectDocumentQuery[1], dbConnection: DatabaseConnection[1], extensions:Extension[*]):DocumentQueryExecutionNode[1]
{
   let sql = $query->documentQueryToString($dbConnection.type, $dbConnection.timeZone, $dbConnection.quoteIdentifiers, $extensions);
   
   ^DocumentQueryExecutionNode
    (
       documentQuery         = $sql,
       resultFields    = $query.fields->cast(@Alias)->map(c | ^DocumentQueryResultField(label = $c.name, dataType = $c->inferDocumentStoreType()->toOne())), // not passing in meta::relational::translation::TranslationContext
       resultType       = ^ResultType(type = Any),
       connection       = $dbConnection->meta::external::store::document::mapping::functions::updateConnection($extensions)->cast(@DatabaseConnection),
       supportFunctions = documentStorePlanSupportFunctions($dbConnection)
    );
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::generatePrimitivePropertyQuery(setImpls: DocumentInstanceSetImplementation[*], propTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], mapping:Mapping[1], inScopeVars: Map<String, List<Any>>[1], debug: DebugContext[1], extensions:Extension[*]):SelectDocumentQuery[1]
{
   let isQualified    = false; // $propTree.property->instanceOf(QualifiedProperty);
   let pureToDocumentQueryState = defaultState($mapping, $inScopeVars);
   let srcSetImpl     = $setImpls->match([
      s:RootDocumentInstanceSetImplementation[1]     | $s,
      s:EmbeddedDocumentInstanceSetImplementation[1] | $s.setMappingOwner;
   ])->cast(@RootDocumentInstanceSetImplementation);

   let mainCollection     = $srcSetImpl.mainDocumentRelation->processDocumentRelation([], '', false, 0, false, $pureToDocumentQueryState, $debug, $extensions);

   let currentNode   = ^RootJoinDocumentTreeNode(alias=^CollectionAlias(name = 'root', documentElement = $mainCollection));
   let base = ^SelectDocumentQuery(data = $currentNode)->applyTypeFilter($srcSetImpl, '_gftm', $pureToDocumentQueryState, $debug, $extensions);
   //let base          = ^$basePreFilter(select = $basePreFilter.select->pushFilters($extensions));
   
   let res = if ($isQualified,
                {|
                   let qualifier    = $propTree.property->cast(@QualifiedProperty<Any>);
                   let newVars      = $qualifier->functionType().parameters->evaluateAndDeactivate()->tail()->map(x | pair($x.name, list($propTree.parameters->evaluateAndDeactivate()->at($qualifier->functionType().parameters->evaluateAndDeactivate()->indexOf($x) - 1)->evaluateAndDeactivate()->reactivate($inScopeVars)->evaluateAndDeactivate())));
                   let updatedState = ^$pureToDocumentQueryState(inGetterFlow = true, qualifierBase=^OperationWithParentPropertyMapping(element = $base), inScopeVars = $pureToDocumentQueryState.inScopeVars->putAll($newVars));
                   // TODO
                   //processQualifiedProperty($qualifier, [], $base, ^Map<VariableExpression, ValueSpecification>(), $updatedState, $debug, $extensions).element->cast(@SelectWithCursor);
                   $base;
                },
                {|
                   processPropertyMapping($propTree.propertyMapping, $parentTree->typeFromGraphFetchTree()->cast(@Class<Any>), $base, ^$pureToDocumentQueryState(inGetterFlow = true), $debug, $extensions)->cast(@SelectDocumentQuery)
                }
             );

  ^$res(distinct = true);
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::createPureToDocumentQueryState(simplePrimitiveProperties: Property<Nil,Any|*>[*], inScopeVars: Map<String, List<Any>>[1], mapping: Mapping[1], exeCtx: ExecutionContext[1]):State[1]
{
   let defaultPureToDocumentQueryState = defaultState($mapping, $inScopeVars);
   let sqlStateAsPerContext  = if($exeCtx->isNotEmpty() && $exeCtx->toOne()->instanceOf(DocumentStoreExecutionContext),
                                  | let docContext = $exeCtx->toOne()->cast(@DocumentStoreExecutionContext);
                                    ^$defaultPureToDocumentQueryState();
                                     //(
                                        //preserveJoinOrder              = $docContext.preserveJoinOrder,
                                        //addDriverTablePkForProject     = $docContext.addDriverTablePkForProject,
                                        //insertDriverTablePkInTempTable = $docContext.insertDriverTablePkInTempTable,
                                        //useTempTableAsDriver           = $docContext.useTempTableAsDriver
                                     //);
                                     ,
                                  | $defaultPureToDocumentQueryState
                               );
   ^$sqlStateAsPerContext
    (
       graphFetchFlow       = true,
       graphFetchProperties = $simplePrimitiveProperties
    );
}

function <<access.private>> meta::external::store::document::graphFetch::executionPlan::tempTableName(index: Integer[1]):String[1]
{
   'temp_table_node_' + toString($index)
}
