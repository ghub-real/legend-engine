// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import meta::pure::extension::*;
import meta::pure::graphFetch::*;
import meta::pure::runtime::*;
import meta::external::store::document::extension::*;
import meta::external::store::document::metamodel::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::external::store::document::metamodel::runtime::*;
import meta::external::store::document::extension::documentQueryToString::*;
import meta::external::store::document::functions::pureToDocumentStoreQuery::*; // for all the rest process operation stuff
import meta::external::store::document::functions::typeInference::*;
import meta::document::executionPlan::platformBinding::legendJava::*;
import meta::pure::executionPlan::platformBinding::legendJava::*;

Profile meta::external::store::document::extension::db
{
   stereotypes: [DocumentStoreExtensionLoader];
}

Class meta::external::store::document::extension::DocumentStoreExtension extends ModuleExtension
{

   documentQueryToString_processOperation : meta::pure::metamodel::function::Function<{Nil[1], Format[1], GenerationState[1], Config[1], Extension[*] -> meta::pure::metamodel::function::Function<{Nil[1]->String[1]}>[*]}>[0..1];
   pureToDocumentQuery_buildUniqueName : meta::pure::metamodel::function::Function<{Boolean[1], Boolean[1], Extension[*] -> meta::pure::metamodel::function::Function<{Nil[1]->String[1]}>[*]}>[0..1];

   //relational_execution_postProcessors : Function<{PostProcessorResult[1], Runtime[1], RoutedValueSpecification[0..1], Mapping[0..1], Database[0..1], ExecutionContext[1] -> PostProcessorResult[1]}>[*];
   //relational_plan_postProcessors : Function<{PostProcessorResult[1], Runtime[1], RoutedValueSpecification[0..1], Mapping[0..1], Database[0..1], ExecutionContext[1] -> PostProcessorResult[1]}>[*];
  documentStore_plan_updateConnection : meta::pure::metamodel::function::Function<{Nil[1]->Connection[1]}>[*];

   documentQueryToString_isBooleanOperation : meta::pure::metamodel::function::Function<{Nil[1] -> Boolean[1]}>[*];
}

function meta::external::store::document::extension::documentStoreExtensions()  : meta::pure::extension::Extension[1]
{
   [documentStoreExtension('documentStore')]
}


function <<access.private>> meta::external::store::document::extension::documentStoreExtension(type:String[1]) : meta::pure::extension::Extension[1]
{
   ^Extension
   (
      type = $type,
      availableStores = meta::pure::extension::defaultExtensions().availableStores->concatenate(meta::external::store::document::contract::documentStoreStoreContract()),
      serializerExtension =  meta::external::store::document::extension::documentQueryToString::documentStoreSerializerExtension_String_1__String_1_,
      graphExtension_calculateSourceTree = {tree:RootGraphFetchTree<Any>[1] |
         {rsi: RootDocumentInstanceSetImplementation[1] |
            $tree;
         }
      },
      //TODO: Move this out along with Java Binding
      availablePlatformBindings = meta::pure::extension::defaultExtensions().availablePlatformBindings->concatenate(
         meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBinding([
           meta::document::executionPlan::platformBinding::legendJava::documentLegendJavaPlatformBindingExtension()
         ])
      )
  )
}

function meta::external::store::document::extension::documentQueryToString::documentStoreSerializerExtension(version:String[1]):String[1]
{
  println('meta::external::store::document::extension::documentQueryToString::documentStoreSerializerExtension');
   let a = 'meta::protocols::pure::'+$version+'::extension::store::document::getDocumentStoreExtension_String_1__SerializerExtension_1_';
   $a;
}


function meta::external::store::document::extension::documentQueryToString::processOperation(documentStoreElement:DocumentStoreElement[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   processOperation($documentStoreElement, createDbConfig($dbType, [], []), ^Format(newLine='', indent=''), ^Config(), $extensions)
}


function meta::external::store::document::extension::documentQueryToString::createDbConfig( dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1]):DbConfig[1]
{
   ^DbConfig(
      dbType = $dbType,
      dbTimeZone = $dbTimeZone,
      quoteIdentifiers = if($quoteIdentifiers->isEmpty(), |false, |$quoteIdentifiers->toOne()),
      dbExtension = $dbType->loadDbExtension()
   );
}


Class meta::external::store::document::extension::documentQueryToString::DbConfig
{
   dbType:DatabaseType[1];
   dbTimeZone:String[0..1];
   quoteIdentifiers:Boolean[1];

   dbExtension: DbExtension[1];

   isDbReservedIdentifier(str:String[1])
   {
     $this.dbExtension.isDbReservedIdentifier->eval($str);
   }: Boolean[1];

   literalProcessor(type:Type[1])
   {
     getLiteralProcessorForType($type, $this.dbExtension.literalProcessor);
   }: LiteralProcessor[1];

   selectDocumentQueryProcessor(s:SelectDocumentQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1])
   {
     $this.dbExtension.selectDocumentQueryProcessor->eval($s, $sgc, $isSubSelect);
   }: String[1];


   collectionNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.collectionNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.collectionNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   fieldNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.fieldNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.fieldNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   identifierProcessor(s:String[1])
   {
     $this.dbExtension.identifierProcessor->eval($s, $this);
   }: String[1];

   dynaFuncDispatch(d:DynaFunction[1], b: Boolean[1])
   {
     $this.dbExtension.dynaFuncDispatch->eval($d, $b);
   }: String[1];
}

Class meta::external::store::document::extension::documentQueryToString::DbExtensionLoader
{
   dbType: DatabaseType[1];
   loader: meta::pure::metamodel::function::Function<{->DbExtension[1]}>[1];
}

Class meta::external::store::document::extension::documentQueryToString::DbExtension
{
   isBooleanLiteralSupported: Boolean[1];
   collectionThresholdLimit: Integer[0..1];
   aliasLimit: Integer[0..1];
   coreTypeToDbSpecificSqlTranslator: meta::pure::metamodel::function::Function<{CoreDataType[1] -> String[0..1]}>[0..1];
   isDbReservedIdentifier: meta::pure::metamodel::function::Function<{String[1] -> Boolean[1]}>[1];
   literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1];
   selectDocumentQueryProcessor: meta::pure::metamodel::function::Function<{SelectDocumentQuery[1], SqlGenerationContext[1], Boolean[1] -> String[1]}>[1];
   collectionNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   fieldNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   identifierProcessor: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[1];
   dynaFuncDispatch: meta::pure::metamodel::function::Function<{DynaFunction[1], Boolean[1] -> String[1]}>[1];
}

Class meta::external::store::document::extension::documentQueryToString::SqlGenerationContext
{
   dbConfig: DbConfig[1];
   format: Format[1];
   generationState: GenerationState[1];
   config: Config[1];
   extensions: Extension[*];
}

Class meta::external::store::document::extension::documentQueryToString::Format
{
   newLine:String[1];
   indent:String[1];

   indentStack:String[*];

   separator(){
      $this.newLine + $this.indentStack->makeString();
   }:String[1];
}

Enum meta::external::store::document::extension::documentQueryToString::GenerationSide
{
   Select,
   Where
}

Class meta::external::store::document::extension::documentQueryToString::GenerationState
{
  <<equality.Key>> generationSide : GenerationSide[1];
  <<equality.Key>> withinWhenClause : Boolean[0..1];
}

Class meta::external::store::document::extension::documentQueryToString::Config
{
   //callingFromFilter : Boolean[0..1];
   useQuotesForTableAliasColumn : Boolean[0..1];
   //generateJoin:Boolean[0..1];
   //generateJoinTarget : TableAlias[0..1];
}

function meta::external::store::document::extension::documentQueryToString::loadDbExtension(dbType: DatabaseType[1]):DbExtension[1]
{
  let loader = getDbExtensionLoaders()->filter(l| $l.dbType == $dbType);
  assert($loader->size() > 0, 'No extension loaders found for dbType ' + $dbType->toString());
  assert($loader->size() < 2, 'Multiple extension loaders found for dbType ' + $dbType->toString());
  $loader->toOne().loader->eval();
}

function meta::external::store::document::extension::documentQueryToString::getDbExtensionLoaders():DbExtensionLoader[*]
{
  db->stereotype('DocumentStoreExtensionLoader').modelElements->cast(@meta::pure::metamodel::function::Function<{->DbExtensionLoader[1]}>)
    ->map(f| $f->eval())->sortBy(l| $l.dbType.name);
}

function meta::external::store::document::extension::documentQueryToString::processSelectDocumentQuery(s:SelectDocumentQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
      $sgc.dbConfig.selectDocumentQueryProcessor($s, $sgc, $isSubSelect);
}

function meta::external::store::document::extension::documentQueryToString::dynaFuncDispatch(d:DynaFunction[1], dbConfig:DbConfig[1]):String[1]
{
      $dbConfig.dynaFuncDispatch($d, false);
}

function meta::external::store::document::extension::documentQueryToString::processIdentifierWithDoubleQuotes(identifier:String[1], dbConfig : DbConfig[1], quoteChar: String[1]):String[1]
{
  // Do we need this?
  //$dbConfig.identifierProcessor($identifier, $dbConfig, $quoteChar);
  ''
}

function meta::external::store::document::extension::documentQueryToString::processFieldName(name:String[1], dbConfig:DbConfig[1]):String[1]
{
  // not used currently, see if we need it
   $dbConfig.identifierProcessor($dbConfig.fieldNameToIdentifier($name));
}

function meta::external::store::document::extension::documentQueryToString::processLiteral(literal:Literal[1], dbConfig : DbConfig[1]) : String[1]
{
   $literal.value->processLiteralValue($dbConfig);
}

function meta::external::store::document::extension::documentQueryToString::getDefaultLiteralProcessors():Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(Enum,           ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_->literalTransform())),
      pair(String,         ^LiteralProcessor(format = '\'%s\'', transform = convertStringToDocumentQueryString_String_1__String_1_->literalTransform())),
      pair(Number,         ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_->literalTransform())),
      pair(Integer,        ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_->literalTransform())),
      pair(Float,          ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_->literalTransform())),
      pair(Decimal,        ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_->literalTransform())),
      pair(Boolean,        ^LiteralProcessor(format = '\'%s\'', transform = toString_Any_1__String_1_->literalTransform())),
      pair(DocumentNull,        ^LiteralProcessor(format = '%s',     transform = convertNullToDocumentQueryString_DocumentNull_1__String_1_->literalTransform())),
      //pair(StrictDate,     ^LiteralProcessor(format = '\'%s\'', transform = {d:StrictDate[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = '\'%s\'', transform = {d:DateTime[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)}))
      //pair(Date,           ^LiteralProcessor(format = '\'%s\'', transform = {d:Date[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)}))
   ]);
}

function meta::external::store::document::extension::documentQueryToString::processLiteralValue(a:Any[1], dbConfig : DbConfig[1]) : String[1]
{
   let processor = $dbConfig.literalProcessor($a->type());
   $processor.formatValue($a, $dbConfig.dbTimeZone);
}

function meta::external::store::document::extension::documentQueryToString::convertStringToDocumentQueryString(s:String[1]):String[1]
{
   $s->replace('\'', '\'\'')->replace('\@@','\'')
}

function meta::external::store::document::extension::documentQueryToString::convertNullToDocumentQueryString(s:DocumentNull[1]):String[1]
{
   'null'
}


function meta::external::store::document::extension::documentQueryToString::literalTransform<K>(t: meta::pure::metamodel::function::Function<{K[1] -> String[1]}>[1]): meta::pure::metamodel::function::Function<{K[1], String[0..1] -> String[1]}>[1]
{
  {x:K[1], dbTimeZone:String[0..1]| $t->eval($x)};
}


function meta::external::store::document::extension::documentQueryToString::getLiteralProcessorForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]): LiteralProcessor[1]
{
//   if($type->equal(VarPlaceHolder),
//      |^LiteralProcessor(format = '%s', transform = {v:VarPlaceHolder[1], dbTimeZone:String[0..1] | convertPlaceHolderToSQLString($v, $literalProcessor, $dbTimeZone)}),
//      |
      $literalProcessor->eval($type);
}

function meta::external::store::document::extension::documentQueryToString::convertDateToSqlString(date:Date[1], dbTimeZone:String[0..1]):String[1]
{
   //Default to UTC, if timezone is not specified. GMT is the same as UTC, UTC is not actually a timezone
   let timeZone = if( $dbTimeZone->isEmpty(), | 'GMT', |  $dbTimeZone->toOne());
   if($date->hasSecond(),
      | if ($date->hasSubsecond(),
            | format('%t{[' + $timeZone + ']yyyy-MM-dd HH:mm:ss.SSSSSS}', $date),
            | format('%t{[' + $timeZone + ']yyyy-MM-dd HH:mm:ss}', $date)),
      | format('%t{[' + $timeZone + ']yyyy-MM-dd}', $date));
}

//function meta::external::store::document::extension::documentQueryToString::convertPlaceHolderToSQLString(v:VarPlaceHolder[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1], dbTimeZone:String[0..1]):String[1]
//{
//   let vType        = $v->getVariableType();
//
//   let prefixSuffix = getPrefixAndSuffixForType($vType, $literalProcessor);
//   let prefix       = $prefixSuffix.first;
//   let suffix       = $prefixSuffix.second;
//   let value        = processPlaceHolder($v, $vType, $prefix, $suffix, $dbTimeZone);
//}
//
//function meta::external::store::document::extension::documentQueryToString::processPlaceHolder(v:VarPlaceHolder[1], type:Type[1], prefix:String[1], suffix:String[1], dbTimeZone:String[0..1]): String[1]
//{
//   let noPropertyPath              = $v.propertyPath->isEmpty();
//   let optionalHandler             = if($v->isOptionalPlaceHolder() && $noPropertyPath,|'![]',|'');
//   let placeHolderWithPath         = $v.name+if($noPropertyPath,|'',|'.')+$v.propertyPath->map(p|$p.name)->joinStrings('.');
//   let resolvedPlaceHolder         = if($type == String,
//                                           | $placeHolderWithPath->convertStringToSQLString(),
//                                           | $placeHolderWithPath) + $optionalHandler;
//
//   let isPossibleDateTimeType      = [Date, DateTime]->contains($v.type);
//   let possiblyApplyDateTzFunction = if($isPossibleDateTimeType,| processDatePlaceHolder($resolvedPlaceHolder, $dbTimeZone),| $resolvedPlaceHolder);
//
//   if($v->isCollectionPlaceHolder(),
//      |if($resolvedPlaceHolder == $possiblyApplyDateTzFunction,
//         |'${renderCollection('+ $resolvedPlaceHolder + ' \",\" \"' + $prefix + '\" \"' + $suffix + '\" ' + placeHolderDefaultValue() +')}',
//         |'${renderCollectionWithTz('+ $resolvedPlaceHolder + ' "['+ $dbTimeZone->toOne() + ']" ' + '\",\" \"' + $prefix + '\" \"' + $suffix + '\" ' + placeHolderDefaultValue() +')}'),
//      |if($v->isOptionalPlaceHolder(),
//          |'${varPlaceHolderToString(' + $possiblyApplyDateTzFunction + ' \"' + $prefix + '\" \"'+ $suffix + '\" '+ placeHolderDefaultValue()+')}',
//          |$prefix + '${'+$possiblyApplyDateTzFunction+'}' + $suffix)
//      );
//}
//
//function <<access.private>> meta::external::store::document::extension::documentQueryToString::getPrefixAndSuffixForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]):Pair<String, String>[1]
//{
//   let lp           = $literalProcessor->eval($type);
//   // We need this replace here to mimic what we would have done if we had executed the format string on input.
//   // %% is used in format to escape a required % symbol. We don't need to do this while building freemarker context
//   let lpFormat     = $lp.format->replace('%%', '%');
//
//   let index        = $lpFormat->indexOf('%s');
//   let prefix       = $lpFormat->substring(0, $index);
//   let suffix       = $lpFormat->substring($index+2);
//
//   ^Pair<String, String>(first = $prefix, second = $suffix);
//}


Class meta::external::store::document::extension::documentQueryToString::LiteralProcessor
{
   types:Type[*];
   format: String[1];
   transform: meta::pure::metamodel::function::Function<{Nil[1], String[0..1] -> String[1]}>[1];

   formatValue(value:Any[1], dbTimeZone:String[0..1]) {
      $this.format->format($this.transformValue($value, $dbTimeZone))
   }:String[1];

   transformValue(value:Any[1], dbTimeZone:String[0..1]) {
      $this.transform->eval($value, $dbTimeZone)
   }:String[1];
}

function meta::external::store::document::extension::documentQueryToString::documentQueryToString(documentQuery:SelectDocumentQuery[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   documentQueryToString($documentQuery, $dbType, [], [], $extensions);
}

function meta::external::store::document::extension::documentQueryToString::documentQueryToString(documentQuery:SelectDocumentQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
{
   documentQueryToString($documentQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='', indent=''), $extensions);
}

function meta::external::store::document::extension::documentQueryToString::documentQueryToStringPretty(documentQuery:SelectDocumentQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
{
   documentQueryToString($documentQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='\n', indent='\t'), $extensions);
}

function meta::external::store::document::extension::documentQueryToString::documentQueryToString(documentQuery:SelectDocumentQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], format:Format[1], extensions:Extension[*]):String[1]
{
  processOperation($documentQuery, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), $format, ^Config(), $extensions)
}


function meta::external::store::document::functions::typeInference::inferDocumentStoreType(dop: DocumentStoreElement[1]):meta::external::store::document::metamodel::TypeReference[0..1] // removed , translationContext:TranslationContext[1]
{
   let documentStoreType = inferDocumentStoreType($dop, true);
   //$relationalType->translateCoreTypeToDbSpecificType($translationContext);
   $documentStoreType;
}

function meta::external::store::document::functions::typeInference::inferDocumentStoreType(dop: DocumentStoreElement[1], failOnMatchFailure:Boolean[1]):meta::external::store::document::metamodel::TypeReference[0..1]
{
   $dop->match([
      //t : TableAliasColumn[1] | if($t.column.owner->isNotEmpty() && $t.column.owner->toOne()->instanceOf(View),| $t.column.owner->toOne()->cast(@View).columnMappings->filter(cm | $cm.columnName == $t.column.name)->toOne().relationalOperationElement->inferRelationalType($failOnMatchFailure), | $t.column.type),
      //j : RelationalOperationElementWithJoin[1] | $j.relationalOperationElement->toOne()->inferRelationalType($failOnMatchFailure),
      d : DynaFunction[1] | $d->inferDynaFunctionReturnType($failOnMatchFailure),
      d : Alias[1] | $d.documentElement->inferDocumentStoreType($failOnMatchFailure),
      l : Literal[1] | $l.value->match([
         s: String[1]  | ^meta::external::store::document::metamodel::StringTypeReference(list=false),
         b: Boolean[1] |  ^meta::external::store::document::metamodel::BooleanTypeReference(list=false),
         i: Integer[1] |  ^meta::external::store::document::metamodel::IntegerTypeReference(list=false),
         d: Float[1]   |  ^meta::external::store::document::metamodel::DoubleTypeReference(list=false),
         //d: StrictDate[1]   |  ^meta::external::store::document::metamodel::DateTypeReference(),
         d: Date[1]   |  ^meta::external::store::document::metamodel::DateTypeReference(list=false),
        //  d: meta::relational::functions::pureToSqlQuery::metamodel::VarPlaceHolder[1]   |
        //     if($d.type == String,
        //        | ^meta::relational::metamodel::datatype::Varchar(size = 4000),
        //        | if($d.type == Integer,
        //             | ^meta::relational::metamodel::datatype::Integer(),
        //             | if($d.type == Float,
        //                  | ^meta::relational::metamodel::datatype::Float(),
        //                  | if($d.type == Boolean,
        //                       | ^meta::relational::metamodel::datatype::Bit(),
        //                       | if($d.type->in([DateTime, Date]),
        //                            | ^meta::relational::metamodel::datatype::Timestamp(),
        //                            | if($d.type == StrictDate,
        //                                 | ^meta::relational::metamodel::datatype::Date(),
        //                                 | fail('Not supported yet!'); ^meta::relational::metamodel::datatype::DataType();
        //                              )
        //                         )
        //                    )
        //               )
        //          )
        //     ),
         a: Any[1]     | if($failOnMatchFailure, | fail('Not supported yet!'); ^meta::external::store::document::metamodel::CoreDataType(list=false);, |[]);
      ]),
      //j : meta::relational::metamodel::operation::JoinStrings[1] | ^meta::relational::metamodel::datatype::Varchar(size = $j.strings->concatenate($j.prefix)->concatenate($j.separator)->concatenate($j.suffix)->map(x | $x->inferRelationalType($failOnMatchFailure)->toOne()->getSize())->sum()),
      f:Field[1] | $f.type,
      l : Any[1] | if($failOnMatchFailure, | fail('Not supported yet!'); ^meta::external::store::document::metamodel::CoreDataType(list=false);, |[]);
   ]);
}

function meta::external::store::document::functions::typeInference::inferDynaFunctionReturnType(d: DynaFunction[1], failOnMatchFailure:Boolean[1]):meta::external::store::document::metamodel::TypeReference[0..1]
{
   let dfToReturnFunctionMap = meta::external::store::document::functions::typeInference::getDynaFunctionTypeInferenceMap();
   let candidateMatchAndDTypePairs = $dfToReturnFunctionMap->get($d.name).values;
   let filteredMatchAndDTypePairs = $candidateMatchAndDTypePairs->filter(p | $p.first->eval($d.parameters));
   if($failOnMatchFailure, | assert($filteredMatchAndDTypePairs->size() >= 1, 'Type inference not supported yet! Dyna function: ' + $d.name);, | []);
   if($filteredMatchAndDTypePairs->size() >= 1, | $filteredMatchAndDTypePairs->at(0).second->eval($d.parameters), | []);
}

function <<access.private>> meta::external::store::document::functions::typeInference::getDynaFunctionTypeInferenceMap():Map<String, List<Pair<meta::pure::metamodel::function::Function<{DocumentStoreElement[*]->Boolean[1]}>, meta::pure::metamodel::function::Function<{DocumentStoreElement[*]->meta::external::store::document::metamodel::TypeReference[0..1]}>>>>[1]
{
   newMap([
      pair(
         'and',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),


      pair(
         'convertDateTime',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::DateTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'count',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::LongTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'distinct',
         list([
            pair(
               {params: DocumentStoreElement[*] | $params->isNotEmpty()},
               {params: DocumentStoreElement[*] | $params->at(0)->inferDocumentStoreType()}
            )
         ])
      ),

      pair(
         'equal',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'exists',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'greaterThan',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'greaterThanEqual',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'in',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'isEmpty',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'isNotEmpty',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'isNotNull',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'isNull',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'lessThan',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'lessThanEqual',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),


      pair(
         'not',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'notEqual',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'or',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::BooleanTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'size',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | ^meta::external::store::document::metamodel::LongTypeReference(list=false)}
            )
         ])
      ),

      pair(
         'toOne',
         list([
            pair(
               {params: DocumentStoreElement[*] | true},
               {params: DocumentStoreElement[*] | $params->at(0)->inferDocumentStoreType()}
            )
         ])
      )

  ]);

}